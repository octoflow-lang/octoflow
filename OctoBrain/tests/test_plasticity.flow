// OctoBrain Plasticity Module Tests
// Tests for lib/plasticity.flow — uses PASS/FAIL print pattern.

use "../lib/vecmath"
use "../lib/edges"
use "../lib/plasticity"

// ── Helper: approximate equality ──────────────────────────────────
fn approx_eq(x, y, tol)
  let mut diff = x - y
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ══════════════════════════════════════════════════════════════════
// Test 1: Drift toward observation
// Proto at [1,0,0], drift toward [0.7,0.3,0]. Proto should move.
// ══════════════════════════════════════════════════════════════════

let mut embs1 = [1.0, 0.0, 0.0]
let observed1 = [0.7, 0.3, 0.0]
let d1 = drift_proto(embs1, 3.0, 0.0, observed1, 0.1, 0.0)

// After drift: x should be < 1.0, y should be > 0.0
let x1 = embs1[0]
let y1 = embs1[1]
if x1 < 1.0 && y1 > 0.0
  print("PASS test1: drift moves proto toward observation (x={x1:.4}, y={y1:.4})")
else
  print("FAIL test1: expected x < 1.0 and y > 0, got x={x1}, y={y1}")
end

// ══════════════════════════════════════════════════════════════════
// Test 2: Importance slows drift
// Higher importance → less movement.
// ══════════════════════════════════════════════════════════════════

// Drift with importance = 1.0
let mut embs2a = [1.0, 0.0, 0.0]
let obs2 = [0.7, 0.3, 0.0]
let d2a = drift_proto(embs2a, 3.0, 0.0, obs2, 0.1, 1.0)
let y2a = embs2a[1]

// Drift with importance = 10.0
let mut embs2b = [1.0, 0.0, 0.0]
let d2b = drift_proto(embs2b, 3.0, 0.0, obs2, 0.1, 10.0)
let y2b = embs2b[1]

// Higher importance should produce less y-movement
if y2a > y2b && y2b > 0.0
  print("PASS test2: importance slows drift (imp=1 y={y2a:.4}, imp=10 y={y2b:.4})")
else
  print("FAIL test2: expected y_imp1 > y_imp10 > 0, got y_imp1={y2a}, y_imp10={y2b}")
end

// ══════════════════════════════════════════════════════════════════
// Test 3: Drift preserves unit norm
// After drift, norm should still be ~1.0.
// ══════════════════════════════════════════════════════════════════

let mut embs3 = [1.0, 0.0, 0.0]
let obs3 = [0.5, 0.5, 0.5]
let d3 = drift_proto(embs3, 3.0, 0.0, obs3, 0.2, 0.0)

let norm3 = vec_norm(embs3, 3.0)
if approx_eq(norm3, 1.0, 0.001)
  print("PASS test3: drift preserves unit norm (norm={norm3:.4})")
else
  print("FAIL test3: expected norm ~1.0, got {norm3}")
end

// ══════════════════════════════════════════════════════════════════
// Test 4: Edge decay
// Create edge, apply decay factor 0.995, verify permanence decreased.
// ══════════════════════════════════════════════════════════════════

let mut edge_st = edges_new()
let mut en = []
let mut ea = []
let mut eo = []
let mut ep = []
let mut ew = []
let mut eact = []
let nids4 = [0.0, 1.0]
let r4 = edges_add(edge_st, en, ea, eo, ep, ew, eact, nids4, 1.0)

let perm_before = ep[0]
let d4 = decay_all_edges(edge_st, ep, 0.995)
let perm_after = ep[0]

// Initial permanence = 0.3, after decay = 0.3 * 0.995 = 0.2985
if perm_after < perm_before && approx_eq(perm_after, 0.2985, 0.001)
  print("PASS test4: edge decay reduces permanence ({perm_before:.4} -> {perm_after:.4})")
else
  print("FAIL test4: expected perm decrease to ~0.2985, got before={perm_before}, after={perm_after}")
end

// ══════════════════════════════════════════════════════════════════
// Test 5: Homeostasis split detection
// 2 protos, one gets 90% of matches → flagged for split.
// ══════════════════════════════════════════════════════════════════

let mut ps5 = map()
map_set(ps5, "proto_count", 2.0)
map_set(ps5, "embed_dim", 3.0)

// Proto 0: [1,0,0], Proto 1: [0,0,1] (orthogonal, no merge)
let mut pembs5 = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0]
// Proto 0 gets 90 matches, Proto 1 gets 10 → total 100
// Proto 0 has 90% > 20% threshold → should be flagged for split
let mut mc5 = [90.0, 10.0]

let mut h5 = map()
let mut splits5 = []
let mut merges5 = []
let d5 = homeostasis_check(ps5, pembs5, mc5, 3.0, h5, splits5, merges5)
let sc5 = map_get(h5, "split_count")
let mgc5 = map_get(h5, "merge_count")

if approx_eq(sc5, 1.0, 0.001) && approx_eq(mgc5, 0.0, 0.001)
  print("PASS test5: homeostasis detects split (split_count=1, merge_count=0)")
else
  print("FAIL test5: expected split_count=1 merge_count=0, got sc={sc5} mc={mgc5}")
end

// ══════════════════════════════════════════════════════════════════
// Test 6: Homeostasis merge detection
// 2 very similar protos (cosine > 0.95) → flagged for merge.
// ══════════════════════════════════════════════════════════════════

let mut ps6 = map()
map_set(ps6, "proto_count", 6.0)

// 6 protos: proto 0 and 1 are nearly identical (cosine > 0.95)
// protos 2-5 are orthogonal/different directions
// cosine_sim([1,0,0], normalize([0.99,0.1,0])) > 0.95
let n6a = sqrt(0.99 * 0.99 + 0.1 * 0.1)
let mut pembs6 = [1.0, 0.0, 0.0, 0.99 / n6a, 0.1 / n6a, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.577, 0.577, 0.577, 0.707, 0.0, 0.707]
// Balanced matches: each has 10, total=60, threshold=12
// No proto exceeds 12, so no splits
let mut mc6 = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0]

let mut h6 = map()
let mut splits6 = []
let mut merges6 = []
let d6 = homeostasis_check(ps6, pembs6, mc6, 3.0, h6, splits6, merges6)
let sc6 = map_get(h6, "split_count")
let mgc6 = map_get(h6, "merge_count")

// Should detect 1 merge pair (protos 0 and 1) and 0 splits
if mgc6 >= 1.0 && approx_eq(sc6, 0.0, 0.001)
  print("PASS test6: homeostasis detects merge (merge_count={mgc6}, split_count=0)")
else
  print("FAIL test6: expected merge_count>=1 split_count=0, got mc={mgc6} sc={sc6}")
end

// ══════════════════════════════════════════════════════════════════
// Test 7: Homeostasis no action needed
// Balanced protos with different directions → no splits or merges.
// ══════════════════════════════════════════════════════════════════

let mut ps7 = map()
map_set(ps7, "proto_count", 5.0)

// 5 orthogonal/distinct unit vectors — all different enough (cosine < 0.95)
let mut pembs7b = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.577, 0.577, 0.577, 0.707, 0.0, 0.707]
let mut mc7 = [10.0, 10.0, 10.0, 10.0, 10.0]
// total = 50, threshold = 10, each has 10 which is NOT > 10 (strictly >)

let mut h7 = map()
let mut splits7 = []
let mut merges7 = []
let d7 = homeostasis_check(ps7, pembs7b, mc7, 3.0, h7, splits7, merges7)
let sc7 = map_get(h7, "split_count")
let mgc7 = map_get(h7, "merge_count")

if approx_eq(sc7, 0.0, 0.001) && approx_eq(mgc7, 0.0, 0.001)
  print("PASS test7: homeostasis no action needed (split=0, merge=0)")
else
  print("FAIL test7: expected split=0 merge=0, got sc={sc7} mc={mgc7}")
end

print("--- plasticity tests complete ---")
