// OctoBrain Preprocessing Tests
// Tests for lib/preprocess.flow — auto-centering with EMA running mean.
// 6 tests.

use "../lib/preprocess"
use "../lib/vecmath"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(x, y, tol)
  let mut diff = x - y
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

print("=== Auto-Centering Preprocessor Tests ===")
print("")

// ══════════════════════════════════════════════════════════════
// Test 1: First call returns zeros, mean initialized
// ══════════════════════════════════════════════════════════════

let mut mean1 = []
let mut count1 = [0.0]
let data1 = [3.0, 4.0, 5.0]
let result1 = auto_center(data1, mean1, count1)

let r1_ok = approx_eq(result1[0], 0.0, 0.001) && approx_eq(result1[1], 0.0, 0.001) && approx_eq(result1[2], 0.0, 0.001)
let m1_ok = approx_eq(mean1[0], 3.0, 0.001) && approx_eq(mean1[1], 4.0, 0.001) && approx_eq(mean1[2], 5.0, 0.001)

if r1_ok && m1_ok
  print("PASS test1: first call returns [0,0,0], mean = [3,4,5]")
else
  print("FAIL test1: result=[{result1[0]:.4},{result1[1]:.4},{result1[2]:.4}], mean=[{mean1[0]:.4},{mean1[1]:.4},{mean1[2]:.4}]")
end

// ══════════════════════════════════════════════════════════════
// Test 2: Second call returns approximately (data - mean)
// Mean after first call: [3,4,5]. Feed [5,6,7].
// EMA update: mean = 0.99*[3,4,5] + 0.01*[5,6,7] = [3.02, 4.02, 5.02]
// Centered: [5,6,7] - [3.02,4.02,5.02] = [1.98, 1.98, 1.98]
// ══════════════════════════════════════════════════════════════

let data2 = [5.0, 6.0, 7.0]
let result2 = auto_center(data2, mean1, count1)

if approx_eq(result2[0], 1.98, 0.05) && approx_eq(result2[1], 1.98, 0.05) && approx_eq(result2[2], 1.98, 0.05)
  print("PASS test2: second call returns ~[1.98, 1.98, 1.98] (data - EMA mean)")
else
  print("FAIL test2: expected ~[1.98,1.98,1.98], got [{result2[0]:.4},{result2[1]:.4},{result2[2]:.4}]")
end

// ══════════════════════════════════════════════════════════════
// Test 3: After 100 constant calls with [10,10], mean ≈ [10,10]
// ══════════════════════════════════════════════════════════════

let mut mean3 = []
let mut count3 = [0.0]
let data3 = [10.0, 10.0]

// Call 99 times (first is init, rest are updates), discard results
let mut iter3 = 0.0
while iter3 < 99.0
  let r3_discard = auto_center(data3, mean3, count3)
  iter3 = iter3 + 1.0
end

// 100th call — capture the result fresh
let last_result3 = auto_center(data3, mean3, count3)

// Mean should be very close to [10, 10] after 100 iterations
let mean3_ok = approx_eq(mean3[0], 10.0, 0.1) && approx_eq(mean3[1], 10.0, 0.1)
// Centered should be very close to [0, 0]
let res3_ok = approx_eq(last_result3[0], 0.0, 0.1) && approx_eq(last_result3[1], 0.0, 0.1)

if mean3_ok && res3_ok
  print("PASS test3: after 100x [10,10], mean ≈ [10,10], centered ≈ [0,0]")
else
  print("FAIL test3: mean=[{mean3[0]:.4},{mean3[1]:.4}], centered=[{last_result3[0]:.4},{last_result3[1]:.4}]")
end

// ══════════════════════════════════════════════════════════════
// Test 4: center_reset clears state, next call acts like first
// ══════════════════════════════════════════════════════════════

let mut mean4 = []
let mut count4 = [0.0]
let data4a = [5.0, 5.0]
let r4a = auto_center(data4a, mean4, count4)

// Reset
let dummy = center_reset(mean4, count4)

// After reset, count should be 0 and mean empty
let count4_val = count4[0]
let mean4_len = len(mean4)

// Next call should act like first
let data4b = [7.0, 8.0]
let r4b = auto_center(data4b, mean4, count4)
let r4b_ok = approx_eq(r4b[0], 0.0, 0.001) && approx_eq(r4b[1], 0.0, 0.001)
let m4_ok = approx_eq(mean4[0], 7.0, 0.001) && approx_eq(mean4[1], 8.0, 0.001)

if r4b_ok && m4_ok && approx_eq(count4_val, 0.0, 0.001)
  print("PASS test4: center_reset clears state, next call acts like first")
else
  print("FAIL test4: after reset — result=[{r4b[0]:.4},{r4b[1]:.4}], mean=[{mean4[0]:.4},{mean4[1]:.4}], count={count4_val}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: Varying data — mean shifts toward new distribution
// Feed [1,0] 50×, then [0,1] 50× → mean[1] should be > 0
// ══════════════════════════════════════════════════════════════

let mut mean5 = []
let mut count5 = [0.0]

// Phase A: feed [1,0] 50 times
let mut iter5a = 0.0
while iter5a < 50.0
  let d5a = [1.0, 0.0]
  let r5a = auto_center(d5a, mean5, count5)
  iter5a = iter5a + 1.0
end

// Phase B: feed [0,1] 50 times
let mut iter5b = 0.0
while iter5b < 50.0
  let d5b = [0.0, 1.0]
  let r5b = auto_center(d5b, mean5, count5)
  iter5b = iter5b + 1.0
end

// After 50x [0,1] the mean[1] should have increased from ~0 toward positive
let mean5_dim1 = mean5[1]
if mean5_dim1 > 0.1
  print("PASS test5: mean shifts — after 50x [0,1], mean[1] = {mean5_dim1:.4} > 0.1")
else
  print("FAIL test5: mean didn't shift — mean[1] = {mean5_dim1:.4}, expected > 0.1")
end

// ══════════════════════════════════════════════════════════════
// Test 6: Works with high-dim (16D) data — no crash, reasonable
// ══════════════════════════════════════════════════════════════

let mut mean6 = []
let mut count6 = [0.0]

let mut iter6 = 0.0
while iter6 < 20.0
  let mut data6 = []
  let mut di = 0.0
  while di < 16.0
    push(data6, sin(iter6 * (di + 1.0) * 0.3))
    di = di + 1.0
  end
  let r6 = auto_center(data6, mean6, count6)
  iter6 = iter6 + 1.0
end

let mean6_len = len(mean6)
let count6_val = count6[0]

if approx_eq(mean6_len, 16.0, 0.001) && approx_eq(count6_val, 20.0, 0.001)
  print("PASS test6: 16D data — mean has 16 elements, count = 20")
else
  print("FAIL test6: expected 16 elements and count 20, got {mean6_len} elements, count {count6_val}")
end

print("")
print("--- preprocess tests complete ---")
