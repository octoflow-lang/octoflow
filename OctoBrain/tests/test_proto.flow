// OctoBrain Prototype Store Tests
// Tests for lib/proto.flow — uses PASS/FAIL print pattern.

use "../lib/proto"
use "../lib/vecmath"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(x, y, tol)
  let mut diff = x - y
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ══════════════════════════════════════════════════════════════
// Test 1: First observation creates first prototype
// ══════════════════════════════════════════════════════════════

let mut s1 = proto_new()
let mut embs1 = []
let mut mc1 = []
let obs1 = [1.0, 0.0, 0.0]
let mid1 = proto_observe(s1, embs1, mc1, obs1, 3.0)

let pc1 = map_get(s1, "proto_count")
if approx_eq(pc1, 1.0, 0.001)
  print("PASS test1: first observation creates first prototype (proto_count == 1)")
else
  print("FAIL test1: expected proto_count 1, got {pc1}")
end

// ══════════════════════════════════════════════════════════════
// Test 2: Similar observation matches existing (proto_count stays 1)
// ══════════════════════════════════════════════════════════════

// Very similar to first — slight perturbation, still above 0.85 threshold
let obs2 = [0.98, 0.1, 0.05]
let mid2 = proto_observe(s1, embs1, mc1, obs2, 3.0)

let pc2 = map_get(s1, "proto_count")
if approx_eq(pc2, 1.0, 0.001)
  print("PASS test2: similar observation matches existing (proto_count stays 1)")
else
  print("FAIL test2: expected proto_count 1, got {pc2}")
end

// ══════════════════════════════════════════════════════════════
// Test 3: Different observation creates new prototype
// ══════════════════════════════════════════════════════════════

// Orthogonal direction — will not match proto 0
let obs3 = [0.0, 0.0, 1.0]
let mid3 = proto_observe(s1, embs1, mc1, obs3, 3.0)

let pc3 = map_get(s1, "proto_count")
if approx_eq(pc3, 2.0, 0.001)
  print("PASS test3: different observation creates new prototype (proto_count == 2)")
else
  print("FAIL test3: expected proto_count 2, got {pc3}")
end

// ══════════════════════════════════════════════════════════════
// Test 4: Match returns correct proto ID
// ══════════════════════════════════════════════════════════════

// The last observation was obs3 which created proto 1
let lmid3 = map_get(s1, "last_match_id")
if approx_eq(lmid3, 1.0, 0.001)
  print("PASS test4: match returns correct proto ID (1 for new proto)")
else
  print("FAIL test4: expected last_match_id 1, got {lmid3}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: Re-observing first cluster matches proto 0
// ══════════════════════════════════════════════════════════════

let obs5 = [0.95, 0.15, 0.05]
let mid5 = proto_observe(s1, embs1, mc1, obs5, 3.0)

let lmid5 = map_get(s1, "last_match_id")
if approx_eq(lmid5, 0.0, 0.001)
  print("PASS test5: re-observing first cluster matches proto 0")
else
  print("FAIL test5: expected last_match_id 0, got {lmid5}")
end

// ══════════════════════════════════════════════════════════════
// Test 6: Transition detection works
// ══════════════════════════════════════════════════════════════

// Previous was proto 1, now we matched proto 0 — transition should be detected
let td6 = map_get(s1, "transition_detected")
if approx_eq(td6, 1.0, 0.001)
  print("PASS test6: transition detected (proto changed 1 -> 0)")
else
  print("FAIL test6: expected transition_detected 1.0, got {td6}")
end

// ══════════════════════════════════════════════════════════════
// Test 7: EMA drift — prototype should shift toward observation
// ══════════════════════════════════════════════════════════════

// Start fresh for drift test
let mut s2 = proto_new()
let mut embs2 = []
let mut mc2 = []
// Create prototype at [1, 0, 0]
let d_obs1 = [1.0, 0.0, 0.0]
let d_mid1 = proto_observe(s2, embs2, mc2, d_obs1, 3.0)

// Observe something similar but shifted: [0.9, 0.3, 0.0]
// This is close enough to match (cosine > 0.85) but should cause drift
let d_obs2 = [0.9, 0.3, 0.0]
let d_mid2 = proto_observe(s2, embs2, mc2, d_obs2, 3.0)

// Extract the prototype — it should no longer be exactly [1, 0, 0]
let d_proto = vec_extract(embs2, 0.0, 3.0)
let d_y = d_proto[1]

// After EMA drift toward [0.9, 0.3, 0.0] (normalized), y-component should be > 0
if d_y > 0.01
  print("PASS test7: EMA drift — prototype y-component shifted > 0 (got {d_y:.4})")
else
  print("FAIL test7: expected prototype drift y > 0.01, got {d_y}")
end

// ══════════════════════════════════════════════════════════════
// Test 8: proto_new returns correct initial state
// ══════════════════════════════════════════════════════════════

let mut s3 = proto_new()
let pc_init = map_get(s3, "proto_count")
let lmi_init = map_get(s3, "last_match_id")
let tc_init = map_get(s3, "transition_count")
if approx_eq(pc_init, 0.0, 0.001) && approx_eq(lmi_init, -1.0, 0.001) && approx_eq(tc_init, 0.0, 0.001)
  print("PASS test8: proto_new returns correct initial state")
else
  print("FAIL test8: init state wrong pc={pc_init} lmi={lmi_init} tc={tc_init}")
end

print("--- proto tests complete ---")
