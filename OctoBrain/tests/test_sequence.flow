// OctoBrain Sequence Reasoning Infrastructure Tests
// Tests for lib/sequence.flow — uses PASS/FAIL print pattern.
// 10 tests covering generators, sliding window, Markov tables, prediction,
// and surprise scoring.

use "../lib/sequence"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(a, b, tol)
  let mut diff = a - b
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ══════════════════════════════════════════════════════════════
// Test 1: seq_arithmetic(1, 2, 5) -> [1, 3, 5, 7, 9]
// ══════════════════════════════════════════════════════════════

let t1 = seq_arithmetic(1.0, 2.0, 5.0)
if len(t1) == 5.0 && approx_eq(t1[0], 1.0, 0.001) && approx_eq(t1[1], 3.0, 0.001) && approx_eq(t1[2], 5.0, 0.001) && approx_eq(t1[3], 7.0, 0.001) && approx_eq(t1[4], 9.0, 0.001)
  print("PASS test1: seq_arithmetic(1,2,5) = [1,3,5,7,9]")
else
  print("FAIL test1: seq_arithmetic(1,2,5) got [{t1[0]},{t1[1]},{t1[2]},{t1[3]},{t1[4]}]")
end

// ══════════════════════════════════════════════════════════════
// Test 2: seq_geometric(2, 3, 4) -> [2, 6, 18, 54]
// ══════════════════════════════════════════════════════════════

let t2 = seq_geometric(2.0, 3.0, 4.0)
if len(t2) == 4.0 && approx_eq(t2[0], 2.0, 0.001) && approx_eq(t2[1], 6.0, 0.001) && approx_eq(t2[2], 18.0, 0.001) && approx_eq(t2[3], 54.0, 0.001)
  print("PASS test2: seq_geometric(2,3,4) = [2,6,18,54]")
else
  print("FAIL test2: seq_geometric(2,3,4) got [{t2[0]},{t2[1]},{t2[2]},{t2[3]}]")
end

// ══════════════════════════════════════════════════════════════
// Test 3: seq_fibonacci(7) -> [1, 1, 2, 3, 5, 8, 13]
// ══════════════════════════════════════════════════════════════

let t3 = seq_fibonacci(7.0)
if len(t3) == 7.0 && approx_eq(t3[0], 1.0, 0.001) && approx_eq(t3[1], 1.0, 0.001) && approx_eq(t3[2], 2.0, 0.001) && approx_eq(t3[3], 3.0, 0.001) && approx_eq(t3[4], 5.0, 0.001) && approx_eq(t3[5], 8.0, 0.001) && approx_eq(t3[6], 13.0, 0.001)
  print("PASS test3: seq_fibonacci(7) = [1,1,2,3,5,8,13]")
else
  print("FAIL test3: seq_fibonacci(7) got [{t3[0]},{t3[1]},{t3[2]},{t3[3]},{t3[4]},{t3[5]},{t3[6]}]")
end

// ══════════════════════════════════════════════════════════════
// Test 4: seq_window extracts correct window, pads at boundary
// data = [10, 20, 30, 40, 50], window of size 3 at pos 3 -> [40, 50, 0]
// ══════════════════════════════════════════════════════════════

let t4_data = [10.0, 20.0, 30.0, 40.0, 50.0]
let t4_win = seq_window(t4_data, 3.0, 3.0)
if len(t4_win) == 3.0 && approx_eq(t4_win[0], 40.0, 0.001) && approx_eq(t4_win[1], 50.0, 0.001) && approx_eq(t4_win[2], 0.0, 0.001)
  print("PASS test4: seq_window pads at boundary [40,50,0]")
else
  print("FAIL test4: seq_window got [{t4_win[0]},{t4_win[1]},{t4_win[2]}]")
end

// ══════════════════════════════════════════════════════════════
// Test 5: markov1_build with sequence [0, 1, 0, 1]
// Transitions: 0->1, 1->0, 0->1
// table[0*2+1]=2 (0->1 twice), table[1*2+0]=1 (1->0 once)
// ══════════════════════════════════════════════════════════════

let t5_seq = [0.0, 1.0, 0.0, 1.0]
let t5_table = markov1_build(t5_seq, 4.0, 2.0)
// table layout: [0->0, 0->1, 1->0, 1->1] = [0, 2, 1, 0]
let t5_00 = t5_table[0]
let t5_01 = t5_table[1]
let t5_10 = t5_table[2]
let t5_11 = t5_table[3]
if approx_eq(t5_01, 2.0, 0.001) && approx_eq(t5_10, 1.0, 0.001) && approx_eq(t5_00, 0.0, 0.001) && approx_eq(t5_11, 0.0, 0.001)
  print("PASS test5: markov1_build [0,1,0,1] -> table[0->1]=2, table[1->0]=1")
else
  print("FAIL test5: markov1_build got [0->0={t5_00}, 0->1={t5_01}, 1->0={t5_10}, 1->1={t5_11}]")
end

// ══════════════════════════════════════════════════════════════
// Test 6: markov1_predict from proto 0 in above table -> predicts 1
// From proto 0: table[0*2+0]=0, table[0*2+1]=2 -> argmax = 1
// ══════════════════════════════════════════════════════════════

let t6_pred = markov1_predict(t5_table, 0.0, 2.0)
if approx_eq(t6_pred, 1.0, 0.001)
  print("PASS test6: markov1_predict from proto 0 -> predicts 1")
else
  print("FAIL test6: markov1_predict from proto 0 got {t6_pred}")
end

// ══════════════════════════════════════════════════════════════
// Test 7: markov2_build with [0, 1, 0, 1, 0]
// Trigrams: (0,1,0), (1,0,1), (0,1,0)
// table[0*4+1*2+0] = 2 (context [0,1] -> next 0, appears twice)
// table[1*4+0*2+1] = 1 (context [1,0] -> next 1, appears once)
// ══════════════════════════════════════════════════════════════

let t7_seq = [0.0, 1.0, 0.0, 1.0, 0.0]
let t7_table = markov2_build(t7_seq, 5.0, 2.0)
// table size = 2^3 = 8
// Index for [0,1,0] = 0*4 + 1*2 + 0 = 2
// Index for [1,0,1] = 1*4 + 0*2 + 1 = 5
let t7_010 = t7_table[2]
let t7_101 = t7_table[5]
if approx_eq(t7_010, 2.0, 0.001) && approx_eq(t7_101, 1.0, 0.001)
  print("PASS test7: markov2_build [0,1,0,1,0] -> table[0,1->0]=2, table[1,0->1]=1")
else
  print("FAIL test7: markov2_build got [0,1->0]={t7_010}, [1,0->1]={t7_101}")
end

// ══════════════════════════════════════════════════════════════
// Test 8: markov2_predict from context (0,1) -> predicts 0
// From (0,1): table[0*4+1*2+0]=2, table[0*4+1*2+1]=0 -> argmax = 0
// ══════════════════════════════════════════════════════════════

let t8_pred = markov2_predict(t7_table, 0.0, 1.0, 2.0)
if approx_eq(t8_pred, 0.0, 0.001)
  print("PASS test8: markov2_predict from context (0,1) -> predicts 0")
else
  print("FAIL test8: markov2_predict from context (0,1) got {t8_pred}")
end

// ══════════════════════════════════════════════════════════════
// Test 9: predict_n_steps chains 3 predictions from alternating table
// Using markov1 table from test5: 0->1 (count 2), 1->0 (count 1)
// Starting from proto 0: predict 1, then from 1 predict 0, then from 0 predict 1
// Expected: [1, 0, 1]
// ══════════════════════════════════════════════════════════════

let t9_ctx = [0.0]
let t9_preds = predict_n_steps(t5_table, 1.0, t9_ctx, 2.0, 3.0)
if len(t9_preds) == 3.0 && approx_eq(t9_preds[0], 1.0, 0.001) && approx_eq(t9_preds[1], 0.0, 0.001) && approx_eq(t9_preds[2], 1.0, 0.001)
  print("PASS test9: predict_n_steps 3 steps from 0 -> [1,0,1]")
else
  print("FAIL test9: predict_n_steps got [{t9_preds[0]},{t9_preds[1]},{t9_preds[2]}]")
end

// ══════════════════════════════════════════════════════════════
// Test 10: compute_surprise for expected vs unseen transition
// Using markov1 table from test5: 0->1 count=2, 0->0 count=0
// Surprise for expected (0 -> 1): P(1|0) = 2/2 = 1.0, surprise = 0.0
// Surprise for unseen (0 -> 0):   P(0|0) = 0/2 = 0.0, surprise = 1.0
// ══════════════════════════════════════════════════════════════

let t10_ctx = [0.0]
let t10_surprise_expected = compute_surprise(t5_table, 1.0, t10_ctx, 1.0, 2.0)
let t10_surprise_unseen = compute_surprise(t5_table, 1.0, t10_ctx, 0.0, 2.0)
if approx_eq(t10_surprise_expected, 0.0, 0.01) && approx_eq(t10_surprise_unseen, 1.0, 0.01)
  print("PASS test10: compute_surprise expected=0.0, unseen=1.0")
else
  print("FAIL test10: compute_surprise expected={t10_surprise_expected}, unseen={t10_surprise_unseen}")
end

print("--- sequence tests complete ---")
