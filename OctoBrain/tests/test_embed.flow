// OctoBrain Adaptive Embedding Tests
// Tests for lib/embed.flow — uses PASS/FAIL print pattern.

use "../lib/embed"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(a, b, tol)
  let mut diff = a - b
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ══════════════════════════════════════════════════════════════
// Test 1: Initial state — embed_new returns correct defaults
// ══════════════════════════════════════════════════════════════

let mut st1 = embed_new()
let id1 = map_get(st1, "input_dim")
let ed1 = map_get(st1, "embed_dim")
let oc1 = map_get(st1, "obs_count")
let bs1 = map_get(st1, "buffer_size")
let mb1 = map_get(st1, "max_buffer")
if approx_eq(id1, 0.0, 0.001) && approx_eq(ed1, 0.0, 0.001) && approx_eq(oc1, 0.0, 0.001) && approx_eq(bs1, 0.0, 0.001) && approx_eq(mb1, 100.0, 0.001)
  print("PASS test1: embed_new returns correct defaults")
else
  print("FAIL test1: defaults wrong id={id1} ed={ed1} oc={oc1} bs={bs1} mb={mb1}")
end

// ══════════════════════════════════════════════════════════════
// Test 2: Variance computation
// ══════════════════════════════════════════════════════════════
// 3 observations of dim 2: [1,2], [3,2], [5,2]
// dim 0 values: 1, 3, 5 -> mean=3, var = ((1-3)^2 + (3-3)^2 + (5-3)^2)/3 = (4+0+4)/3 = 2.667
// dim 1 values: 2, 2, 2 -> mean=2, var = 0

let obs_flat2 = [1.0, 2.0, 3.0, 2.0, 5.0, 2.0]
let vars2 = compute_variance(obs_flat2, 3.0, 2.0)
let v2_0 = vars2[0]
let v2_1 = vars2[1]
if approx_eq(v2_0, 2.6667, 0.01) && approx_eq(v2_1, 0.0, 0.001)
  print("PASS test2: variance computation [2.667, 0.0]")
else
  print("FAIL test2: expected [2.667, 0.0], got [{v2_0}, {v2_1}]")
end

// ══════════════════════════════════════════════════════════════
// Test 3: Dimension discovery — threshold filtering
// ══════════════════════════════════════════════════════════════
// Variances: [10.0, 5.0, 0.05, 0.001]
// Max = 10.0, threshold = 0.1
// 10.0 > 0.1 -> yes, 5.0 > 0.1 -> yes, 0.05 < 0.1 -> no, 0.001 < 0.1 -> no
// Expect 2 significant dims

let test_vars3 = [10.0, 5.0, 0.05, 0.001]
let dim3 = discover_dim(test_vars3, 4.0)
if approx_eq(dim3, 2.0, 0.001)
  print("PASS test3: dimension discovery finds 2 significant dims")
else
  print("FAIL test3: expected 2 significant dims, got {dim3}")
end

// ══════════════════════════════════════════════════════════════
// Test 4: Dimension discovery edge case — all equal variances
// ══════════════════════════════════════════════════════════════
// All variances equal -> all above 1% of max -> all significant

let test_vars4 = [5.0, 5.0, 5.0]
let dim4 = discover_dim(test_vars4, 3.0)
if approx_eq(dim4, 3.0, 0.001)
  print("PASS test4: all equal variances -> all dims significant")
else
  print("FAIL test4: expected 3 dims, got {dim4}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: Identity projection
// ══════════════════════════════════════════════════════════════
// When embed_dim == input_dim and W is identity, project should
// produce the normalized version of the input.

let mut st5 = embed_new()
let mut W5 = []
let dummy5 = embed_set_dims(st5, W5, 3.0, 3.0)

// Verify W is identity (3x3 = 9 elements)
let wlen5 = len(W5)
if approx_eq(wlen5, 9.0, 0.001)
  print("PASS test5a: W_embed has 9 elements for 3x3 identity")
else
  print("FAIL test5a: expected 9 elements, got {wlen5}")
end

// Project [3.0, 4.0, 0.0] through identity -> normalize([3,4,0]) = [0.6, 0.8, 0.0]
let raw5 = [3.0, 4.0, 0.0]
let proj5 = embed_project(W5, raw5, 3.0, 3.0)
let p5_0 = proj5[0]
let p5_1 = proj5[1]
let p5_2 = proj5[2]
if approx_eq(p5_0, 0.6, 0.001) && approx_eq(p5_1, 0.8, 0.001) && approx_eq(p5_2, 0.0, 0.001)
  print("PASS test5b: identity projection = normalized input [0.6, 0.8, 0.0]")
else
  print("FAIL test5b: expected [0.6, 0.8, 0.0], got [{p5_0}, {p5_1}, {p5_2}]")
end

// ══════════════════════════════════════════════════════════════
// Test 6: Dimension reduction projection
// ══════════════════════════════════════════════════════════════
// input_dim=3, embed_dim=2 -> W is 3x2 identity-like:
//   [1,0, 0,1, 0,0]
// Project [3, 4, 99] -> [3, 4] -> normalize -> [0.6, 0.8]

let mut st6 = embed_new()
let mut W6 = []
let dummy6 = embed_set_dims(st6, W6, 3.0, 2.0)

let raw6 = [3.0, 4.0, 99.0]
let proj6 = embed_project(W6, raw6, 3.0, 2.0)
let p6_0 = proj6[0]
let p6_1 = proj6[1]
if approx_eq(p6_0, 0.6, 0.001) && approx_eq(p6_1, 0.8, 0.001)
  print("PASS test6: dimension reduction projection [0.6, 0.8]")
else
  print("FAIL test6: expected [0.6, 0.8], got [{p6_0}, {p6_1}]")
end

// ══════════════════════════════════════════════════════════════
// Test 7: Buffer observations — count increases
// ══════════════════════════════════════════════════════════════

let mut st7 = embed_new()
let mut buf7 = []
let data7a = [1.0, 2.0]
let data7b = [3.0, 4.0]
let dummy7a = embed_buffer_obs(st7, buf7, data7a, 2.0)
let dummy7b = embed_buffer_obs(st7, buf7, data7b, 2.0)

let bs7 = map_get(st7, "buffer_size")
let oc7 = map_get(st7, "obs_count")
let buflen7 = len(buf7)
if approx_eq(bs7, 2.0, 0.001) && approx_eq(oc7, 2.0, 0.001) && approx_eq(buflen7, 4.0, 0.001)
  print("PASS test7: buffer obs count=2, buffer has 4 elements")
else
  print("FAIL test7: expected bs=2 oc=2 len=4, got bs={bs7} oc={oc7} len={buflen7}")
end

// ══════════════════════════════════════════════════════════════
// Test 8: Buffer eviction when exceeding max
// ══════════════════════════════════════════════════════════════
// Set max_buffer to 3, add 4 observations of dim 2.
// After 4th, oldest should be evicted, buffer_size stays 3.

let mut st8 = map()
map_set(st8, "input_dim", 0.0)
map_set(st8, "embed_dim", 0.0)
map_set(st8, "obs_count", 0.0)
map_set(st8, "buffer_size", 0.0)
map_set(st8, "max_buffer", 3.0)
let mut buf8 = []

let d8a = [10.0, 20.0]
let d8b = [30.0, 40.0]
let d8c = [50.0, 60.0]
let d8d = [70.0, 80.0]

let dum8a = embed_buffer_obs(st8, buf8, d8a, 2.0)
let dum8b = embed_buffer_obs(st8, buf8, d8b, 2.0)
let dum8c = embed_buffer_obs(st8, buf8, d8c, 2.0)
let dum8d = embed_buffer_obs(st8, buf8, d8d, 2.0)

let bs8 = map_get(st8, "buffer_size")
let oc8 = map_get(st8, "obs_count")
let buflen8 = len(buf8)

// buffer_size should be 3 (evicted oldest), obs_count should be 4 (total ever)
// buffer should contain [30,40, 50,60, 70,80] = 6 elements for 3 obs of dim 2
if approx_eq(bs8, 3.0, 0.001) && approx_eq(oc8, 4.0, 0.001) && approx_eq(buflen8, 6.0, 0.001)
  print("PASS test8a: eviction — buffer_size=3, obs_count=4, len=6")
else
  print("FAIL test8a: expected bs=3 oc=4 len=6, got bs={bs8} oc={oc8} len={buflen8}")
end

// Verify oldest was evicted: first element should be 30.0 (not 10.0)
let first8 = buf8[0]
if approx_eq(first8, 30.0, 0.001)
  print("PASS test8b: oldest observation evicted (first elem = 30)")
else
  print("FAIL test8b: expected first elem 30, got {first8}")
end

// ══════════════════════════════════════════════════════════════
// Test 9: embed_set_dims sets state correctly
// ══════════════════════════════════════════════════════════════

let mut st9 = embed_new()
let mut W9 = []
let dummy9 = embed_set_dims(st9, W9, 5.0, 3.0)

let id9 = map_get(st9, "input_dim")
let ed9 = map_get(st9, "embed_dim")
if approx_eq(id9, 5.0, 0.001) && approx_eq(ed9, 3.0, 0.001)
  print("PASS test9: embed_set_dims sets input_dim=5 embed_dim=3")
else
  print("FAIL test9: expected id=5 ed=3, got id={id9} ed={ed9}")
end

print("--- embed tests complete ---")
