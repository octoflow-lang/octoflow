// OctoBrain Recall Module Tests
// Tests for lib/recall.flow — uses PASS/FAIL print pattern.

use "../lib/vecmath"
use "../lib/proto"
use "../lib/edges"
use "../lib/recall"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(x, y, tol)
  let mut diff = x - y
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ── Shared setup: create 3 prototypes ─────────────────────────
let mut ps = proto_new()
let mut p_embs = []
let mut p_mc = []
let obs1 = [1.0, 0.0, 0.0]
let d1 = proto_observe(ps, p_embs, p_mc, obs1, 3.0)
let obs2 = [0.0, 1.0, 0.0]
let d2 = proto_observe(ps, p_embs, p_mc, obs2, 3.0)
let obs3 = [0.0, 0.0, 1.0]
let d3 = proto_observe(ps, p_embs, p_mc, obs3, 3.0)

// ── Shared setup: create edge store ───────────────────────────
let mut es = edges_new()
let mut en = []
let mut ea = []
let mut eo = []
let mut ep = []
let mut ew = []
let mut eact = []

// Add edge between protos 0 and 1
let edge_nodes = [0.0, 1.0]
let d4 = edges_add(es, en, ea, eo, ep, ew, eact, edge_nodes, 5.0)

// ══════════════════════════════════════════════════════════════
// Test 1: Context mean — two protos [1,0,0] and [0,1,0]
// Mean should be [0.5, 0.5, 0.0]
// ══════════════════════════════════════════════════════════════

let win1 = [0.0, 1.0]
let cm1 = context_mean(p_embs, win1, 3.0)
let cm1_len = len(cm1)
if cm1_len == 3.0
  let cm1_x = cm1[0]
  let cm1_y = cm1[1]
  let cm1_z = cm1[2]
  if approx_eq(cm1_x, 0.5, 0.01) && approx_eq(cm1_y, 0.5, 0.01) && approx_eq(cm1_z, 0.0, 0.01)
    print("PASS test1: context_mean = [{cm1_x}, {cm1_y}, {cm1_z}]")
  else
    print("FAIL test1: expected [0.5, 0.5, 0.0], got [{cm1_x}, {cm1_y}, {cm1_z}]")
  end
else
  print("FAIL test1: expected len=3, got {cm1_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 2: Score protos — protos 0,1 should score higher than proto 2
// Query is context_mean [0.5, 0.5, 0.0] — orthogonal to proto 2 [0,0,1]
// ══════════════════════════════════════════════════════════════

let sp2 = score_protos(p_embs, cm1, 3.0, 3.0)
let sp2_len = len(sp2)
if sp2_len == 3.0
  let sp2_0 = sp2[0]
  let sp2_1 = sp2[1]
  let sp2_2 = sp2[2]
  // Protos 0 and 1 have positive cosine with [0.5, 0.5, 0]
  // Proto 2 [0,0,1] is orthogonal to [0.5, 0.5, 0], so sim ~= 0
  if sp2_0 > sp2_2 && sp2_1 > sp2_2 && approx_eq(sp2_2, 0.0, 0.01)
    print("PASS test2: score_protos — protos 0,1 > proto 2 (scores: {sp2_0}, {sp2_1}, {sp2_2})")
  else
    print("FAIL test2: expected protos 0,1 > proto 2, got [{sp2_0}, {sp2_1}, {sp2_2}]")
  end
else
  print("FAIL test2: expected len=3, got {sp2_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 3: Action projection — identity-like W_score [3x2]
// With embedding [1, 0, 0], W_score identity-like should give [1, 0]
// ══════════════════════════════════════════════════════════════

// W_score [3 x 2] row-major:
// row 0: [1, 0]   — embed dim 0 maps to action 0
// row 1: [0, 1]   — embed dim 1 maps to action 1
// row 2: [0, 0]   — embed dim 2 maps to nothing
let W_test = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
let emb_test = [1.0, 0.0, 0.0]
let act3 = project_actions(emb_test, W_test, 3.0, 2.0)
let act3_len = len(act3)
if act3_len == 2.0
  let act3_0 = act3[0]
  let act3_1 = act3[1]
  if approx_eq(act3_0, 1.0, 0.01) && approx_eq(act3_1, 0.0, 0.01)
    print("PASS test3: project_actions [1,0,0] x identity = [{act3_0}, {act3_1}]")
  else
    print("FAIL test3: expected [1.0, 0.0], got [{act3_0}, {act3_1}]")
  end
else
  print("FAIL test3: expected len=2, got {act3_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 4: Empty window returns zeros
// ══════════════════════════════════════════════════════════════

let empty_win = []
let W4 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
let act4 = recall(p_embs, 3.0, 3.0, es, en, ea, eo, ep, empty_win, 2.0, W4)
let act4_len = len(act4)
if act4_len == 2.0
  let act4_0 = act4[0]
  let act4_1 = act4[1]
  if approx_eq(act4_0, 0.0, 0.01) && approx_eq(act4_1, 0.0, 0.01)
    print("PASS test4: empty window returns zeros [{act4_0}, {act4_1}]")
  else
    print("FAIL test4: expected [0.0, 0.0], got [{act4_0}, {act4_1}]")
  end
else
  print("FAIL test4: expected len=2, got {act4_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: Weighted scoring — edge between protos 0-1 should
// boost their scores relative to unconnected proto 2
// ══════════════════════════════════════════════════════════════

// Use a query that has equal cosine to all 3 unit basis vectors
// Query = normalize([1, 1, 1]) ~ [0.577, 0.577, 0.577]
let q5_raw = [1.0, 1.0, 1.0]
let q5 = normalize(q5_raw, 3.0)

let ws5 = weighted_score(p_embs, q5, 3.0, 3.0, es, en, ea, eo, ep)
let ws5_len = len(ws5)
if ws5_len == 3.0
  let ws5_0 = ws5[0]
  let ws5_1 = ws5[1]
  let ws5_2 = ws5[2]
  // Protos 0 and 1 are connected by an edge with permanence ~0.3
  // So their scores should be boosted: base * (1 + perm)
  // Proto 2 has no edges, so score = base * 1.0
  // All base cosines are equal (~0.577), so connected protos must be higher
  if ws5_0 > ws5_2 && ws5_1 > ws5_2
    print("PASS test5: weighted scoring — connected protos boosted ({ws5_0}, {ws5_1} > {ws5_2})")
  else
    print("FAIL test5: expected connected protos > unconnected, got [{ws5_0}, {ws5_1}, {ws5_2}]")
  end
else
  print("FAIL test5: expected len=3, got {ws5_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 6: Full recall pipeline — produces action scores with
// correct dimension
// ══════════════════════════════════════════════════════════════

let win6 = [0.0, 1.0]
let W6 = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]
let act6 = recall(p_embs, 3.0, 3.0, es, en, ea, eo, ep, win6, 2.0, W6)
let act6_len = len(act6)
if act6_len == 2.0
  let act6_0 = act6[0]
  let act6_1 = act6[1]
  // With window [0,1], context mean ~ [0.5, 0.5, 0]
  // Protos 0 and 1 dominate attention, proto 2 gets ~0 weight
  // Weighted embedding ~ mix of [1,0,0] and [0,1,0]
  // Project with identity-like W: action 0 gets x component, action 1 gets y component
  // Both should be positive and roughly equal
  if act6_0 > 0.0 && act6_1 > 0.0
    print("PASS test6: full recall pipeline — actions [{act6_0}, {act6_1}] (both positive)")
  else
    print("FAIL test6: expected positive action scores, got [{act6_0}, {act6_1}]")
  end
else
  print("FAIL test6: expected len=2, got {act6_len}")
end

print("--- recall tests complete ---")
