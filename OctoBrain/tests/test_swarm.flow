// OctoBrain Swarm Voting Tests
// Tests for lib/swarm.flow — uses PASS/FAIL print pattern.

use "../lib/swarm"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(x, y, tol)
  let mut diff = x - y
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ══════════════════════════════════════════════════════════════
// Test 1: Unanimous 3 voters — returns that class
// ══════════════════════════════════════════════════════════════

let mut preds1 = []
push(preds1, 2.0)
push(preds1, 2.0)
push(preds1, 2.0)
let r1 = majority_vote(preds1, 3.0, 3.0)
if approx_eq(r1, 2.0, 0.001)
  print("PASS test1: unanimous 3 voters returns class 2")
else
  print("FAIL test1: unanimous expected 2.0, got {r1}")
end

// ══════════════════════════════════════════════════════════════
// Test 2: 2-vs-1 split — returns majority
// ══════════════════════════════════════════════════════════════

let mut preds2 = []
push(preds2, 1.0)
push(preds2, 0.0)
push(preds2, 1.0)
let r2 = majority_vote(preds2, 3.0, 3.0)
if approx_eq(r2, 1.0, 0.001)
  print("PASS test2: 2-vs-1 split returns majority class 1")
else
  print("FAIL test2: 2-vs-1 expected 1.0, got {r2}")
end

// ══════════════════════════════════════════════════════════════
// Test 3: Tie — returns lowest class ID
// ══════════════════════════════════════════════════════════════

let mut preds3 = []
push(preds3, 0.0)
push(preds3, 1.0)
push(preds3, 2.0)
let r3 = majority_vote(preds3, 3.0, 3.0)
if approx_eq(r3, 0.0, 0.001)
  print("PASS test3: tie returns lowest class ID 0")
else
  print("FAIL test3: tie expected 0.0, got {r3}")
end

// ══════════════════════════════════════════════════════════════
// Test 4: Weighted vote favors high-weight voter
// ══════════════════════════════════════════════════════════════

let mut preds4 = []
push(preds4, 0.0)
push(preds4, 1.0)
push(preds4, 1.0)
let mut conf4 = []
push(conf4, 10.0)
push(conf4, 3.0)
push(conf4, 3.0)
let r4 = weighted_vote(preds4, conf4, 3.0, 2.0)
if approx_eq(r4, 0.0, 0.001)
  print("PASS test4: weighted vote favors high-weight voter (class 0)")
else
  print("FAIL test4: weighted expected 0.0, got {r4}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: Equal weights matches majority_vote result
// ══════════════════════════════════════════════════════════════

let mut preds5 = []
push(preds5, 1.0)
push(preds5, 0.0)
push(preds5, 1.0)
let mut conf5 = []
push(conf5, 1.0)
push(conf5, 1.0)
push(conf5, 1.0)
let r5_maj = majority_vote(preds5, 3.0, 2.0)
let r5_wt = weighted_vote(preds5, conf5, 3.0, 2.0)
if approx_eq(r5_maj, 1.0, 0.001) && approx_eq(r5_wt, 1.0, 0.001)
  print("PASS test5: equal weights matches majority vote (class 1)")
else
  print("FAIL test5: expected both 1.0, got maj={r5_maj} wt={r5_wt}")
end

// ══════════════════════════════════════════════════════════════
// Test 6: Perfect swarm_accuracy — 1.0
// ══════════════════════════════════════════════════════════════

// 3 voters, 2 samples: sample0 all vote 0, sample1 all vote 1
let mut vp6 = []
push(vp6, 0.0)
push(vp6, 0.0)
push(vp6, 0.0)
push(vp6, 1.0)
push(vp6, 1.0)
push(vp6, 1.0)
let mut tl6 = []
push(tl6, 0.0)
push(tl6, 1.0)
let r6 = swarm_accuracy(vp6, tl6, 2.0, 3.0, 2.0)
if approx_eq(r6, 1.0, 0.001)
  print("PASS test6: perfect swarm accuracy = 1.0")
else
  print("FAIL test6: expected 1.0, got {r6}")
end

// ══════════════════════════════════════════════════════════════
// Test 7: 50% swarm_accuracy
// ══════════════════════════════════════════════════════════════

// 3 voters, 2 samples: all vote 0 for both samples
let mut vp7 = []
push(vp7, 0.0)
push(vp7, 0.0)
push(vp7, 0.0)
push(vp7, 0.0)
push(vp7, 0.0)
push(vp7, 0.0)
let mut tl7 = []
push(tl7, 0.0)
push(tl7, 1.0)
let r7 = swarm_accuracy(vp7, tl7, 2.0, 3.0, 2.0)
if approx_eq(r7, 0.5, 0.001)
  print("PASS test7: 50% swarm accuracy = 0.5")
else
  print("FAIL test7: expected 0.5, got {r7}")
end

// ══════════════════════════════════════════════════════════════
// Test 8: Single voter — same as solo accuracy
// ══════════════════════════════════════════════════════════════

// 1 voter, 3 samples: predicts [0, 1, 0], truth [0, 1, 1] -> 2/3 correct
let mut vp8 = []
push(vp8, 0.0)
push(vp8, 1.0)
push(vp8, 0.0)
let mut tl8 = []
push(tl8, 0.0)
push(tl8, 1.0)
push(tl8, 1.0)
let r8 = swarm_accuracy(vp8, tl8, 3.0, 1.0, 2.0)
if approx_eq(r8, 0.6667, 0.01)
  print("PASS test8: single voter accuracy = 2/3")
else
  print("FAIL test8: expected ~0.6667, got {r8}")
end

// ══════════════════════════════════════════════════════════════
// Test 9: type_encode_onehot(2, 4) → length 4, sum=1, pos 2=1
// ══════════════════════════════════════════════════════════════

let oh9 = type_encode_onehot(2.0, 4.0)
let oh9_len = len(oh9)
let oh9_sum = oh9[0] + oh9[1] + oh9[2] + oh9[3]
if approx_eq(oh9_len, 4.0, 0.001) && approx_eq(oh9_sum, 1.0, 0.001) && approx_eq(oh9[2], 1.0, 0.001)
  print("PASS test9: type_encode_onehot(2,4) correct — len=4, sum=1, pos2=1")
else
  print("FAIL test9: type_encode_onehot(2,4) — len={oh9_len} sum={oh9_sum} pos2={oh9[2]}")
end

// ══════════════════════════════════════════════════════════════
// Test 10: type_encode_onehot(0, 3) → length 3, pos0=1, pos1=0
// ══════════════════════════════════════════════════════════════

let oh10 = type_encode_onehot(0.0, 3.0)
let oh10_len = len(oh10)
if approx_eq(oh10_len, 3.0, 0.001) && approx_eq(oh10[0], 1.0, 0.001) && approx_eq(oh10[1], 0.0, 0.001)
  print("PASS test10: type_encode_onehot(0,3) correct — len=3, pos0=1, pos1=0")
else
  print("FAIL test10: type_encode_onehot(0,3) — len={oh10_len} pos0={oh10[0]} pos1={oh10[1]}")
end

// ══════════════════════════════════════════════════════════════
// Test 11: type_encode_bigram_onehot(1, 2, 4) → length 8, pos1=1, pos6=1
// ══════════════════════════════════════════════════════════════

let bg11 = type_encode_bigram_onehot(1.0, 2.0, 4.0)
let bg11_len = len(bg11)
if approx_eq(bg11_len, 8.0, 0.001) && approx_eq(bg11[1], 1.0, 0.001) && approx_eq(bg11[6], 1.0, 0.001)
  print("PASS test11: type_encode_bigram_onehot(1,2,4) correct — len=8, pos1=1, pos6=1")
else
  print("FAIL test11: bigram_onehot(1,2,4) — len={bg11_len} pos1={bg11[1]} pos6={bg11[6]}")
end

// ══════════════════════════════════════════════════════════════
// Test 12: type_encode_bigram_onehot(0, 0, 3) → length 6, pos0=1, pos3=1
// ══════════════════════════════════════════════════════════════

let bg12 = type_encode_bigram_onehot(0.0, 0.0, 3.0)
let bg12_len = len(bg12)
if approx_eq(bg12_len, 6.0, 0.001) && approx_eq(bg12[0], 1.0, 0.001) && approx_eq(bg12[3], 1.0, 0.001)
  print("PASS test12: type_encode_bigram_onehot(0,0,3) correct — len=6, pos0=1, pos3=1")
else
  print("FAIL test12: bigram_onehot(0,0,3) — len={bg12_len} pos0={bg12[0]} pos3={bg12[3]}")
end

print("--- swarm voting tests complete ---")
