// OctoBrain Hyperedge Store Tests
// Tests for lib/edges.flow — uses PASS/FAIL print pattern.

use "../lib/edges"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(x, y, tol)
  let mut diff = x - y
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ── Create the shared edge store ──────────────────────────────
let mut state = edges_new()
let mut e_nodes = []
let mut e_arities = []
let mut e_offsets = []
let mut e_permanences = []
let mut e_weights = []
let mut e_activations = []

// ══════════════════════════════════════════════════════════════
// Test 1: Empty store has edge_count = 0
// ══════════════════════════════════════════════════════════════

let ec1 = map_get(state, "edge_count")
if approx_eq(ec1, 0.0, 0.001)
  print("PASS test1: empty store has edge_count = 0")
else
  print("FAIL test1: expected edge_count 0, got {ec1}")
end

// ══════════════════════════════════════════════════════════════
// Test 2: Add first edge — edge_count becomes 1
// ══════════════════════════════════════════════════════════════

let node_ids_1 = [0.0, 1.0, 2.0]
let r2 = edges_add(state, e_nodes, e_arities, e_offsets, e_permanences, e_weights, e_activations, node_ids_1, 1.0)

let ec2 = map_get(state, "edge_count")
if approx_eq(ec2, 1.0, 0.001)
  print("PASS test2: add first edge — edge_count = 1")
else
  print("FAIL test2: expected edge_count 1, got {ec2}")
end

// ══════════════════════════════════════════════════════════════
// Test 3: Duplicate edge strengthens — edge_count stays 1,
//         permanence increases
// ══════════════════════════════════════════════════════════════

// Same nodes in different order — should be treated as same edge
let node_ids_dup = [2.0, 0.0, 1.0]
let r3 = edges_add(state, e_nodes, e_arities, e_offsets, e_permanences, e_weights, e_activations, node_ids_dup, 1.0)

let ec3 = map_get(state, "edge_count")
let p3 = e_permanences[0]
// Initial was 0.3, after one strengthening: 0.3 + 0.02*1.0 = 0.32
if approx_eq(ec3, 1.0, 0.001) && approx_eq(p3, 0.32, 0.001)
  print("PASS test3: duplicate strengthens — count=1, permanence=0.32")
else
  print("FAIL test3: expected count=1 perm=0.32, got count={ec3} perm={p3}")
end

// ══════════════════════════════════════════════════════════════
// Test 4: Different edge — edge_count becomes 2
// ══════════════════════════════════════════════════════════════

let node_ids_2 = [1.0, 3.0]
let r4 = edges_add(state, e_nodes, e_arities, e_offsets, e_permanences, e_weights, e_activations, node_ids_2, 1.0)

let ec4 = map_get(state, "edge_count")
if approx_eq(ec4, 2.0, 0.001)
  print("PASS test4: different edge — edge_count = 2")
else
  print("FAIL test4: expected edge_count 2, got {ec4}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: Query by context — finds overlapping edges
// ══════════════════════════════════════════════════════════════

// Query with [0, 1] — should find edge 0 (nodes 0,1,2) and edge 1 (nodes 1,3)
let ctx = [0.0, 1.0]
let qr = edges_query(state, e_nodes, e_arities, e_offsets, e_permanences, ctx)

// Results are flat triples: [edge_idx, overlap_fraction, permanence, ...]
// Edge 0 (nodes 0,1,2): overlap = 2 nodes (0,1), fraction = 2/3
// Edge 1 (nodes 1,3):   overlap = 1 node (1),  fraction = 1/2
let qr_len = len(qr)
// Should have 2 edges * 3 values = 6 entries
if approx_eq(qr_len, 6.0, 0.001)
  let e0_idx = qr[0]
  let e0_frac = qr[1]
  let e1_idx = qr[3]
  let e1_frac = qr[4]
  // Edge 0: overlap_fraction = 2/3 ~= 0.6667
  // Edge 1: overlap_fraction = 1/2 = 0.5
  if approx_eq(e0_idx, 0.0, 0.001) && approx_eq(e0_frac, 0.6667, 0.01) && approx_eq(e1_idx, 1.0, 0.001) && approx_eq(e1_frac, 0.5, 0.01)
    print("PASS test5: query finds overlapping edges with correct fractions")
  else
    print("FAIL test5: wrong query results e0_idx={e0_idx} e0_frac={e0_frac} e1_idx={e1_idx} e1_frac={e1_frac}")
  end
else
  print("FAIL test5: expected 6 result entries, got {qr_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 6: Decay — permanences decrease
// ══════════════════════════════════════════════════════════════

// Before decay: edge 0 perm = 0.32, edge 1 perm = 0.3
let r6 = edges_decay(state, e_permanences, 0.5)

let p6_0 = e_permanences[0]
let p6_1 = e_permanences[1]
// After decay: edge 0 = 0.32 * 0.5 = 0.16, edge 1 = 0.3 * 0.5 = 0.15
if approx_eq(p6_0, 0.16, 0.001) && approx_eq(p6_1, 0.15, 0.001)
  print("PASS test6: decay reduces permanences (0.16, 0.15)")
else
  print("FAIL test6: expected permanences 0.16 and 0.15, got {p6_0} and {p6_1}")
end

// ══════════════════════════════════════════════════════════════
// Test 7: Get nodes — returns correct node list
// ══════════════════════════════════════════════════════════════

let gnodes = edges_get_nodes(state, e_nodes, e_arities, e_offsets, 0.0)
let gn_len = len(gnodes)
// Edge 0 has sorted nodes [0, 1, 2]
if approx_eq(gn_len, 3.0, 0.001) && approx_eq(gnodes[0], 0.0, 0.001) && approx_eq(gnodes[1], 1.0, 0.001) && approx_eq(gnodes[2], 2.0, 0.001)
  print("PASS test7: get_nodes returns [0, 1, 2] for edge 0")
else
  print("FAIL test7: expected [0,1,2], got len={gn_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 8: Initial permanence is 0.3
// ══════════════════════════════════════════════════════════════

// Create a fresh store and add one edge
let mut state2 = edges_new()
let mut e2_nodes = []
let mut e2_arities = []
let mut e2_offsets = []
let mut e2_permanences = []
let mut e2_weights = []
let mut e2_activations = []
let node_ids_8 = [5.0, 6.0]
let r8 = edges_add(state2, e2_nodes, e2_arities, e2_offsets, e2_permanences, e2_weights, e2_activations, node_ids_8, 1.0)
let p8 = e2_permanences[0]
if approx_eq(p8, 0.3, 0.001)
  print("PASS test8: initial permanence is 0.3")
else
  print("FAIL test8: expected initial permanence 0.3, got {p8}")
end

print("--- edges tests complete ---")
