// OctoBrain Vector Math Tests
// Tests for lib/vecmath.flow — uses PASS/FAIL print pattern.

use "../lib/vecmath"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(a, b, tol)
  let mut diff = a - b
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ══════════════════════════════════════════════════════════════
// Test: dot_product
// ══════════════════════════════════════════════════════════════

// Orthogonal vectors: dot product should be 0
let a1 = [1.0, 0.0]
let b1 = [0.0, 1.0]
let d1 = dot_product(a1, b1, 2.0)
if approx_eq(d1, 0.0, 0.001)
  print("PASS dot_product orthogonal = 0")
else
  print("FAIL dot_product orthogonal: expected 0, got {d1}")
end

// Known product: [1,2,3] . [4,5,6] = 4+10+18 = 32
let a2 = [1.0, 2.0, 3.0]
let b2 = [4.0, 5.0, 6.0]
let d2 = dot_product(a2, b2, 3.0)
if approx_eq(d2, 32.0, 0.001)
  print("PASS dot_product known = 32")
else
  print("FAIL dot_product known: expected 32, got {d2}")
end

// ══════════════════════════════════════════════════════════════
// Test: vec_norm
// ══════════════════════════════════════════════════════════════

// Classic 3-4-5 triangle: norm([3,4]) = 5
let v_norm = [3.0, 4.0]
let n1 = vec_norm(v_norm, 2.0)
if approx_eq(n1, 5.0, 0.001)
  print("PASS vec_norm [3,4] = 5")
else
  print("FAIL vec_norm [3,4]: expected 5, got {n1}")
end

// Unit vector: norm([1,0,0]) = 1
let v_unit = [1.0, 0.0, 0.0]
let n2 = vec_norm(v_unit, 3.0)
if approx_eq(n2, 1.0, 0.001)
  print("PASS vec_norm unit vector = 1")
else
  print("FAIL vec_norm unit: expected 1, got {n2}")
end

// ══════════════════════════════════════════════════════════════
// Test: cosine_sim
// ══════════════════════════════════════════════════════════════

// Identical vectors: cosine similarity should be ~1.0
let cs_a = [1.0, 2.0, 3.0]
let cs_b = [1.0, 2.0, 3.0]
let cs1 = cosine_sim(cs_a, cs_b, 3.0)
if approx_eq(cs1, 1.0, 0.001)
  print("PASS cosine_sim identical ~= 1.0")
else
  print("FAIL cosine_sim identical: expected 1.0, got {cs1}")
end

// Orthogonal vectors: cosine similarity should be ~0.0
let cs_c = [1.0, 0.0]
let cs_d = [0.0, 1.0]
let cs2 = cosine_sim(cs_c, cs_d, 2.0)
if approx_eq(cs2, 0.0, 0.001)
  print("PASS cosine_sim orthogonal ~= 0.0")
else
  print("FAIL cosine_sim orthogonal: expected 0.0, got {cs2}")
end

// Opposite vectors: cosine similarity should be ~-1.0
let cs_e = [1.0, 0.0]
let cs_f = [-1.0, 0.0]
let cs3 = cosine_sim(cs_e, cs_f, 2.0)
if approx_eq(cs3, -1.0, 0.001)
  print("PASS cosine_sim opposite ~= -1.0")
else
  print("FAIL cosine_sim opposite: expected -1.0, got {cs3}")
end

// ══════════════════════════════════════════════════════════════
// Test: normalize
// ══════════════════════════════════════════════════════════════

// Normalized vector should have norm ~1.0
let v_raw = [3.0, 4.0]
let v_normed = normalize(v_raw, 2.0)
let norm_check = vec_norm(v_normed, 2.0)
if approx_eq(norm_check, 1.0, 0.001)
  print("PASS normalize: result has norm ~1.0")
else
  print("FAIL normalize: expected norm 1.0, got {norm_check}")
end

// Verify direction preserved: normalized [3,4] should be [0.6, 0.8]
let nc0 = v_normed[0]
let nc1 = v_normed[1]
if approx_eq(nc0, 0.6, 0.001) && approx_eq(nc1, 0.8, 0.001)
  print("PASS normalize: direction preserved [0.6, 0.8]")
else
  print("FAIL normalize: expected [0.6, 0.8], got [{nc0}, {nc1}]")
end

// ══════════════════════════════════════════════════════════════
// Test: vec_subtract
// ══════════════════════════════════════════════════════════════

let sub_a = [5.0, 3.0]
let sub_b = [2.0, 1.0]
let sub_r = vec_subtract(sub_a, sub_b, 2.0)
let sr0 = sub_r[0]
let sr1 = sub_r[1]
if approx_eq(sr0, 3.0, 0.001) && approx_eq(sr1, 2.0, 0.001)
  print("PASS vec_subtract [5,3] - [2,1] = [3,2]")
else
  print("FAIL vec_subtract: expected [3,2], got [{sr0}, {sr1}]")
end

// ══════════════════════════════════════════════════════════════
// Test: vec_add
// ══════════════════════════════════════════════════════════════

let add_a = [5.0, 3.0]
let add_b = [2.0, 1.0]
let add_r = vec_add(add_a, add_b, 2.0)
let ar0 = add_r[0]
let ar1 = add_r[1]
if approx_eq(ar0, 7.0, 0.001) && approx_eq(ar1, 4.0, 0.001)
  print("PASS vec_add [5,3] + [2,1] = [7,4]")
else
  print("FAIL vec_add: expected [7,4], got [{ar0}, {ar1}]")
end

// ══════════════════════════════════════════════════════════════
// Test: vec_scale
// ══════════════════════════════════════════════════════════════

let sc_v = [2.0, 4.0]
let sc_r = vec_scale(sc_v, 0.5, 2.0)
let scr0 = sc_r[0]
let scr1 = sc_r[1]
if approx_eq(scr0, 1.0, 0.001) && approx_eq(scr1, 2.0, 0.001)
  print("PASS vec_scale [2,4] * 0.5 = [1,2]")
else
  print("FAIL vec_scale: expected [1,2], got [{scr0}, {scr1}]")
end

// ══════════════════════════════════════════════════════════════
// Test: vec_extract
// ══════════════════════════════════════════════════════════════

// 2x3 matrix stored flat: [[1,2,3], [4,5,6]]
let flat = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]

// Extract row 0 (should be [1,2,3])
let row0 = vec_extract(flat, 0.0, 3.0)
let r00 = row0[0]
let r01 = row0[1]
let r02 = row0[2]
if approx_eq(r00, 1.0, 0.001) && approx_eq(r01, 2.0, 0.001) && approx_eq(r02, 3.0, 0.001)
  print("PASS vec_extract row 0 = [1,2,3]")
else
  print("FAIL vec_extract row 0: got [{r00}, {r01}, {r02}]")
end

// Extract row 1 (should be [4,5,6])
let row1 = vec_extract(flat, 1.0, 3.0)
let r10 = row1[0]
let r11 = row1[1]
let r12 = row1[2]
if approx_eq(r10, 4.0, 0.001) && approx_eq(r11, 5.0, 0.001) && approx_eq(r12, 6.0, 0.001)
  print("PASS vec_extract row 1 = [4,5,6]")
else
  print("FAIL vec_extract row 1: got [{r10}, {r11}, {r12}]")
end

// ══════════════════════════════════════════════════════════════
// Test: vec_insert
// ══════════════════════════════════════════════════════════════

// Insert [7,8,9] at row 1 of a 2x3 flat matrix
let flat2 = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
let new_vals = [7.0, 8.0, 9.0]
let updated = vec_insert(flat2, 1.0, 3.0, new_vals)
let u0 = updated[0]
let u1 = updated[1]
let u2 = updated[2]
let u3 = updated[3]
let u4 = updated[4]
let u5 = updated[5]
if approx_eq(u0, 1.0, 0.001) && approx_eq(u1, 2.0, 0.001) && approx_eq(u2, 3.0, 0.001) && approx_eq(u3, 7.0, 0.001) && approx_eq(u4, 8.0, 0.001) && approx_eq(u5, 9.0, 0.001)
  print("PASS vec_insert row 1 = [1,2,3,7,8,9]")
else
  print("FAIL vec_insert: got [{u0},{u1},{u2},{u3},{u4},{u5}]")
end

// ══════════════════════════════════════════════════════════════
// Test: vec_zeros
// ══════════════════════════════════════════════════════════════

let z = vec_zeros(3.0)
let zlen = len(z)
let z0 = z[0]
let z1 = z[1]
let z2 = z[2]
if approx_eq(zlen, 3.0, 0.001) && approx_eq(z0, 0.0, 0.001) && approx_eq(z1, 0.0, 0.001) && approx_eq(z2, 0.0, 0.001)
  print("PASS vec_zeros(3) = [0,0,0]")
else
  print("FAIL vec_zeros: expected [0,0,0] len=3, got [{z0},{z1},{z2}] len={zlen}")
end

print("--- vecmath tests complete ---")
