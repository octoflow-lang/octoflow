// OctoBrain GPU Matching Tests
// Tests for lib/gpu_match.flow — uses PASS/FAIL print pattern.
// 8 tests: CPU fallback, GPU scoring, GPU vs CPU consistency, edge cases.
//
// Run with:
//   powershell.exe -NoProfile -ExecutionPolicy Bypass -File "C:\OctoFlow\run_test.ps1" run --bin octoflow -- run OctoBrain/tests/test_gpu_match.flow --allow-ffi --allow-read

use "../lib/gpu_match"
use "../lib/vecmath"
use "../lib/kernels"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(a, b, tol)
  let mut diff = a - b
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ── Helper: generate deterministic normalized vector ──────────
// Creates an embed_dim-length vector with a deterministic pattern
// based on seed, then normalizes it to unit length.
// Pattern: component[j] = sin((seed + 1) * (j + 1) * 0.7)
fn make_unit_vec(seed, embed_dim)
  let mut raw = []
  let mut j = 0.0
  while j < embed_dim
    let val = sin((seed + 1.0) * (j + 1.0) * 0.7)
    push(raw, val)
    j = j + 1.0
  end
  let result = normalize(raw, embed_dim)
  return result
end

// ══════════════════════════════════════════════════════════════
// Test 1: CPU path — orthogonal protos
// 3 unit vectors [1,0,0], [0,1,0], [0,0,1]. Query = [1,0,0].
// proto_count=3 < GPU_THRESHOLD so CPU path is used.
// Scores should be [1.0, 0.0, 0.0].
// ══════════════════════════════════════════════════════════════

let mut protos1 = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
let query1 = [1.0, 0.0, 0.0]
let scores1 = gpu_score_all(protos1, query1, 3.0, 3.0)

let s1_0 = scores1[0]
let s1_1 = scores1[1]
let s1_2 = scores1[2]
if approx_eq(s1_0, 1.0, 0.001) && approx_eq(s1_1, 0.0, 0.001) && approx_eq(s1_2, 0.0, 0.001)
  print("PASS test1: CPU path orthogonal protos — scores [1, 0, 0]")
else
  print("FAIL test1: expected [1, 0, 0], got [{s1_0}, {s1_1}, {s1_2}]")
end

// ══════════════════════════════════════════════════════════════
// Test 2: CPU path — exact match best_id
// Query identical to proto[1] = [0,1,0]. gpu_match_best returns
// best_id=1, best_sim~1.0.
// ══════════════════════════════════════════════════════════════

let query2 = [0.0, 1.0, 0.0]
let best2 = gpu_match_best(protos1, query2, 3.0, 3.0)
let best2_id = best2[0]
let best2_sim = best2[1]
if approx_eq(best2_id, 1.0, 0.001) && approx_eq(best2_sim, 1.0, 0.001)
  print("PASS test2: CPU path best match — id=1, sim~1.0")
else
  print("FAIL test2: expected id=1 sim=1.0, got id={best2_id} sim={best2_sim}")
end

// ══════════════════════════════════════════════════════════════
// Test 3: GPU path — basic scoring
// Init GPU. Create 100 normalized 8-dim protos (deterministic).
// Call gpu_score_all. Verify len=100, scores in [-1, 1].
// ══════════════════════════════════════════════════════════════

let _init = gpu_match_init()

// Build 100 normalized 8-dim protos as flat array
let embed_dim3 = 8.0
let proto_count3 = 100.0
let mut protos3 = []
let mut pi3 = 0.0
while pi3 < proto_count3
  let uv3 = make_unit_vec(pi3, embed_dim3)
  let mut j3 = 0.0
  while j3 < embed_dim3
    push(protos3, uv3[j3])
    j3 = j3 + 1.0
  end
  pi3 = pi3 + 1.0
end

// Query: normalized random-ish vector
let qvec3 = make_unit_vec(999.0, embed_dim3)

let scores3 = gpu_score_all(protos3, qvec3, embed_dim3, proto_count3)
let scores3_len = len(scores3)

// Check length and range
let mut t3_pass = 1.0
if approx_eq(scores3_len, 100.0, 0.001) == 0.0
  t3_pass = 0.0
end
let mut t3i = 0.0
while t3i < scores3_len && t3_pass > 0.5
  let sv = scores3[t3i]
  if sv < -1.01 || sv > 1.01
    t3_pass = 0.0
  end
  t3i = t3i + 1.0
end

if t3_pass > 0.5
  print("PASS test3: GPU path basic scoring — 100 scores, all in [-1, 1]")
else
  print("FAIL test3: GPU scoring — len={scores3_len}, expected 100 with valid range")
end

// ══════════════════════════════════════════════════════════════
// Test 4: GPU vs CPU consistency
// Same 100 protos. Compute CPU scores via cosine_sim loop.
// Compare: |gpu[i] - cpu[i]| < 0.001 for all 100.
// ══════════════════════════════════════════════════════════════

let mut t4_pass = 1.0
let mut t4_first_fail = -1.0
let mut t4_fail_gpu = 0.0
let mut t4_fail_cpu = 0.0
let mut t4i = 0.0
while t4i < proto_count3
  let pv4 = vec_extract(protos3, t4i, embed_dim3)
  let cpu_sim = cosine_sim(qvec3, pv4, embed_dim3)
  let gpu_sim = scores3[t4i]
  if approx_eq(gpu_sim, cpu_sim, 0.001) == 0.0
    if t4_first_fail < 0.0
      t4_first_fail = t4i
      t4_fail_gpu = gpu_sim
      t4_fail_cpu = cpu_sim
    end
    t4_pass = 0.0
  end
  t4i = t4i + 1.0
end

if t4_pass > 0.5
  print("PASS test4: GPU vs CPU consistency — all 100 scores match (tol=0.001)")
else
  print("FAIL test4: GPU/CPU mismatch at index {t4_first_fail}: gpu={t4_fail_gpu} cpu={t4_fail_cpu}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: gpu_match_best correctness
// Use 100 protos, query = proto[42]. Best match should be id=42.
// ══════════════════════════════════════════════════════════════

let qvec5 = make_unit_vec(42.0, embed_dim3)
let best5 = gpu_match_best(protos3, qvec5, embed_dim3, proto_count3)
let best5_id = best5[0]
let best5_sim = best5[1]
if approx_eq(best5_id, 42.0, 0.001) && best5_sim > 0.99
  print("PASS test5: gpu_match_best — best_id=42, sim={best5_sim:.4}")
else
  print("FAIL test5: expected best_id=42 sim>0.99, got id={best5_id} sim={best5_sim}")
end

// ══════════════════════════════════════════════════════════════
// Test 6: Edge case — 1 proto
// Single prototype, CPU path (1 < 64). Verify best_id=0, sim~1.0.
// ══════════════════════════════════════════════════════════════

let mut protos6 = [0.6, 0.8]
let query6 = [0.6, 0.8]
let best6 = gpu_match_best(protos6, query6, 2.0, 1.0)
let best6_id = best6[0]
let best6_sim = best6[1]
if approx_eq(best6_id, 0.0, 0.001) && approx_eq(best6_sim, 1.0, 0.001)
  print("PASS test6: edge case 1 proto — best_id=0, sim~1.0")
else
  print("FAIL test6: expected id=0 sim=1.0, got id={best6_id} sim={best6_sim}")
end

// ══════════════════════════════════════════════════════════════
// Test 7: Large scale — 500 protos (GPU path, > threshold)
// 500 normalized 4-dim protos. Verify len(scores)=500, no crash.
// ══════════════════════════════════════════════════════════════

let embed_dim7 = 4.0
let proto_count7 = 500.0
let mut protos7 = []
let mut pi7 = 0.0
while pi7 < proto_count7
  let uv7 = make_unit_vec(pi7, embed_dim7)
  let mut j7 = 0.0
  while j7 < embed_dim7
    push(protos7, uv7[j7])
    j7 = j7 + 1.0
  end
  pi7 = pi7 + 1.0
end

let qvec7 = make_unit_vec(250.0, embed_dim7)
let scores7 = gpu_score_all(protos7, qvec7, embed_dim7, proto_count7)
let scores7_len = len(scores7)

if approx_eq(scores7_len, 500.0, 0.001)
  print("PASS test7: large scale 500 protos — len={scores7_len}, no crash")
else
  print("FAIL test7: expected 500 scores, got {scores7_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 8: Init/cleanup flags
// GPU_READY[0] should be 1 now (init was called for test 3).
// After cleanup, GPU_READY[0] should be 0.
// ══════════════════════════════════════════════════════════════

let flag_before = GPU_READY[0]
let _cleanup = gpu_match_cleanup()
let flag_after = GPU_READY[0]

if approx_eq(flag_before, 1.0, 0.001) && approx_eq(flag_after, 0.0, 0.001)
  print("PASS test8: init/cleanup flags — before=1, after=0")
else
  print("FAIL test8: expected before=1 after=0, got before={flag_before} after={flag_after}")
end

// ══════════════════════════════════════════════════════════════
// Test 9: Kernel signature generation
// kernel_sig_match should produce "match:<embed_dim>:<proto_count>"
// ══════════════════════════════════════════════════════════════

let sig = kernel_sig_match(8.0, 100.0)
if sig == "match:8:100"
  print("PASS test9: kernel_sig_match generates correct signature")
else
  print("FAIL test9: expected match:8:100, got {sig}")
end

// ══════════════════════════════════════════════════════════════
// Test 10: Cache lookup/register
// Miss on first lookup, hit after register.
// ══════════════════════════════════════════════════════════════

let sig10 = kernel_sig_match(3.0, 50.0)
let miss = kernel_cached(sig10)
// Should be 0 (not cached yet)
let _r = kernel_register(sig10)
let hit = kernel_cached(sig10)
// Should be 1 (now cached)
if approx_eq(miss, 0.0, 0.001) > 0.5 && approx_eq(hit, 1.0, 0.001) > 0.5
  print("PASS test10: kernel cache miss then hit after register")
else
  print("FAIL test10: expected miss=0 hit=1, got miss={miss} hit={hit}")
end

// ══════════════════════════════════════════════════════════════
// Test 11: Cache statistics
// After test 10, we should have >= 1 hit, >= 1 miss, >= 1 cached.
// ══════════════════════════════════════════════════════════════

let kstats = kernel_stats()
let hits = map_get(kstats, "hits")
let misses = map_get(kstats, "misses")
let cached = map_get(kstats, "cached_count")
if hits >= 1.0 && misses >= 1.0 && cached >= 1.0
  print("PASS test11: kernel stats correct (hits={hits}, misses={misses}, cached={cached})")
else
  print("FAIL test11: unexpected stats hits={hits} misses={misses} cached={cached}")
end

print("--- gpu match + kernel tests complete ---")
