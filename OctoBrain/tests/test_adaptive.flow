// OctoBrain Adaptive Threshold + Zero-Vector Guard Tests
// Tests for Phase 6 fixes to proto.flow.
// 8 tests: threshold computation (4), zero-vector guard (2), high-dim (1), low-dim (1).

use "../lib/proto"
use "../lib/vecmath"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(x, y, tol)
  let mut diff = x - y
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

print("=== Adaptive Threshold + Zero-Vector Guard Tests ===")
print("")

// ══════════════════════════════════════════════════════════════
// Test 1: compute_threshold(3) returns 0.85 (capped at max)
// sqrt(3) ≈ 1.732, 2.4/1.732 ≈ 1.386 → capped to 0.85
// ══════════════════════════════════════════════════════════════

let t1 = compute_threshold(3.0)
if approx_eq(t1, 0.85, 0.01)
  print("PASS test1: compute_threshold(3) = {t1:.4} ≈ 0.85 (capped)")
else
  print("FAIL test1: expected 0.85, got {t1:.4}")
end

// ══════════════════════════════════════════════════════════════
// Test 2: compute_threshold(8) returns ~0.85
// sqrt(8) ≈ 2.828, 2.4/2.828 ≈ 0.849 → capped to 0.85
// ══════════════════════════════════════════════════════════════

let t2 = compute_threshold(8.0)
if approx_eq(t2, 0.85, 0.01)
  print("PASS test2: compute_threshold(8) = {t2:.4} ≈ 0.85 (capped)")
else
  print("FAIL test2: expected ~0.85, got {t2:.4}")
end

// ══════════════════════════════════════════════════════════════
// Test 3: compute_threshold(64) returns 0.30 (floored)
// sqrt(64) = 8.0, 2.4/8.0 = 0.30 → exactly at floor
// ══════════════════════════════════════════════════════════════

let t3 = compute_threshold(64.0)
if approx_eq(t3, 0.30, 0.01)
  print("PASS test3: compute_threshold(64) = {t3:.4} ≈ 0.30 (floored)")
else
  print("FAIL test3: expected 0.30, got {t3:.4}")
end

// ══════════════════════════════════════════════════════════════
// Test 4: compute_threshold(128) returns 0.30 (floored)
// sqrt(128) ≈ 11.31, 2.4/11.31 ≈ 0.212 → floored to 0.30
// ══════════════════════════════════════════════════════════════

let t4 = compute_threshold(128.0)
if approx_eq(t4, 0.30, 0.01)
  print("PASS test4: compute_threshold(128) = {t4:.4} ≈ 0.30 (floored)")
else
  print("FAIL test4: expected 0.30, got {t4:.4}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: Zero-vector guard — feed [0,0,0] to empty brain
// Should return -1.0 (last_match_id initial value), proto_count stays 0
// ══════════════════════════════════════════════════════════════

let mut s5 = proto_new()
let mut embs5 = []
let mut mc5 = []
let zero_obs = [0.0, 0.0, 0.0]
let mid5 = proto_observe(s5, embs5, mc5, zero_obs, 3.0)
let pc5 = map_get(s5, "proto_count")

if approx_eq(pc5, 0.0, 0.001) && approx_eq(mid5, -1.0, 0.001)
  print("PASS test5: zero-vector guard skips degenerate input (proto_count=0, returned -1)")
else
  print("FAIL test5: expected proto_count=0, returned=-1, got pc={pc5}, mid={mid5}")
end

// ══════════════════════════════════════════════════════════════
// Test 6: Zero-vector guard — feed [0,0,0] after valid observation
// Proto_count should stay at 1 (zero-vector skipped)
// ══════════════════════════════════════════════════════════════

let mut s6 = proto_new()
let mut embs6 = []
let mut mc6 = []
// First: valid observation
let valid_obs = [1.0, 0.0, 0.0]
let mid6a = proto_observe(s6, embs6, mc6, valid_obs, 3.0)
let pc6a = map_get(s6, "proto_count")

// Second: zero-vector — should be skipped
let mid6b = proto_observe(s6, embs6, mc6, zero_obs, 3.0)
let pc6b = map_get(s6, "proto_count")

if approx_eq(pc6a, 1.0, 0.001) && approx_eq(pc6b, 1.0, 0.001)
  print("PASS test6: zero-vector after valid obs — proto_count stays 1")
else
  print("FAIL test6: expected proto_count=1 after both, got {pc6a} then {pc6b}")
end

// ══════════════════════════════════════════════════════════════
// Test 7: High-dim validation — 64D data, 20 observations
// With adaptive threshold (0.30), proto_count should be < 20
// ══════════════════════════════════════════════════════════════

let mut s7 = proto_new()
let mut embs7 = []
let mut mc7 = []
let dim7 = 64.0

let mut obs_idx = 0.0
while obs_idx < 20.0
  let t = obs_idx * 0.5
  let mut obs7 = []
  let mut di = 0.0
  while di < dim7
    let val = sin(t * (di + 1.0) * 0.3)
    push(obs7, val)
    di = di + 1.0
  end
  let mid7 = proto_observe(s7, embs7, mc7, obs7, dim7)
  obs_idx = obs_idx + 1.0
end

let pc7 = map_get(s7, "proto_count")
let pc7_int = int(pc7)
if pc7 < 20.0
  print("PASS test7: 64D high-dim — proto_count={pc7_int} < 20 observations (adaptive threshold works)")
else
  print("FAIL test7: expected proto_count < 20 at 64D, got {pc7_int}")
end

// ══════════════════════════════════════════════════════════════
// Test 8: Normal low-dim behavior unchanged — 3 distinct 3D vectors
// Should create 3 prototypes (orthogonal directions)
// ══════════════════════════════════════════════════════════════

let mut s8 = proto_new()
let mut embs8 = []
let mut mc8 = []
let obs8a = [1.0, 0.0, 0.0]
let obs8b = [0.0, 1.0, 0.0]
let obs8c = [0.0, 0.0, 1.0]

let mid8a = proto_observe(s8, embs8, mc8, obs8a, 3.0)
let mid8b = proto_observe(s8, embs8, mc8, obs8b, 3.0)
let mid8c = proto_observe(s8, embs8, mc8, obs8c, 3.0)

let pc8 = map_get(s8, "proto_count")
if approx_eq(pc8, 3.0, 0.001)
  print("PASS test8: 3 distinct 3D vectors create 3 protos (low-dim unchanged)")
else
  print("FAIL test8: expected 3 protos for 3 orthogonal vectors, got {pc8}")
end

print("")
print("--- adaptive threshold + zero-vector guard tests complete ---")
