// OctoBrain GPU Recall Tests
// Tests for lib/gpu_recall.flow — GPU-accelerated action projection.
// 5 tests: small GPU vs CPU, larger GPU vs CPU, full pipeline consistency,
// edge case CPU fallback, large scale GPU path.
//
// Run with:
//   powershell.exe -NoProfile -ExecutionPolicy Bypass -File "C:\OctoFlow\run_test.ps1" run --bin octoflow -- run OctoBrain/tests/test_gpu_recall.flow --allow-ffi --allow-read

use "../lib/gpu_match"
use "../lib/gpu_recall"
use "../lib/vecmath"
use "../lib/edges"
use "../lib/recall"

// ── Helper: approximate equality ──────────────────────────────
fn approx_eq(a, b, tol)
  let mut diff = a - b
  if diff < 0.0
    diff = diff * -1.0
  end
  if diff < tol
    return 1.0
  end
  return 0.0
end

// ── Helper: CPU project_actions (reference implementation) ────
// Direct CPU computation for comparison against GPU path.
fn cpu_project_actions(embedding, W_score, embed_dim, action_count)
  let mut actions = []
  let mut a = 0.0
  while a < action_count
    let mut sum = 0.0
    let mut d = 0.0
    while d < embed_dim
      sum = sum + embedding[d] * W_score[d * action_count + a]
      d = d + 1.0
    end
    push(actions, sum)
    a = a + 1.0
  end
  return actions
end

// ── Helper: generate deterministic vector ─────────────────────
fn make_vec(seed, dim)
  let mut result = []
  let mut i = 0.0
  while i < dim
    let val = sin((seed + 1.0) * (i + 1.0) * 0.7)
    push(result, val)
    i = i + 1.0
  end
  return result
end

// ── Helper: generate deterministic weight matrix ──────────────
// Creates [rows x cols] flat row-major matrix with deterministic values.
fn make_weights(seed, rows, cols)
  let mut result = []
  let mut r = 0.0
  while r < rows
    let mut c = 0.0
    while c < cols
      let val = sin((seed + r + 1.0) * (c + 1.0) * 0.3) * 0.5
      push(result, val)
      c = c + 1.0
    end
    r = r + 1.0
  end
  return result
end

// ── Helper: compare two arrays element-wise ───────────────────
// Returns 1.0 if all elements match within tolerance, 0.0 otherwise.
fn arrays_match(arr1, arr2, count, tol)
  let mut pass = 1.0
  let mut i = 0.0
  while i < count
    if approx_eq(arr1[i], arr2[i], tol) == 0.0
      pass = 0.0
    end
    i = i + 1.0
  end
  return pass
end

// Initialize GPU
let _init = gpu_match_init()

// ══════════════════════════════════════════════════════════════
// Test 1: GPU project_actions matches CPU for small case (3D -> 2 actions)
// embed_dim=3, action_count=2 => total=6 < 64, so GPU fallback to CPU.
// Verify gpu_project_actions gives same result as CPU reference.
// ══════════════════════════════════════════════════════════════

let emb1 = [1.0, 0.5, -0.3]
// W_score [3 x 2] row-major:
// row 0: [0.2, -0.1]   row 1: [0.4, 0.3]   row 2: [-0.5, 0.6]
let W1 = [0.2, -0.1, 0.4, 0.3, -0.5, 0.6]
let gpu1 = gpu_project_actions(emb1, W1, 3.0, 2.0)
let cpu1 = cpu_project_actions(emb1, W1, 3.0, 2.0)

let gpu1_len = len(gpu1)
let t1_match = arrays_match(gpu1, cpu1, 2.0, 0.001)
let gpu1_0 = gpu1[0]
let gpu1_1 = gpu1[1]
let cpu1_0 = cpu1[0]
let cpu1_1 = cpu1[1]

if gpu1_len == 2.0 && t1_match > 0.5
  print("PASS test1: GPU matches CPU for 3D->2 actions (gpu=[{gpu1_0:.4}, {gpu1_1:.4}], cpu=[{cpu1_0:.4}, {cpu1_1:.4}])")
else
  print("FAIL test1: GPU/CPU mismatch for 3D->2 actions (len={gpu1_len})")
end

// ══════════════════════════════════════════════════════════════
// Test 2: GPU project_actions matches CPU for larger case (16D -> 4 actions)
// embed_dim=16, action_count=4 => total=64 >= threshold, GPU path used.
// ══════════════════════════════════════════════════════════════

let embed_dim2 = 16.0
let action_count2 = 4.0
let emb2 = make_vec(42.0, embed_dim2)
let W2 = make_weights(7.0, embed_dim2, action_count2)

let gpu2 = gpu_project_actions(emb2, W2, embed_dim2, action_count2)
let cpu2 = cpu_project_actions(emb2, W2, embed_dim2, action_count2)

let gpu2_len = len(gpu2)
let t2_match = arrays_match(gpu2, cpu2, action_count2, 0.01)

if gpu2_len == action_count2 && t2_match > 0.5
  print("PASS test2: GPU matches CPU for 16D->4 actions (GPU path, tol=0.01)")
else
  print("FAIL test2: GPU/CPU mismatch for 16D->4 actions (len={gpu2_len})")
end

// ══════════════════════════════════════════════════════════════
// Test 3: Full recall pipeline GPU vs CPU consistency
// Observe 3 points, recall, compare scores when GPU is active.
// The recall() function internally calls project_actions which
// will route to GPU when dims are large enough.
// We use embed_dim=16, action_count=4 to exercise GPU path.
// ══════════════════════════════════════════════════════════════

// Build prototypes: 3 normalized 16D vectors
let embed_dim3 = 16.0
let action_count3 = 4.0
let proto_count3 = 3.0

let mut p3_flat = []
let mut p3i = 0.0
while p3i < proto_count3
  let uv3 = make_vec(p3i * 10.0, embed_dim3)
  let nv3 = normalize(uv3, embed_dim3)
  let mut j3 = 0.0
  while j3 < embed_dim3
    push(p3_flat, nv3[j3])
    j3 = j3 + 1.0
  end
  p3i = p3i + 1.0
end

// Edge store (minimal, no edges)
let mut es3 = edges_new()
let mut en3 = []
let mut ea3 = []
let mut eo3 = []
let mut ep3 = []

// Window: all 3 protos
let win3 = [0.0, 1.0, 2.0]

// Weight matrix for projection
let W3 = make_weights(13.0, embed_dim3, action_count3)

// Call recall pipeline (GPU path for project_actions)
let act3 = recall(p3_flat, embed_dim3, proto_count3, es3, en3, ea3, eo3, ep3, win3, action_count3, W3)
let act3_len = len(act3)

// Verify: correct dimension and finite values
let mut t3_pass = 1.0
let mut t3i = 0.0
while t3i < act3_len
  let v3 = act3[t3i]
  // Check finite (not NaN/Inf): value should be between -1000 and 1000
  if v3 < -1000.0 || v3 > 1000.0
    t3_pass = 0.0
  end
  t3i = t3i + 1.0
end

if act3_len == action_count3 && t3_pass > 0.5
  print("PASS test3: full recall pipeline GPU consistency — {act3_len} actions, finite values")
else
  print("FAIL test3: recall pipeline issue — len={act3_len}")
end

// ══════════════════════════════════════════════════════════════
// Test 4: Edge case — 1D -> 1 action (CPU fallback)
// embed_dim=1, action_count=1 => total=1 < 64, CPU path.
// Simple scalar multiply: action[0] = emb[0] * W[0].
// ══════════════════════════════════════════════════════════════

let emb4 = [3.0]
let W4 = [2.0]
let gpu4 = gpu_project_actions(emb4, W4, 1.0, 1.0)
let cpu4 = cpu_project_actions(emb4, W4, 1.0, 1.0)

let gpu4_len = len(gpu4)
let gpu4_0 = gpu4[0]
let cpu4_0 = cpu4[0]

if gpu4_len == 1.0 && approx_eq(gpu4_0, 6.0, 0.001) > 0.5 && approx_eq(cpu4_0, 6.0, 0.001) > 0.5
  print("PASS test4: 1D->1 action CPU fallback — gpu={gpu4_0:.4} cpu={cpu4_0:.4} (expected 6.0)")
else
  print("FAIL test4: expected 6.0, got gpu={gpu4_0} cpu={cpu4_0}")
end

// ══════════════════════════════════════════════════════════════
// Test 5: Large scale — 32D -> 8 actions (GPU path exercised)
// embed_dim=32, action_count=8 => total=256, well above threshold.
// ══════════════════════════════════════════════════════════════

let embed_dim5 = 32.0
let action_count5 = 8.0
let emb5 = make_vec(99.0, embed_dim5)
let W5 = make_weights(17.0, embed_dim5, action_count5)

let gpu5 = gpu_project_actions(emb5, W5, embed_dim5, action_count5)
let cpu5 = cpu_project_actions(emb5, W5, embed_dim5, action_count5)

let gpu5_len = len(gpu5)
let t5_match = arrays_match(gpu5, cpu5, action_count5, 0.01)

if gpu5_len == action_count5 && t5_match > 0.5
  print("PASS test5: large scale 32D->8 actions — GPU matches CPU (tol=0.01)")
else
  print("FAIL test5: GPU/CPU mismatch for 32D->8 actions (len={gpu5_len})")
end

// Cleanup GPU
let _cleanup = gpu_match_cleanup()

print("--- gpu recall tests complete ---")
