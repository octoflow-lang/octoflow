// OctoBrain Kernel Cache
// Scaffolding for Phase 3+ JIT kernel caching.
// Phase 2: dimension signature tracking with hit/miss counting.
//
// Uses flat array for signature storage (module-level maps not supported
// in cross-module function calls). Linear scan is fine for scaffolding;
// Phase 3+ will use proper hash-based lookup.

let mut KERNEL_SIGS = []
let mut kernel_hits = [0.0]
let mut kernel_misses = [0.0]

// Build dimension signature for prototype matching.
// Returns "match:<embed_dim>:<proto_count>"
fn kernel_sig_match(embed_dim, proto_count)
  let ed = str(int(embed_dim))
  let pc = str(int(proto_count))
  return "match:" + ed + ":" + pc
end

// Check if a kernel for this signature is cached.
// Returns 1.0 if cached, 0.0 if not.
fn kernel_cached(sig)
  let mut i = 0.0
  let n = len(KERNEL_SIGS)
  while i < n
    if KERNEL_SIGS[i] == sig
      kernel_hits[0] = kernel_hits[0] + 1.0
      return 1.0
    end
    i = i + 1.0
  end
  kernel_misses[0] = kernel_misses[0] + 1.0
  return 0.0
end

// Register a kernel in the cache.
// Skips if already registered.
fn kernel_register(sig)
  let mut i = 0.0
  let n = len(KERNEL_SIGS)
  while i < n
    if KERNEL_SIGS[i] == sig
      return 0.0
    end
    i = i + 1.0
  end
  push(KERNEL_SIGS, sig)
  return 0.0
end

// Get cache statistics as a map.
fn kernel_stats()
  let mut stats = map()
  map_set(stats, "hits", kernel_hits[0])
  map_set(stats, "misses", kernel_misses[0])
  map_set(stats, "cached_count", len(KERNEL_SIGS))
  return stats
end
