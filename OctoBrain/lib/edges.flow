// OctoBrain Hyperedge Store
// N-ary connections between prototype nodes with permanence.
// Edges connect multiple nodes that co-occur; permanence strengthens
// via Hebbian learning and weakens via decay.
//
// State map holds scalar metadata: edge_count.
// The caller must also create separate mutable arrays:
//   let mut e_nodes = []        — flat array of node IDs (all edges concatenated)
//   let mut e_arities = []      — arity (number of nodes) per edge
//   let mut e_offsets = []      — start offset in e_nodes per edge
//   let mut e_permanences = []  — permanence value [0,1] per edge
//   let mut e_weights = []      — accumulated weight per edge
//   let mut e_activations = []  — activation count per edge
//
// All arrays are modified in-place via shared mutation semantics.

// ── Constants ────────────────────────────────────────────────────
let INITIAL_PERMANENCE = 0.3
let PERMANENCE_BONUS = 0.02

// ── Edge index cache ─────────────────────────────────────────────
// Maps sorted-key string → edge index string for O(1) dedup lookup.
// Populated by edges_add; queried by _find_edge.
let mut _edge_index = map()

// ── edges_new ────────────────────────────────────────────────────
// Create an empty hyperedge store (scalar state only).
// The caller must also create the six parallel arrays listed above.
fn edges_new()
  let mut state = map()
  map_set(state, "edge_count", 0.0)
  return state
end

// ── _edge_key ────────────────────────────────────────────────────
// Helper: Sort node IDs and create a string key like "0,1,2".
// Used for deduplication — edges with the same nodes in any order
// produce the same key.
fn _edge_key(node_ids)
  // Sort a copy of node_ids
  let n = len(node_ids)
  let mut tmp = []
  let mut ci = 0.0
  while ci < n
    push(tmp, node_ids[ci])
    ci = ci + 1.0
  end
  let sorted = sort_array(tmp)

  // Build string key
  let mut key = ""
  let mut i = 0.0
  while i < n
    if i > 0.0
      key = key + ","
    end
    key = key + str(int(sorted[i]))
    i = i + 1.0
  end
  return key
end

// ── _find_edge ───────────────────────────────────────────────────
// O(1) lookup via _edge_index map. Returns edge index if found, -1.0 if not.
fn _find_edge(state, e_nodes, e_arities, e_offsets, key)
  if map_has(_edge_index, key)
    return float(map_get(_edge_index, key))
  end
  return -1.0
end

// ── edges_add ────────────────────────────────────────────────────
// Add or strengthen a hyperedge connecting node_ids.
// If an edge with the same sorted nodes exists, strengthen it
// (permanence += PERMANENCE_BONUS * weight, capped at 1.0).
// Otherwise create a new edge with initial permanence 0.3.
// All arrays are modified in-place. Returns 0.0.
fn edges_add(state, e_nodes, e_arities, e_offsets, e_permanences, e_weights, e_activations, node_ids, weight)
  let key = _edge_key(node_ids)
  let existing = _find_edge(state, e_nodes, e_arities, e_offsets, key)

  if existing >= 0.0
    // Strengthen existing edge
    let old_perm = e_permanences[existing]
    let mut new_perm = old_perm + PERMANENCE_BONUS * weight
    if new_perm > 1.0
      new_perm = 1.0
    end
    e_permanences[existing] = new_perm

    let old_w = e_weights[existing]
    e_weights[existing] = old_w + weight

    let old_a = e_activations[existing]
    e_activations[existing] = old_a + 1.0
  else
    // Create new edge
    let edge_count = map_get(state, "edge_count")

    // Record offset (current end of e_nodes)
    let offset = len(e_nodes)

    // Sort node_ids before storing
    let n = len(node_ids)
    let mut tmp_ids = []
    let mut i = 0.0
    while i < n
      push(tmp_ids, node_ids[i])
      i = i + 1.0
    end
    let sorted = sort_array(tmp_ids)

    // Append sorted node IDs to flat nodes array
    i = 0.0
    while i < n
      push(e_nodes, sorted[i])
      i = i + 1.0
    end

    push(e_arities, n)
    push(e_offsets, offset)
    push(e_permanences, INITIAL_PERMANENCE)
    push(e_weights, weight)
    push(e_activations, 1.0)

    map_set(state, "edge_count", edge_count + 1.0)

    // Index the new edge for O(1) lookup
    map_set(_edge_index, key, str(edge_count))
  end

  return 0.0
end

// ── edges_query ──────────────────────────────────────────────────
// Find edges overlapping with context_nodes.
// Returns a flat array of triples: [edge_idx, overlap_fraction, permanence, ...]
// overlap_fraction = (number of context nodes in edge) / (arity of edge)
fn edges_query(state, e_nodes, e_arities, e_offsets, e_permanences, context_nodes)
  let edge_count = map_get(state, "edge_count")
  let ctx_len = len(context_nodes)

  let mut results = []

  let mut idx = 0.0
  while idx < edge_count
    let arity = e_arities[idx]
    let offset = e_offsets[idx]

    // Count overlap: how many context_nodes appear in this edge
    let mut overlap = 0.0
    let mut ci = 0.0
    while ci < ctx_len
      let ctx_node = context_nodes[ci]
      let mut ni = 0.0
      while ni < arity
        if e_nodes[offset + ni] == ctx_node
          overlap = overlap + 1.0
        end
        ni = ni + 1.0
      end
      ci = ci + 1.0
    end

    // Only include edges with at least one overlapping node
    if overlap > 0.0
      let fraction = overlap / arity
      let perm = e_permanences[idx]
      push(results, idx)
      push(results, fraction)
      push(results, perm)
    end

    idx = idx + 1.0
  end

  return results
end

// ── edges_decay ──────────────────────────────────────────────────
// Multiply all permanences by factor. In-place mutation.
// Returns 0.0.
fn edges_decay(state, e_permanences, factor)
  let edge_count = map_get(state, "edge_count")

  let mut i = 0.0
  while i < edge_count
    let old_p = e_permanences[i]
    e_permanences[i] = old_p * factor
    i = i + 1.0
  end

  return 0.0
end

// ── edges_get_nodes ──────────────────────────────────────────────
// Pure function. Returns an array of node IDs for the given edge.
fn edges_get_nodes(state, e_nodes, e_arities, e_offsets, edge_index)
  let arity = e_arities[edge_index]
  let offset = e_offsets[edge_index]

  let mut result = []
  let mut i = 0.0
  while i < arity
    push(result, e_nodes[offset + i])
    i = i + 1.0
  end
  return result
end
