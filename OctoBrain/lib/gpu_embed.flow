// OctoBrain GPU Embedding Module
// GPU-accelerated embedding projection with CPU fallback.
// Uses gpu_matmul for matrix-vector multiply: raw_data^T * W_embed.
//
// Key insight: embed_project computes result[c] = sum_r(raw_data[r] * W_embed[r * embed_dim + c])
// This is exactly (1 x input_dim) * (input_dim x embed_dim) = (1 x embed_dim).
// gpu_matmul(A, B, m, n, k) computes (m x k) * (k x n) = (m x n),
// so gpu_matmul(raw_data, W_embed, 1, embed_dim, input_dim) gives the projection.
//
// Run with: --allow-ffi --allow-read

use "vecmath"
use "../../stdlib/loom/math/linalg"
use "../../stdlib/loom/ops/runtime"

// GPU threshold: use GPU path when input_dim * embed_dim exceeds this
let GPU_EMBED_THRESHOLD = 64.0

// Module state: GPU readiness flag (single-element array for cross-function mutation)
let mut GPU_EMBED_READY = [0.0]

// ── gpu_embed_init ──────────────────────────────────────────────────
// Initialize the GPU runtime (Vulkan). Call once before using GPU path.
// Sets GPU_EMBED_READY[0] = 1.0 on success.
fn gpu_embed_init()
  rt_init()
  GPU_EMBED_READY[0] = 1.0
  return 1.0
end

// ── gpu_embed_cleanup ───────────────────────────────────────────────
// Clean up GPU resources. Call once when done with GPU embedding.
// Sets GPU_EMBED_READY[0] = 0.0.
fn gpu_embed_cleanup()
  if GPU_EMBED_READY[0] > 0.5
    rt_cleanup()
    GPU_EMBED_READY[0] = 0.0
  end
  return 0.0
end

// ── gpu_embed_project ───────────────────────────────────────────────
// GPU-accelerated embedding projection.
// W_embed: flat [input_dim x embed_dim] row-major
// raw_data: [input_dim]
// input_dim: number of input dimensions
// embed_dim: number of embedding dimensions
// Returns normalized [embed_dim] array.
//
// GPU path: when GPU_EMBED_READY and input_dim * embed_dim >= GPU_EMBED_THRESHOLD,
//   uses gpu_matmul for the matrix multiply in a single dispatch.
//   gpu_matmul(raw_data, W_embed, 1, embed_dim, input_dim) computes
//   (1 x input_dim) * (input_dim x embed_dim) = (1 x embed_dim).
// CPU fallback: iterates through dimensions manually (same as embed_project).
fn gpu_embed_project(W_embed, raw_data, input_dim, embed_dim)
  let ops = input_dim * embed_dim
  if GPU_EMBED_READY[0] > 0.5 && ops >= GPU_EMBED_THRESHOLD
    // GPU path: matmul raw_data (as 1 x input_dim) * W_embed (input_dim x embed_dim)
    let raw_result = gpu_matmul(raw_data, W_embed, 1.0, embed_dim, input_dim)

    // Normalize the projection
    let normed = normalize(raw_result, embed_dim)
    return normed
  end

  // CPU fallback: manual matrix-vector multiply
  let mut result = []
  let mut c = 0.0
  while c < embed_dim
    let mut sum = 0.0
    let mut r = 0.0
    while r < input_dim
      sum = sum + raw_data[r] * W_embed[r * embed_dim + c]
      r = r + 1.0
    end
    push(result, sum)
    c = c + 1.0
  end

  // Normalize the projection
  let normed = normalize(result, embed_dim)
  return normed
end
