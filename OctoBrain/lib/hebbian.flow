// OctoBrain Hebbian Learning
// Strengthens hyperedges between co-occurring prototypes using
// pairwise correlation and Oja's rule for permanence updates.
//
// Depends on vecmath.flow for vector operations and edges.flow for
// hyperedge store manipulation.
//
// All embeddings are flat arrays: [num_nodes * embed_dim] stored row-major.
// Functions follow the external arrays pattern — mutable arrays are
// passed in and modified in-place.

use "vecmath"
use "edges"

// ── Constants ────────────────────────────────────────────────────
let HEBBIAN_LR = 0.01
let HEBBIAN_BONUS = 0.02

// ── avg_pairwise_corr ────────────────────────────────────────────
// Pure function. Compute average pairwise cosine similarity between
// all unique pairs (i < j) of node embeddings.
// embeddings_flat: flat array [num_nodes * embed_dim]
// num_nodes: number of nodes (f32)
// embed_dim: embedding dimension (f32)
// Returns average correlation scalar.
fn avg_pairwise_corr(embeddings_flat, num_nodes, embed_dim)
  let mut total = 0.0
  let mut pair_count = 0.0

  let mut i = 0.0
  while i < num_nodes
    let vec_i = vec_extract(embeddings_flat, i, embed_dim)
    let mut j = i + 1.0
    while j < num_nodes
      let vec_j = vec_extract(embeddings_flat, j, embed_dim)
      let sim = cosine_sim(vec_i, vec_j, embed_dim)
      total = total + sim
      pair_count = pair_count + 1.0
      j = j + 1.0
    end
    i = i + 1.0
  end

  if pair_count < 0.5
    return 0.0
  end
  return total / pair_count
end

// ── mean_embedding ───────────────────────────────────────────────
// Pure function. Compute element-wise mean of all node embeddings.
// Returns array of length embed_dim.
fn mean_embedding(embeddings_flat, num_nodes, embed_dim)
  // Accumulate sums per dimension
  let mut sums = []
  let mut di = 0.0
  while di < embed_dim
    push(sums, 0.0)
    di = di + 1.0
  end

  // Sum across all nodes
  let mut ni = 0.0
  while ni < num_nodes
    let off = ni * embed_dim
    let mut di2 = 0.0
    while di2 < embed_dim
      sums[di2] = sums[di2] + embeddings_flat[off + di2]
      di2 = di2 + 1.0
    end
    ni = ni + 1.0
  end

  // Divide by num_nodes to get mean
  let mut result = []
  if num_nodes > 0.0
    let mut di3 = 0.0
    while di3 < embed_dim
      push(result, sums[di3] / num_nodes)
      di3 = di3 + 1.0
    end
  else
    let mut di4 = 0.0
    while di4 < embed_dim
      push(result, 0.0)
      di4 = di4 + 1.0
    end
  end
  return result
end

// ── oja_update ───────────────────────────────────────────────────
// Pure function. Oja's rule for permanence update.
// permanence: current permanence value [0,1]
// avg_corr: average pairwise correlation
// mean_sq: squared norm of mean embedding
// lr: learning rate (typically HEBBIAN_LR)
// weight: edge weight
// Returns updated permanence clamped to [0, 1].
fn oja_update(permanence, avg_corr, mean_sq, lr, weight)
  let delta = lr * weight * (avg_corr - mean_sq * permanence) + HEBBIAN_BONUS * weight
  let mut new_perm = permanence + delta
  if new_perm > 1.0
    new_perm = 1.0
  end
  if new_perm < 0.0
    new_perm = 0.0
  end
  return new_perm
end

// ── learn_edge ───────────────────────────────────────────────────
// Full Hebbian learning for one hyperedge.
// Gathers embeddings for nodes in node_ids from proto_embeddings,
// computes pairwise correlation, applies Oja's rule, and
// adds/strengthens the edge in the edge store.
//
// proto_embeddings: flat array of all prototype embeddings [proto_count * embed_dim]
// embed_dim: embedding dimension (f32)
// edge_state: mutable map from edges_new()
// e_nodes, e_arities, e_offsets, e_permanences, e_weights, e_activations:
//   mutable edge arrays (modified in-place)
// node_ids: array of prototype IDs to connect
// weight: edge weight (f32)
// Returns 0.0.
fn learn_edge(proto_embeddings, embed_dim, edge_state, e_nodes, e_arities, e_offsets, e_permanences, e_weights, e_activations, node_ids, weight)
  let num_nodes = len(node_ids)

  // Step 1: Gather embeddings for the specified node IDs
  let mut gathered = []
  let mut gi = 0.0
  while gi < num_nodes
    let node_id = node_ids[gi]
    let emb = vec_extract(proto_embeddings, node_id, embed_dim)
    let mut ei = 0.0
    while ei < embed_dim
      push(gathered, emb[ei])
      ei = ei + 1.0
    end
    gi = gi + 1.0
  end

  // Step 2: Compute average pairwise correlation
  let avg_corr = avg_pairwise_corr(gathered, num_nodes, embed_dim)

  // Step 3: Compute mean embedding and its squared norm
  let mean_emb = mean_embedding(gathered, num_nodes, embed_dim)
  let mean_sq = dot_product(mean_emb, mean_emb, embed_dim)

  // Step 4: Add or strengthen the edge
  let dummy = edges_add(edge_state, e_nodes, e_arities, e_offsets, e_permanences, e_weights, e_activations, node_ids, weight)

  // Step 5: Find the edge index and apply Oja's update to its permanence
  let key = _edge_key(node_ids)
  let edge_idx = _find_edge(edge_state, e_nodes, e_arities, e_offsets, key)

  if edge_idx >= 0.0
    let current_perm = e_permanences[edge_idx]
    let new_perm = oja_update(current_perm, avg_corr, mean_sq, HEBBIAN_LR, weight)
    e_permanences[edge_idx] = new_perm
  end

  return 0.0
end
