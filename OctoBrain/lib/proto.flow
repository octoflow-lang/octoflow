// OctoBrain Prototype Store
// Matches observations to learned prototypes.
// Prototypes grow unbounded when new data doesn't match existing ones.
// Depends on vecmath.flow for vector operations.
//
// State map holds scalar values: proto_count, embed_dim, last_match_id, etc.
// Embeddings and match_counts are separate mutable arrays passed by the caller.
// All state is modified in-place via shared mutation semantics.

use "vecmath"
use "gpu_match"

// ── compute_threshold ────────────────────────────────────────
// Adaptive cosine similarity threshold based on dimension.
// In D dimensions, random unit vectors have cosine similarity std ≈ 1/√D.
// Maintains 2.4σ significance across dimensions.
// Clamped to [0.3, 0.85] to avoid degenerate behavior.
fn compute_threshold(dim)
  let sigma_inv = 2.4 / sqrt(dim)
  let mut threshold = sigma_inv
  if threshold > 0.85
    threshold = 0.85
  end
  if threshold < 0.3
    threshold = 0.3
  end
  return threshold
end

// ── proto_new ────────────────────────────────────────────────
// Create an empty prototype store (scalar state only).
// The caller must also create separate mutable arrays:
//   let mut embeddings = []
//   let mut match_counts = []
fn proto_new()
  let mut state = map()
  map_set(state, "proto_count", 0.0)
  map_set(state, "embed_dim", 0.0)
  map_set(state, "last_match_id", -1.0)
  map_set(state, "last_match_sim", 0.0)
  map_set(state, "prev_match_id", -1.0)
  map_set(state, "transition_detected", 0.0)
  map_set(state, "transition_count", 0.0)
  return state
end

// ── proto_observe ────────────────────────────────────────────
// Match observation to existing prototypes, or create a new one.
// state: mutable map from proto_new() (modified in-place)
// embeddings: mutable flat array [proto_count * dim] (modified in-place)
// match_counts: mutable array of per-proto activation counts (modified in-place)
// embedding: input vector of length dim
// dim: embedding dimension (f32)
// Returns the matched/created prototype ID.
// All state is modified in-place — no need to reassign.
fn proto_observe(state, embeddings, match_counts, embedding, dim)
  // Step 0: Zero-vector guard — skip degenerate observations
  let input_norm = vec_norm(embedding, dim)
  if input_norm < 0.000001
    // Return last match unchanged — degenerate input has no angular information
    return map_get(state, "last_match_id")
  end

  // Step 1: Normalize the input embedding
  let normed = normalize(embedding, dim)

  let proto_count = map_get(state, "proto_count")
  let prev_last = map_get(state, "last_match_id")

  let mut best_id = -1.0
  let mut best_sim = -2.0

  // Step 2: If first observation, create first prototype
  if proto_count == 0.0
    // Append normalized embedding to flat array
    let mut i = 0.0
    while i < dim
      push(embeddings, normed[i])
      i = i + 1.0
    end
    push(match_counts, 1.0)

    map_set(state, "proto_count", 1.0)
    map_set(state, "embed_dim", dim)
    map_set(state, "last_match_id", 0.0)
    map_set(state, "last_match_sim", 1.0)
    map_set(state, "prev_match_id", prev_last)

    // Transition detection
    if prev_last >= 0.0 && prev_last != 0.0
      map_set(state, "transition_detected", 1.0)
      let tc = map_get(state, "transition_count")
      map_set(state, "transition_count", tc + 1.0)
    else
      map_set(state, "transition_detected", 0.0)
    end

    return 0.0
  end

  // Step 3: GPU-accelerated matching (CPU fallback for small proto_count)
  let match_result = gpu_match_best(embeddings, normed, dim, proto_count)
  best_id = match_result[0]
  best_sim = match_result[1]

  // Step 4/5: Match or create (adaptive threshold based on dimension)
  let threshold = compute_threshold(dim)
  if best_sim >= threshold
    // Match — EMA drift prototype toward observation (alpha=0.1)
    let proto_vec = vec_extract(embeddings, best_id, dim)
    // EMA: new_proto = (1 - alpha) * proto + alpha * observation
    let scaled_old = vec_scale(proto_vec, 0.9, dim)
    let scaled_new = vec_scale(normed, 0.1, dim)
    let drifted = vec_add(scaled_old, scaled_new, dim)
    // Re-normalize after drift
    let drifted_normed = normalize(drifted, dim)
    // Write back into flat embeddings array (overwrite in-place)
    let base = best_id * dim
    let mut wi = 0.0
    while wi < dim
      embeddings[base + wi] = drifted_normed[wi]
      wi = wi + 1.0
    end

    // Update match count
    let old_count = match_counts[best_id]
    match_counts[best_id] = old_count + 1.0
  else
    // Create new prototype
    let mut i = 0.0
    while i < dim
      push(embeddings, normed[i])
      i = i + 1.0
    end
    push(match_counts, 1.0)
    best_id = proto_count
    best_sim = 1.0
    map_set(state, "proto_count", proto_count + 1.0)
  end

  // Step 6: Update state
  map_set(state, "embed_dim", dim)
  map_set(state, "last_match_id", best_id)
  map_set(state, "last_match_sim", best_sim)
  map_set(state, "prev_match_id", prev_last)

  // Transition detection
  if prev_last >= 0.0 && prev_last != best_id
    map_set(state, "transition_detected", 1.0)
    let tc = map_get(state, "transition_count")
    map_set(state, "transition_count", tc + 1.0)
  else
    map_set(state, "transition_detected", 0.0)
  end

  return best_id
end
