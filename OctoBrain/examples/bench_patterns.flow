// OctoBrain Pattern Sequence Benchmark
// Tests the brain's transition prediction capability — its natural strength.
// Three pattern types with known transition structure:
//   A. ABAB alternating (200 obs) — 2 protos, ~199 transitions
//   B. AABB paired (200 obs) — 2 protos, ~99 transitions
//   C. ABCABC rotating (300 obs) — 3 protos, ~299 transitions
//
// After training, a second pass evaluates transition prediction accuracy
// using a second-order Markov table built from the training sequence.
// Second-order Markov: predict next proto from (prev_proto, curr_proto) pair.
// This captures patterns like AABB where first-order is ambiguous.
//
// Each sub-test uses its own brain instance.

use "../lib/octobrain"

print("=== OctoBrain Pattern Sequence Benchmark ===")
print("")

// =====================================================================
// Sub-test A: ABAB Alternating Pattern (200 observations)
// Encode: A=[1,0,0], B=[0,1,0], alternating A B A B ...
// Expected: 2 protos, ~199 transitions
// =====================================================================
print("--- Sub-test A: ABAB Alternating Pattern (200 obs) ---")

let mut brainA = octobrain_new(2.0)
let mut p_stateA = proto_new()
let mut p_embsA = []
let mut p_mcA = []
let mut e_stateA = embed_new()
let mut W_embedA = []
let mut obs_bufferA = []
let mut edge_stateA = edges_new()
let mut enA = []
let mut eaA = []
let mut eoA = []
let mut epA = []
let mut ewA = []
let mut eactA = []
let mut windowA = []
let mut W_scoreA = []

// -- Training pass A: feed 200 ABAB observations, record proto sequence --
let mut train_seqA = []
let mut stepA = 0.0
while stepA < 200.0
  let half_a = stepA / 2.0
  let is_even_a = floor(half_a) * 2.0
  let mut dataA = []
  if is_even_a == stepA
    push(dataA, 1.0)
    push(dataA, 0.0)
    push(dataA, 0.0)
  else
    push(dataA, 0.0)
    push(dataA, 1.0)
    push(dataA, 0.0)
  end
  let _obsA = octobrain_observe(brainA, p_stateA, p_embsA, p_mcA, e_stateA, W_embedA, obs_bufferA, edge_stateA, enA, eaA, eoA, epA, ewA, eactA, windowA, W_scoreA, dataA)
  let pidA = map_get(p_stateA, "last_match_id")
  push(train_seqA, pidA)
  stepA = stepA + 1.0
end

let statsA = octobrain_stats(brainA, p_stateA, edge_stateA)
let pcA = map_get(statsA, "proto_count")
let tcA = map_get(statsA, "transition_count")
let ecA = map_get(statsA, "edge_count")
print("Training: protos={pcA}, edges={ecA}, transitions={tcA}")

// -- Build second-order Markov transition table from training sequence --
// Flat table: trans2[prev * pcA * pcA + curr * pcA + next] = count
// Size: pcA^3 (at most 8 for 2 protos)
let mut trans2_A = []
let t2a_size = pcA * pcA * pcA
let mut t2a_i = 0.0
while t2a_i < t2a_size
  push(trans2_A, 0.0)
  t2a_i = t2a_i + 1.0
end

let seqlenA = len(train_seqA)
let mut si_a = 2.0
while si_a < seqlenA
  let pp_a = train_seqA[si_a - 2.0]
  let cp_a = train_seqA[si_a - 1.0]
  let np_a = train_seqA[si_a]
  let idx2_a = pp_a * pcA * pcA + cp_a * pcA + np_a
  trans2_A[idx2_a] = trans2_A[idx2_a] + 1.0
  si_a = si_a + 1.0
end

// -- Test pass A: feed same data, predict from second-order Markov table --
let mut correctA = 0.0
let mut totalA = 0.0
// Track last two proto IDs in the test pass
let mut prev_pidA = -1.0
let mut curr_pidA = -1.0

let mut test_stepA = 0.0
while test_stepA < 200.0
  let half_ta = test_stepA / 2.0
  let is_even_ta = floor(half_ta) * 2.0
  let mut test_dataA = []
  if is_even_ta == test_stepA
    push(test_dataA, 1.0)
    push(test_dataA, 0.0)
    push(test_dataA, 0.0)
  else
    push(test_dataA, 0.0)
    push(test_dataA, 1.0)
    push(test_dataA, 0.0)
  end

  if test_stepA >= 2.0
    // Predict: argmax over trans2_A[prev_pidA * pcA^2 + curr_pidA * pcA + :]
    let mut best_next_a = 0.0
    let mut best_count_a = -1.0
    let mut ca = 0.0
    while ca < pcA
      let ci2_a = prev_pidA * pcA * pcA + curr_pidA * pcA + ca
      if trans2_A[ci2_a] > best_count_a
        best_count_a = trans2_A[ci2_a]
        best_next_a = ca
      end
      ca = ca + 1.0
    end

    // Feed observation
    let _tA = octobrain_observe(brainA, p_stateA, p_embsA, p_mcA, e_stateA, W_embedA, obs_bufferA, edge_stateA, enA, eaA, eoA, epA, ewA, eactA, windowA, W_scoreA, test_dataA)
    let actual_a = map_get(p_stateA, "last_match_id")

    if best_next_a == actual_a
      correctA = correctA + 1.0
    end
    totalA = totalA + 1.0
    prev_pidA = curr_pidA
    curr_pidA = actual_a
  else
    // First two observations — no second-order prediction possible, just feed
    let _t0A = octobrain_observe(brainA, p_stateA, p_embsA, p_mcA, e_stateA, W_embedA, obs_bufferA, edge_stateA, enA, eaA, eoA, epA, ewA, eactA, windowA, W_scoreA, test_dataA)
    let fed_a = map_get(p_stateA, "last_match_id")
    prev_pidA = curr_pidA
    curr_pidA = fed_a
  end

  test_stepA = test_stepA + 1.0
end

let accA = correctA / totalA
let pctA = floor(accA * 1000.0) / 10.0
print("Transition prediction: {correctA}/{totalA} = {pctA}%")

if pcA == 2.0 && accA >= 0.90
  print("PASS ABAB: protos=2, prediction={pctA}% >= 90%")
elif pcA == 2.0
  print("FAIL ABAB: protos=2 correct, but prediction={pctA}% < 90%")
else
  print("FAIL ABAB: expected 2 protos, got {pcA}")
end
print("")

// =====================================================================
// Sub-test B: AABB Paired Pattern (200 observations)
// Encode: A=[1,0,0], B=[0,1,0], pairs: AA BB AA BB ...
// Expected: 2 protos, ~99 transitions
// =====================================================================
print("--- Sub-test B: AABB Paired Pattern (200 obs) ---")

let mut brainB = octobrain_new(2.0)
let mut p_stateB = proto_new()
let mut p_embsB = []
let mut p_mcB = []
let mut e_stateB = embed_new()
let mut W_embedB = []
let mut obs_bufferB = []
let mut edge_stateB = edges_new()
let mut enB = []
let mut eaB = []
let mut eoB = []
let mut epB = []
let mut ewB = []
let mut eactB = []
let mut windowB = []
let mut W_scoreB = []

// -- Training pass B: feed 200 AABB observations, record proto sequence --
let mut train_seqB = []
let mut stepB = 0.0
while stepB < 200.0
  // Pattern: positions 0,1 = A; 2,3 = B; 4,5 = A; 6,7 = B; ...
  // group = floor(stepB / 2.0), if group is even => A, odd => B
  let group_b = floor(stepB / 2.0)
  let half_gb = group_b / 2.0
  let is_even_gb = floor(half_gb) * 2.0
  let mut dataB = []
  if is_even_gb == group_b
    push(dataB, 1.0)
    push(dataB, 0.0)
    push(dataB, 0.0)
  else
    push(dataB, 0.0)
    push(dataB, 1.0)
    push(dataB, 0.0)
  end
  let _obsB = octobrain_observe(brainB, p_stateB, p_embsB, p_mcB, e_stateB, W_embedB, obs_bufferB, edge_stateB, enB, eaB, eoB, epB, ewB, eactB, windowB, W_scoreB, dataB)
  let pidB = map_get(p_stateB, "last_match_id")
  push(train_seqB, pidB)
  stepB = stepB + 1.0
end

let statsB = octobrain_stats(brainB, p_stateB, edge_stateB)
let pcB = map_get(statsB, "proto_count")
let tcB = map_get(statsB, "transition_count")
let ecB = map_get(statsB, "edge_count")
print("Training: protos={pcB}, edges={ecB}, transitions={tcB}")

// -- Build second-order Markov transition table from training sequence --
let mut trans2_B = []
let t2b_size = pcB * pcB * pcB
let mut t2b_i = 0.0
while t2b_i < t2b_size
  push(trans2_B, 0.0)
  t2b_i = t2b_i + 1.0
end

let seqlenB = len(train_seqB)
let mut si_b = 2.0
while si_b < seqlenB
  let pp_b = train_seqB[si_b - 2.0]
  let cp_b = train_seqB[si_b - 1.0]
  let np_b = train_seqB[si_b]
  let idx2_b = pp_b * pcB * pcB + cp_b * pcB + np_b
  trans2_B[idx2_b] = trans2_B[idx2_b] + 1.0
  si_b = si_b + 1.0
end

// -- Test pass B: feed same data, predict from second-order Markov table --
let mut correctB = 0.0
let mut totalB = 0.0
let mut prev_pidB = -1.0
let mut curr_pidB = -1.0

let mut test_stepB = 0.0
while test_stepB < 200.0
  let group_tb = floor(test_stepB / 2.0)
  let half_gtb = group_tb / 2.0
  let is_even_gtb = floor(half_gtb) * 2.0
  let mut test_dataB = []
  if is_even_gtb == group_tb
    push(test_dataB, 1.0)
    push(test_dataB, 0.0)
    push(test_dataB, 0.0)
  else
    push(test_dataB, 0.0)
    push(test_dataB, 1.0)
    push(test_dataB, 0.0)
  end

  if test_stepB >= 2.0
    let mut best_next_b = 0.0
    let mut best_count_b = -1.0
    let mut cb = 0.0
    while cb < pcB
      let ci2_b = prev_pidB * pcB * pcB + curr_pidB * pcB + cb
      if trans2_B[ci2_b] > best_count_b
        best_count_b = trans2_B[ci2_b]
        best_next_b = cb
      end
      cb = cb + 1.0
    end

    let _tB = octobrain_observe(brainB, p_stateB, p_embsB, p_mcB, e_stateB, W_embedB, obs_bufferB, edge_stateB, enB, eaB, eoB, epB, ewB, eactB, windowB, W_scoreB, test_dataB)
    let actual_b = map_get(p_stateB, "last_match_id")

    if best_next_b == actual_b
      correctB = correctB + 1.0
    end
    totalB = totalB + 1.0
    prev_pidB = curr_pidB
    curr_pidB = actual_b
  else
    let _t0B = octobrain_observe(brainB, p_stateB, p_embsB, p_mcB, e_stateB, W_embedB, obs_bufferB, edge_stateB, enB, eaB, eoB, epB, ewB, eactB, windowB, W_scoreB, test_dataB)
    let fed_b = map_get(p_stateB, "last_match_id")
    prev_pidB = curr_pidB
    curr_pidB = fed_b
  end

  test_stepB = test_stepB + 1.0
end

let accB = correctB / totalB
let pctB = floor(accB * 1000.0) / 10.0
print("Transition prediction: {correctB}/{totalB} = {pctB}%")

if pcB == 2.0 && accB >= 0.60
  print("PASS AABB: protos=2, prediction={pctB}% >= 60%")
elif pcB == 2.0
  print("FAIL AABB: protos=2 correct, but prediction={pctB}% < 60%")
else
  print("FAIL AABB: expected 2 protos, got {pcB}")
end
print("")

// =====================================================================
// Sub-test C: ABCABC Rotating Pattern (300 observations)
// Encode: A=[1,0,0], B=[0,1,0], C=[0,0,1], rotating A B C A B C ...
// Expected: 3 protos, ~299 transitions
// =====================================================================
print("--- Sub-test C: ABCABC Rotating Pattern (300 obs) ---")

let mut brainC = octobrain_new(2.0)
let mut p_stateC = proto_new()
let mut p_embsC = []
let mut p_mcC = []
let mut e_stateC = embed_new()
let mut W_embedC = []
let mut obs_bufferC = []
let mut edge_stateC = edges_new()
let mut enC = []
let mut eaC = []
let mut eoC = []
let mut epC = []
let mut ewC = []
let mut eactC = []
let mut windowC = []
let mut W_scoreC = []

// -- Training pass C: feed 300 ABCABC observations, record proto sequence --
let mut train_seqC = []
let mut stepC = 0.0
while stepC < 300.0
  // Position in cycle: 0=A, 1=B, 2=C
  let mod3_c = stepC - floor(stepC / 3.0) * 3.0
  let mut dataC = []
  if mod3_c < 0.5
    // A
    push(dataC, 1.0)
    push(dataC, 0.0)
    push(dataC, 0.0)
  elif mod3_c < 1.5
    // B
    push(dataC, 0.0)
    push(dataC, 1.0)
    push(dataC, 0.0)
  else
    // C
    push(dataC, 0.0)
    push(dataC, 0.0)
    push(dataC, 1.0)
  end
  let _obsC = octobrain_observe(brainC, p_stateC, p_embsC, p_mcC, e_stateC, W_embedC, obs_bufferC, edge_stateC, enC, eaC, eoC, epC, ewC, eactC, windowC, W_scoreC, dataC)
  let pidC = map_get(p_stateC, "last_match_id")
  push(train_seqC, pidC)
  stepC = stepC + 1.0
end

let statsC = octobrain_stats(brainC, p_stateC, edge_stateC)
let pcC = map_get(statsC, "proto_count")
let tcC = map_get(statsC, "transition_count")
let ecC = map_get(statsC, "edge_count")
print("Training: protos={pcC}, edges={ecC}, transitions={tcC}")

// -- Build second-order Markov transition table from training sequence --
let mut trans2_C = []
let t2c_size = pcC * pcC * pcC
let mut t2c_i = 0.0
while t2c_i < t2c_size
  push(trans2_C, 0.0)
  t2c_i = t2c_i + 1.0
end

let seqlenC = len(train_seqC)
let mut si_c = 2.0
while si_c < seqlenC
  let pp_c = train_seqC[si_c - 2.0]
  let cp_c = train_seqC[si_c - 1.0]
  let np_c = train_seqC[si_c]
  let idx2_c = pp_c * pcC * pcC + cp_c * pcC + np_c
  trans2_C[idx2_c] = trans2_C[idx2_c] + 1.0
  si_c = si_c + 1.0
end

// -- Test pass C: feed same data, predict from second-order Markov table --
let mut correctC = 0.0
let mut totalC = 0.0
let mut prev_pidC = -1.0
let mut curr_pidC = -1.0

let mut test_stepC = 0.0
while test_stepC < 300.0
  let mod3_tc = test_stepC - floor(test_stepC / 3.0) * 3.0
  let mut test_dataC = []
  if mod3_tc < 0.5
    push(test_dataC, 1.0)
    push(test_dataC, 0.0)
    push(test_dataC, 0.0)
  elif mod3_tc < 1.5
    push(test_dataC, 0.0)
    push(test_dataC, 1.0)
    push(test_dataC, 0.0)
  else
    push(test_dataC, 0.0)
    push(test_dataC, 0.0)
    push(test_dataC, 1.0)
  end

  if test_stepC >= 2.0
    let mut best_next_c = 0.0
    let mut best_count_c = -1.0
    let mut cc = 0.0
    while cc < pcC
      let ci2_c = prev_pidC * pcC * pcC + curr_pidC * pcC + cc
      if trans2_C[ci2_c] > best_count_c
        best_count_c = trans2_C[ci2_c]
        best_next_c = cc
      end
      cc = cc + 1.0
    end

    let _tC = octobrain_observe(brainC, p_stateC, p_embsC, p_mcC, e_stateC, W_embedC, obs_bufferC, edge_stateC, enC, eaC, eoC, epC, ewC, eactC, windowC, W_scoreC, test_dataC)
    let actual_c = map_get(p_stateC, "last_match_id")

    if best_next_c == actual_c
      correctC = correctC + 1.0
    end
    totalC = totalC + 1.0
    prev_pidC = curr_pidC
    curr_pidC = actual_c
  else
    let _t0C = octobrain_observe(brainC, p_stateC, p_embsC, p_mcC, e_stateC, W_embedC, obs_bufferC, edge_stateC, enC, eaC, eoC, epC, ewC, eactC, windowC, W_scoreC, test_dataC)
    let fed_c = map_get(p_stateC, "last_match_id")
    prev_pidC = curr_pidC
    curr_pidC = fed_c
  end

  test_stepC = test_stepC + 1.0
end

let accC = correctC / totalC
let pctC = floor(accC * 1000.0) / 10.0
print("Transition prediction: {correctC}/{totalC} = {pctC}%")

if pcC == 3.0 && accC >= 0.85
  print("PASS ABCABC: protos=3, prediction={pctC}% >= 85%")
elif pcC == 3.0
  print("FAIL ABCABC: protos=3 correct, but prediction={pctC}% < 85%")
else
  print("FAIL ABCABC: expected 3 protos, got {pcC}")
end
print("")

// =====================================================================
// Summary
// =====================================================================
print("=== Pattern Sequence Benchmark Summary ===")
print("ABAB:   protos={pcA}/2, transitions={tcA}, prediction={pctA}% (threshold: 90%)")
print("AABB:   protos={pcB}/2, transitions={tcB}, prediction={pctB}% (threshold: 60%)")
print("ABCABC: protos={pcC}/3, transitions={tcC}, prediction={pctC}% (threshold: 85%)")

let mut pass_count = 0.0
if pcA == 2.0 && accA >= 0.90
  pass_count = pass_count + 1.0
end
if pcB == 2.0 && accB >= 0.60
  pass_count = pass_count + 1.0
end
if pcC == 3.0 && accC >= 0.85
  pass_count = pass_count + 1.0
end
print("Result: {pass_count}/3 sub-tests passed")
print("")
print("--- pattern sequence benchmark complete ---")
