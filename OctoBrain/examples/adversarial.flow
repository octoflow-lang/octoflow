// OctoBrain Adversarial Inputs Benchmark
// Four adversarial edge cases that test brain robustness:
//   1. Constant signal — should collapse to 1 proto, 0 transitions
//   2. All zeros — known weakness: zero vectors always create new protos
//   3. Alternating extremes — should yield 2 protos, ~199 transitions
//   4. Constant + spike — should yield 2 protos, 1 transition
//
// Each sub-test uses its own brain instance with 200 observations.

use "../lib/octobrain"

print("=== OctoBrain Adversarial Inputs Benchmark ===")
print("")

// ─────────────────────────────────────────────────────────────────
// Sub-test 1: Constant Signal (200x [1,0,0])
// ─────────────────────────────────────────────────────────────────
print("--- Sub-test 1: Constant Signal (200x [1,0,0]) ---")

let mut brain1 = octobrain_new(2.0)
let mut p_state1 = proto_new()
let mut p_embs1 = []
let mut p_mc1 = []
let mut e_state1 = embed_new()
let mut W_embed1 = []
let mut obs_buffer1 = []
let mut edge_state1 = edges_new()
let mut en1 = []
let mut ea1 = []
let mut eo1 = []
let mut ep1 = []
let mut ew1 = []
let mut eact1 = []
let mut window1 = []
let mut W_score1 = []

let mut step1 = 0.0
while step1 < 200.0
  let data1 = [1.0, 0.0, 0.0]
  let dummy1 = octobrain_observe(brain1, p_state1, p_embs1, p_mc1, e_state1, W_embed1, obs_buffer1, edge_state1, en1, ea1, eo1, ep1, ew1, eact1, window1, W_score1, data1)
  step1 = step1 + 1.0
end

let stats1 = octobrain_stats(brain1, p_state1, edge_state1)
let pc1 = map_get(stats1, "proto_count")
let tc1 = map_get(stats1, "transition_count")
let ec1 = map_get(stats1, "edge_count")

print("Final: protos={pc1}, edges={ec1}, transitions={tc1}")
if pc1 == 1.0 && tc1 == 0.0
  print("PASS constant: proto=1, transitions=0 (exactly as expected)")
else
  print("FAIL constant: expected proto=1 trans=0, got proto={pc1} trans={tc1}")
end
print("")

// ─────────────────────────────────────────────────────────────────
// Sub-test 2: All Zeros (200x [0,0,0])
// ─────────────────────────────────────────────────────────────────
print("--- Sub-test 2: All Zeros (200x [0,0,0]) ---")

let mut brain2 = octobrain_new(2.0)
let mut p_state2 = proto_new()
let mut p_embs2 = []
let mut p_mc2 = []
let mut e_state2 = embed_new()
let mut W_embed2 = []
let mut obs_buffer2 = []
let mut edge_state2 = edges_new()
let mut en2 = []
let mut ea2 = []
let mut eo2 = []
let mut ep2 = []
let mut ew2 = []
let mut eact2 = []
let mut window2 = []
let mut W_score2 = []

let mut step2 = 0.0
while step2 < 200.0
  let data2 = [0.0, 0.0, 0.0]
  let dummy2 = octobrain_observe(brain2, p_state2, p_embs2, p_mc2, e_state2, W_embed2, obs_buffer2, edge_state2, en2, ea2, eo2, ep2, ew2, eact2, window2, W_score2, data2)
  step2 = step2 + 1.0
end

let stats2 = octobrain_stats(brain2, p_state2, edge_state2)
let pc2 = map_get(stats2, "proto_count")
let tc2 = map_get(stats2, "transition_count")
let ec2 = map_get(stats2, "edge_count")

print("Final: protos={pc2}, edges={ec2}, transitions={tc2}")
print("NOTE zeros: proto={pc2} (known weakness: zero vectors normalize to [0,0,0], cosine_sim=0.0 < 0.85, new proto every observation)")
print("")

// ─────────────────────────────────────────────────────────────────
// Sub-test 3: Alternating Extremes (200x alternating [1,0,0] / [0,0,1])
// ─────────────────────────────────────────────────────────────────
print("--- Sub-test 3: Alternating Extremes ---")

let mut brain3 = octobrain_new(2.0)
let mut p_state3 = proto_new()
let mut p_embs3 = []
let mut p_mc3 = []
let mut e_state3 = embed_new()
let mut W_embed3 = []
let mut obs_buffer3 = []
let mut edge_state3 = edges_new()
let mut en3 = []
let mut ea3 = []
let mut eo3 = []
let mut ep3 = []
let mut ew3 = []
let mut eact3 = []
let mut window3 = []
let mut W_score3 = []

let mut step3 = 0.0
while step3 < 200.0
  // Even steps: [1,0,0]; Odd steps: [0,0,1]
  let half = step3 / 2.0
  let is_even = floor(half) * 2.0
  let mut data3 = []
  if is_even == step3
    push(data3, 1.0)
    push(data3, 0.0)
    push(data3, 0.0)
  else
    push(data3, 0.0)
    push(data3, 0.0)
    push(data3, 1.0)
  end
  let dummy3 = octobrain_observe(brain3, p_state3, p_embs3, p_mc3, e_state3, W_embed3, obs_buffer3, edge_state3, en3, ea3, eo3, ep3, ew3, eact3, window3, W_score3, data3)
  step3 = step3 + 1.0
end

let stats3 = octobrain_stats(brain3, p_state3, edge_state3)
let pc3 = map_get(stats3, "proto_count")
let tc3 = map_get(stats3, "transition_count")
let ec3 = map_get(stats3, "edge_count")

print("Final: protos={pc3}, edges={ec3}, transitions={tc3}")
if pc3 == 2.0 && tc3 >= 100.0
  print("PASS alternating: proto={pc3}, transitions={tc3} (2 protos, high transitions as expected)")
elif pc3 == 2.0
  print("PASS alternating: proto={pc3} correct, transitions={tc3} (expected ~199)")
else
  print("FAIL alternating: expected proto=2 trans>=100, got proto={pc3} trans={tc3}")
end
print("")

// ─────────────────────────────────────────────────────────────────
// Sub-test 4: Constant + Spike (199x [1,0,0] then 1x [0,0,1])
// ─────────────────────────────────────────────────────────────────
print("--- Sub-test 4: Constant + Spike ---")

let mut brain4 = octobrain_new(2.0)
let mut p_state4 = proto_new()
let mut p_embs4 = []
let mut p_mc4 = []
let mut e_state4 = embed_new()
let mut W_embed4 = []
let mut obs_buffer4 = []
let mut edge_state4 = edges_new()
let mut en4 = []
let mut ea4 = []
let mut eo4 = []
let mut ep4 = []
let mut ew4 = []
let mut eact4 = []
let mut window4 = []
let mut W_score4 = []

let mut step4 = 0.0
while step4 < 200.0
  let mut data4 = []
  if step4 < 199.0
    // Constant signal
    push(data4, 1.0)
    push(data4, 0.0)
    push(data4, 0.0)
  else
    // Spike on the last observation
    push(data4, 0.0)
    push(data4, 0.0)
    push(data4, 1.0)
  end
  let dummy4 = octobrain_observe(brain4, p_state4, p_embs4, p_mc4, e_state4, W_embed4, obs_buffer4, edge_state4, en4, ea4, eo4, ep4, ew4, eact4, window4, W_score4, data4)
  step4 = step4 + 1.0
end

let stats4 = octobrain_stats(brain4, p_state4, edge_state4)
let pc4 = map_get(stats4, "proto_count")
let tc4 = map_get(stats4, "transition_count")
let ec4 = map_get(stats4, "edge_count")

print("Final: protos={pc4}, edges={ec4}, transitions={tc4}")
if pc4 == 2.0 && tc4 == 1.0
  print("PASS spike: proto=2, transitions=1 (exactly as expected)")
elif pc4 == 2.0
  print("PASS spike: proto=2 correct, transitions={tc4} (expected 1)")
else
  print("FAIL spike: expected proto=2 trans=1, got proto={pc4} trans={tc4}")
end
print("")

print("--- adversarial benchmark complete ---")
