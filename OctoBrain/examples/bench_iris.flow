// OctoBrain Iris Classification Benchmark
// First real ML accuracy test: Fisher's Iris dataset.
// 150 samples x 4 features x 3 classes (setosa=0, versicolor=1, virginica=2).
// The brain should discover 3-5 prototypes corresponding to the 3 species.
//
// Key: zero-centering is mandatory for positive-only features.
// Without centering, all-positive features produce cosine similarity ~1.0
// after normalization, collapsing everything to 1 prototype.
//
// Run:
//   powershell.exe -NoProfile -ExecutionPolicy Bypass -File "C:\OctoFlow\run_test.ps1" run --bin octoflow -- run "C:\OctoFlow\OctoBrain\examples\bench_iris.flow" --allow-read

use "../lib/octobrain"
use "../lib/benchmark"

print("=== OctoBrain Iris Classification Benchmark ===")
print("")

// ── Step 1: Load data via read_csv ──────────────────────────────────
let rows = read_csv("OctoBrain/data/iris.csv")
let num_rows = len(rows)
print("Loaded {num_rows} rows from iris.csv")

// ── Step 2: Extract features [150 x 4] flat and labels [150] ────────
let mut data_flat = []
let mut labels = []

for row in rows
  let sl = float(row["sepal_length"])
  let sw = float(row["sepal_width"])
  let pl = float(row["petal_length"])
  let pw = float(row["petal_width"])
  let cls = float(row["class"])

  push(data_flat, sl)
  push(data_flat, sw)
  push(data_flat, pl)
  push(data_flat, pw)
  push(labels, cls)
end

let n_features = len(data_flat)
let n_labels = len(labels)
print("Features: {n_features} values (150 x 4 = 600)")
print("Labels: {n_labels}")
print("")

// ── Step 3: Compute means and center data ───────────────────────────
let num_samples = 150.0
let dim = 4.0

let means = compute_means(data_flat, num_samples, dim)
let m0 = means[0]
let m1 = means[1]
let m2 = means[2]
let m3 = means[3]
print("Feature means: [{m0:.3}, {m1:.3}, {m2:.3}, {m3:.3}]")

let centered = center_data(data_flat, means, num_samples, dim)
print("Data centered (zero-mean per feature)")
print("")

// ── Step 4: Create brain and feed observations ──────────────────────
let mut brain = octobrain_new(3.0)
let mut p_state = proto_new()
let mut p_embs = []
let mut p_mc = []
let mut e_state = embed_new()
let mut W_embed = []
let mut obs_buffer = []
let mut edge_state = edges_new()
let mut en = []
let mut ea = []
let mut eo = []
let mut ep = []
let mut ew = []
let mut eact = []
let mut window = []
let mut W_score = []

let mut match_protos = []

// Feed all 150 centered samples
let mut i = 0.0
while i < num_samples
  // Extract 4-feature vector for this sample
  let base = i * dim
  let mut sample = []
  push(sample, centered[base + 0.0])
  push(sample, centered[base + 1.0])
  push(sample, centered[base + 2.0])
  push(sample, centered[base + 3.0])

  let dummy = octobrain_observe(brain, p_state, p_embs, p_mc, e_state, W_embed, obs_buffer, edge_state, en, ea, eo, ep, ew, eact, window, W_score, sample)

  // Record which prototype matched this sample
  let last_proto = map_get(p_state, "last_match_id")
  push(match_protos, last_proto)

  i = i + 1.0
end

print("Fed 150 observations to brain")
print("")

// ── Step 5: Get stats ───────────────────────────────────────────────
let stats = octobrain_stats(brain, p_state, edge_state)
let proto_count = map_get(stats, "proto_count")
let edge_count = map_get(stats, "edge_count")
let transition_count = map_get(stats, "transition_count")
let obs_count = map_get(stats, "obs_count")

print("Brain stats:")
print("  Prototypes: {proto_count}")
print("  Edges: {edge_count}")
print("  Transitions: {transition_count}")
print("  Observations: {obs_count}")
print("")

// ── Step 6: Build mapping and compute accuracy ──────────────────────
let num_classes = 3.0
let mapping = build_mapping(match_protos, labels, proto_count, num_classes)

// Print the mapping
print("Proto -> Class mapping:")
let mut mi = 0.0
while mi < proto_count
  let mapped_class = mapping[mi]
  let mc_int = int(mapped_class)
  let mi_int = int(mi)
  print("  Proto {mi_int} -> Class {mc_int}")
  mi = mi + 1.0
end
print("")

let acc = compute_accuracy(match_protos, labels, mapping, num_samples)
print("Accuracy: {acc:.4}")
print("")

// ── Step 7: Confusion matrix ────────────────────────────────────────
print("Confusion Matrix:")
let dummy_cm = print_confusion(match_protos, labels, mapping, num_samples, num_classes)
print("")

// ── Step 8: Per-prototype purity ────────────────────────────────────
print("Prototype Purity:")
let dummy_pp = print_purity(match_protos, labels, proto_count, num_classes, num_samples)
print("")

// ── Step 9: PASS/FAIL criteria ──────────────────────────────────────
print("=== Results ===")

// Proto count check: 2-10
if proto_count >= 2.0 && proto_count <= 10.0
  print("PASS proto_count: {proto_count} (in range 2-10)")
else
  print("FAIL proto_count: {proto_count} (expected 2-10)")
end

// Accuracy check: >= 0.80
if acc >= 0.80
  print("PASS accuracy: {acc:.4} >= 0.80")
else
  print("FAIL accuracy: {acc:.4} < 0.80")
end

print("")
print("--- iris benchmark complete ---")
