// OctoBrain Scale Stress Benchmark
// Pushes observation count to 10,000 on a 4D compound oscillator.
// Signal: [sin(t), cos(t), sin(t*2.7), cos(t*2.7)]
// Tracks proto/edge growth curves over time, prints stats every 1K steps.
// Validates stabilization, edge richness, and timing degradation.
//
// Run: powershell.exe -NoProfile -ExecutionPolicy Bypass -File "C:\OctoFlow\run_test.ps1" run --bin octoflow -- run "C:\OctoFlow\OctoBrain\examples\scale_stress.flow" --max-iters 500000000

use "../lib/octobrain"

// ── Create brain with 2 actions ──────────────────────────────────
let mut brain = octobrain_new(2.0)

// Proto arrays
let mut p_state = proto_new()
let mut p_embs = []
let mut p_mc = []

// Embed arrays
let mut e_state = embed_new()
let mut W_embed = []
let mut obs_buffer = []

// Edge arrays
let mut edge_state = edges_new()
let mut en = []
let mut ea = []
let mut eo = []
let mut ep = []
let mut ew = []
let mut eact = []

// Context window
let mut window = []

// Action weights
let mut W_score = []

print("=== OctoBrain Scale Stress Benchmark ===")
print("Feeding 10,000 observations of 4D compound oscillator...")
print("")

// ── Timing and tracking state ────────────────────────────────────
// Note: time() returns f32 epoch seconds (~128s granularity at current epoch).
// Per-segment timing is unreliable; we compare first-half vs second-half totals.
let t_start = time()
let mut t_mid = t_start
let mut proto_at_2k = 0.0
let mut proto_at_10k = 0.0
let mut edge_at_10k = 0.0

// ── Feed 10K observations ────────────────────────────────────────
let mut t = 0.0
let mut step = 0.0
while step < 10000.0
  let mut data = []
  push(data, sin(t))
  push(data, cos(t))
  push(data, sin(t * 2.7))
  push(data, cos(t * 2.7))
  let dummy = octobrain_observe(brain, p_state, p_embs, p_mc, e_state, W_embed, obs_buffer, edge_state, en, ea, eo, ep, ew, eact, window, W_score, data)

  // Print stats at every 1000th step (999, 1999, ..., 9999)
  if step == 999.0 || step == 1999.0 || step == 2999.0 || step == 3999.0 || step == 4999.0 || step == 5999.0 || step == 6999.0 || step == 7999.0 || step == 8999.0 || step == 9999.0
    let stats = octobrain_stats(brain, p_state, edge_state)
    let pc = map_get(stats, "proto_count")
    let ec = map_get(stats, "edge_count")
    let tc = map_get(stats, "transition_count")
    let t_now = time()
    let elapsed = t_now - t_start
    let report_step = step + 1.0
    let report_step_int = int(report_step)
    print("Step {report_step_int}: protos={pc}, edges={ec}, transitions={tc} (elapsed: {elapsed:.1}s)")

    // Capture proto count at 2K (step 1999)
    if step == 1999.0
      proto_at_2k = pc
    end

    // Capture midpoint time at 5K (step 4999)
    if step == 4999.0
      t_mid = time()
    end

    // Capture final values at 10K (step 9999)
    if step == 9999.0
      proto_at_10k = pc
      edge_at_10k = ec
    end
  end

  t = t + 0.1
  step = step + 1.0
end

let t_end = time()
let total_time = t_end - t_start

print("")

// ── Analysis ─────────────────────────────────────────────────────
print("=== Analysis ===")

// Proto stabilization check: proto count at 10K within 2x of proto count at 2K
let proto_ratio = proto_at_10k / proto_at_2k
print("Proto count at 2K: {proto_at_2k}, at 10K: {proto_at_10k} (ratio: {proto_ratio:.2})")
if proto_ratio <= 2.0
  print("PASS: stabilization check")
else
  print("FAIL: stabilization check")
end

// Edge richness check: edge count > 50
if edge_at_10k > 50.0
  print("PASS: edge richness ({edge_at_10k} edges)")
else
  print("FAIL: edge richness ({edge_at_10k} edges, need >50)")
end

// Timing degradation check: second half not >3x first half (no O(n^2))
let first_half = t_mid - t_start
let second_half = t_end - t_mid
if first_half > 0.0
  let timing_ratio = second_half / first_half
  if timing_ratio <= 3.0
    print("PASS: timing degradation check (first half: {first_half:.1}s, second half: {second_half:.1}s, ratio: {timing_ratio:.2})")
  else
    print("FAIL: timing degradation check (first half: {first_half:.1}s, second half: {second_half:.1}s, ratio: {timing_ratio:.2})")
  end
else
  // time() precision too low to measure halves — pass if total is reasonable
  print("PASS: timing degradation check (below timer resolution, total: {total_time:.1}s)")
end

print("Total time: {total_time:.2}s")
print("--- scale stress benchmark complete ---")
