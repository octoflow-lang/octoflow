// OctoBrain Multi-Step Prediction Benchmark
// Tests whether the brain can predict N steps ahead by chaining Markov transitions.
// Measures prediction horizon â€” how far into the future can we accurately predict?
//
// Three sub-tests, each with a fresh brain:
//   A. Sine wave, 1-5 step lookahead (600 obs: 500 train + 100 test, window=4)
//   B. ABCABC deterministic cycle, 1-6 step lookahead (300 obs)
//   C. Regime change (ABAB -> ABCABC), 1-3 step lookahead (400 obs)
//
// PASS/FAIL criteria:
//   Test A step-1 >= 0.80
//   Test A step-3 >= 0.50
//   Test B step-1 >= 0.95
//   Test B step-6 >= 0.90
//   Test C step-1 >= 0.80
//
// Run: powershell.exe -NoProfile -ExecutionPolicy Bypass -File "C:\OctoFlow\run_test.ps1" run --bin octoflow -- run "C:\OctoFlow\OctoBrain\examples\bench_multistep.flow" --max-iters 20000000

use "../lib/octobrain"
use "../lib/sequence"

print("=== OctoBrain Multi-Step Prediction Benchmark ===")
print("")

// =====================================================================
// Sub-test A: Sine Wave, 1-5 Step Lookahead (600 observations)
// Signal: sin(t * 0.5), window size 4 (period ~12.57 -> ~8 protos per cycle)
// Train: first 500 windows -> build second-order Markov table
// Test: remaining 100 windows -> predict 1-5 steps ahead
// =====================================================================
print("--- Sub-test A: Sine Wave Multi-Step (600 obs, window=4) ---")

// Create brain A
let mut brainA = octobrain_new(2.0)
let mut p_stateA = proto_new()
let mut p_embsA = []
let mut p_mcA = []
let mut e_stateA = embed_new()
let mut W_embedA = []
let mut obs_bufferA = []
let mut edge_stateA = edges_new()
let mut enA = []
let mut eaA = []
let mut eoA = []
let mut epA = []
let mut ewA = []
let mut eactA = []
let mut windowA = []
let mut W_scoreA = []

// Generate sine wave signal: sin(t * 0.5) for t = 0,1,...,603
// Period ~12.57 steps, window size 4 -> ~8 prototypes per cycle
// We need 600 windows of size 4, so 603 data points (500 train + 100 test)
let sine_count = 604.0
let mut sine_data = []
let mut si = 0.0
while si < sine_count
  push(sine_data, sin(si * 0.5))
  si = si + 1.0
end
print("Generated {sine_count:.0} sine wave samples")

// Training: feed first 500 windows, record proto sequence
let train_countA = 500.0
let mut proto_seqA = []
let mut wi = 0.0
while wi < train_countA
  // Build window [sine_data[wi], sine_data[wi+1], sine_data[wi+2], sine_data[wi+3]]
  let mut data = []
  push(data, sine_data[wi])
  push(data, sine_data[wi + 1.0])
  push(data, sine_data[wi + 2.0])
  push(data, sine_data[wi + 3.0])
  let _obs = octobrain_observe(brainA, p_stateA, p_embsA, p_mcA, e_stateA, W_embedA, obs_bufferA, edge_stateA, enA, eaA, eoA, epA, ewA, eactA, windowA, W_scoreA, data)
  let pid = map_get(p_stateA, "last_match_id")
  push(proto_seqA, pid)
  wi = wi + 1.0
end

let statsA = octobrain_stats(brainA, p_stateA, edge_stateA)
let pcA = map_get(statsA, "proto_count")
let tcA = map_get(statsA, "transition_count")
print("Training complete: protos={pcA}, transitions={tcA}")

// Build second-order Markov table from training proto sequence
let seqlenA = len(proto_seqA)
let tableA = markov2_build(proto_seqA, seqlenA, pcA)
print("Built second-order Markov table (size={pcA}^3)")

// Test: feed windows 500..600 (100 windows), predict 1-5 steps ahead
// For N-step test from position i, we need actual protos at i+1..i+N
// So we first feed all test windows and record their proto IDs
let max_horizon_A = 5.0
let test_startA = train_countA
let test_endA = 600.0
let mut test_proto_seqA = []

let mut ti = test_startA
while ti < test_endA
  let mut tdata = []
  push(tdata, sine_data[ti])
  push(tdata, sine_data[ti + 1.0])
  push(tdata, sine_data[ti + 2.0])
  push(tdata, sine_data[ti + 3.0])
  let _tobs = octobrain_observe(brainA, p_stateA, p_embsA, p_mcA, e_stateA, W_embedA, obs_bufferA, edge_stateA, enA, eaA, eoA, epA, ewA, eactA, windowA, W_scoreA, tdata)
  let tpid = map_get(p_stateA, "last_match_id")
  push(test_proto_seqA, tpid)
  ti = ti + 1.0
end

let test_lenA = len(test_proto_seqA)
print("Test protos recorded: {test_lenA:.0}")

// Evaluate multi-step prediction accuracy at each horizon (1-5)
// For each test position i (starting at 2 so we have second-order context),
// build context from the combined proto sequence, predict N steps, compare
// We need context from training + test sequence. Build full sequence for context.
let mut full_seqA = []
let mut fsi = 0.0
while fsi < seqlenA
  push(full_seqA, proto_seqA[fsi])
  fsi = fsi + 1.0
end
let mut fsi2 = 0.0
while fsi2 < test_lenA
  push(full_seqA, test_proto_seqA[fsi2])
  fsi2 = fsi2 + 1.0
end

// Accuracy counters for horizons 1-5
let mut correct_A1 = 0.0
let mut correct_A2 = 0.0
let mut correct_A3 = 0.0
let mut correct_A4 = 0.0
let mut correct_A5 = 0.0
let mut total_A1 = 0.0
let mut total_A2 = 0.0
let mut total_A3 = 0.0
let mut total_A4 = 0.0
let mut total_A5 = 0.0

// Test positions: i ranges over test_proto_seqA
// For position i in test_proto_seqA, absolute position in full_seqA is seqlenA + i
// Context: full_seqA[seqlenA + i - 2] and full_seqA[seqlenA + i - 1]
// Actual at horizon h: test_proto_seqA[i + h] (if i + h < test_lenA)
let mut evalA = 0.0
while evalA < test_lenA
  let abs_pos = seqlenA + evalA
  if abs_pos >= 2.0
    let prev_p = full_seqA[abs_pos - 2.0]
    let curr_p = full_seqA[abs_pos - 1.0]
    // Build context array for predict_n_steps
    let mut ctxA = []
    push(ctxA, prev_p)
    push(ctxA, curr_p)
    let preds = predict_n_steps(tableA, 2.0, ctxA, pcA, max_horizon_A)
    // Compare each horizon
    // Horizon 1: predicted[0] vs test_proto_seqA[evalA]
    if evalA < test_lenA
      let actual_h1 = test_proto_seqA[evalA]
      if preds[0] == actual_h1
        correct_A1 = correct_A1 + 1.0
      end
      total_A1 = total_A1 + 1.0
    end
    // Horizon 2: predicted[1] vs test_proto_seqA[evalA + 1]
    if evalA + 1.0 < test_lenA
      let actual_h2 = test_proto_seqA[evalA + 1.0]
      if preds[1] == actual_h2
        correct_A2 = correct_A2 + 1.0
      end
      total_A2 = total_A2 + 1.0
    end
    // Horizon 3: predicted[2] vs test_proto_seqA[evalA + 2]
    if evalA + 2.0 < test_lenA
      let actual_h3 = test_proto_seqA[evalA + 2.0]
      if preds[2] == actual_h3
        correct_A3 = correct_A3 + 1.0
      end
      total_A3 = total_A3 + 1.0
    end
    // Horizon 4: predicted[3] vs test_proto_seqA[evalA + 3]
    if evalA + 3.0 < test_lenA
      let actual_h4 = test_proto_seqA[evalA + 3.0]
      if preds[3] == actual_h4
        correct_A4 = correct_A4 + 1.0
      end
      total_A4 = total_A4 + 1.0
    end
    // Horizon 5: predicted[4] vs test_proto_seqA[evalA + 4]
    if evalA + 4.0 < test_lenA
      let actual_h5 = test_proto_seqA[evalA + 4.0]
      if preds[4] == actual_h5
        correct_A5 = correct_A5 + 1.0
      end
      total_A5 = total_A5 + 1.0
    end
  end
  evalA = evalA + 1.0
end

// Print accuracy table for Test A
let accA1 = correct_A1 / total_A1
let accA2 = correct_A2 / total_A2
let accA3 = correct_A3 / total_A3
let accA4 = correct_A4 / total_A4
let accA5 = correct_A5 / total_A5
let pctA1 = floor(accA1 * 1000.0) / 10.0
let pctA2 = floor(accA2 * 1000.0) / 10.0
let pctA3 = floor(accA3 * 1000.0) / 10.0
let pctA4 = floor(accA4 * 1000.0) / 10.0
let pctA5 = floor(accA5 * 1000.0) / 10.0
print("")
print("  Horizon | Correct/Total | Accuracy")
print("  --------|---------------|--------")
print("  step-1  | {correct_A1:.0}/{total_A1:.0}       | {pctA1}%")
print("  step-2  | {correct_A2:.0}/{total_A2:.0}       | {pctA2}%")
print("  step-3  | {correct_A3:.0}/{total_A3:.0}       | {pctA3}%")
print("  step-4  | {correct_A4:.0}/{total_A4:.0}       | {pctA4}%")
print("  step-5  | {correct_A5:.0}/{total_A5:.0}       | {pctA5}%")

if accA1 >= 0.80
  print("PASS A-step1: {pctA1}% >= 80%")
else
  print("FAIL A-step1: {pctA1}% < 80%")
end
if accA3 >= 0.50
  print("PASS A-step3: {pctA3}% >= 50%")
else
  print("FAIL A-step3: {pctA3}% < 50%")
end
print("")

// =====================================================================
// Sub-test B: ABCABC Deterministic Cycle, 1-6 Step Lookahead (300 obs)
// Encode: A=[1,0,0], B=[0,1,0], C=[0,0,1]
// Train: first 200 observations
// Test: remaining 100 observations, predict 1-6 steps ahead
// Expected: near 100% at all horizons (deterministic cycle)
// =====================================================================
print("--- Sub-test B: ABCABC Cycle Multi-Step (300 obs) ---")

let mut brainB = octobrain_new(2.0)
let mut p_stateB = proto_new()
let mut p_embsB = []
let mut p_mcB = []
let mut e_stateB = embed_new()
let mut W_embedB = []
let mut obs_bufferB = []
let mut edge_stateB = edges_new()
let mut enB = []
let mut eaB = []
let mut eoB = []
let mut epB = []
let mut ewB = []
let mut eactB = []
let mut windowB = []
let mut W_scoreB = []

// Helper: generate one-hot encoded cycle data
// pos mod 3: 0=A, 1=B, 2=C

// Training phase: 200 observations
let train_countB = 200.0
let mut proto_seqB = []
let mut sb = 0.0
while sb < train_countB
  let mod3 = sb - floor(sb / 3.0) * 3.0
  let mut dataB = []
  if mod3 < 0.5
    push(dataB, 1.0)
    push(dataB, 0.0)
    push(dataB, 0.0)
  elif mod3 < 1.5
    push(dataB, 0.0)
    push(dataB, 1.0)
    push(dataB, 0.0)
  else
    push(dataB, 0.0)
    push(dataB, 0.0)
    push(dataB, 1.0)
  end
  let _obsB = octobrain_observe(brainB, p_stateB, p_embsB, p_mcB, e_stateB, W_embedB, obs_bufferB, edge_stateB, enB, eaB, eoB, epB, ewB, eactB, windowB, W_scoreB, dataB)
  let pidB = map_get(p_stateB, "last_match_id")
  push(proto_seqB, pidB)
  sb = sb + 1.0
end

let statsB = octobrain_stats(brainB, p_stateB, edge_stateB)
let pcB = map_get(statsB, "proto_count")
let tcB = map_get(statsB, "transition_count")
print("Training complete: protos={pcB}, transitions={tcB}")

// Build second-order Markov table from training
let seqlenB = len(proto_seqB)
let tableB = markov2_build(proto_seqB, seqlenB, pcB)
print("Built second-order Markov table")

// Test phase: 100 more observations, record proto IDs
let test_countB = 100.0
let mut test_proto_seqB = []
let mut tb = 0.0
while tb < test_countB
  let posB = train_countB + tb
  let mod3b = posB - floor(posB / 3.0) * 3.0
  let mut tdataB = []
  if mod3b < 0.5
    push(tdataB, 1.0)
    push(tdataB, 0.0)
    push(tdataB, 0.0)
  elif mod3b < 1.5
    push(tdataB, 0.0)
    push(tdataB, 1.0)
    push(tdataB, 0.0)
  else
    push(tdataB, 0.0)
    push(tdataB, 0.0)
    push(tdataB, 1.0)
  end
  let _tobsB = octobrain_observe(brainB, p_stateB, p_embsB, p_mcB, e_stateB, W_embedB, obs_bufferB, edge_stateB, enB, eaB, eoB, epB, ewB, eactB, windowB, W_scoreB, tdataB)
  let tpidB = map_get(p_stateB, "last_match_id")
  push(test_proto_seqB, tpidB)
  tb = tb + 1.0
end

let test_lenB = len(test_proto_seqB)
print("Test protos recorded: {test_lenB:.0}")

// Build full sequence for context
let mut full_seqB = []
let mut fsb = 0.0
while fsb < seqlenB
  push(full_seqB, proto_seqB[fsb])
  fsb = fsb + 1.0
end
let mut fsb2 = 0.0
while fsb2 < test_lenB
  push(full_seqB, test_proto_seqB[fsb2])
  fsb2 = fsb2 + 1.0
end

// Accuracy counters for horizons 1-6
let max_horizon_B = 6.0
let mut correct_B1 = 0.0
let mut correct_B2 = 0.0
let mut correct_B3 = 0.0
let mut correct_B4 = 0.0
let mut correct_B5 = 0.0
let mut correct_B6 = 0.0
let mut total_B1 = 0.0
let mut total_B2 = 0.0
let mut total_B3 = 0.0
let mut total_B4 = 0.0
let mut total_B5 = 0.0
let mut total_B6 = 0.0

let mut evalB = 0.0
while evalB < test_lenB
  let abs_posB = seqlenB + evalB
  if abs_posB >= 2.0
    let prev_pB = full_seqB[abs_posB - 2.0]
    let curr_pB = full_seqB[abs_posB - 1.0]
    let mut ctxB = []
    push(ctxB, prev_pB)
    push(ctxB, curr_pB)
    let predsB = predict_n_steps(tableB, 2.0, ctxB, pcB, max_horizon_B)

    // Horizon 1
    if evalB < test_lenB
      if predsB[0] == test_proto_seqB[evalB]
        correct_B1 = correct_B1 + 1.0
      end
      total_B1 = total_B1 + 1.0
    end
    // Horizon 2
    if evalB + 1.0 < test_lenB
      if predsB[1] == test_proto_seqB[evalB + 1.0]
        correct_B2 = correct_B2 + 1.0
      end
      total_B2 = total_B2 + 1.0
    end
    // Horizon 3
    if evalB + 2.0 < test_lenB
      if predsB[2] == test_proto_seqB[evalB + 2.0]
        correct_B3 = correct_B3 + 1.0
      end
      total_B3 = total_B3 + 1.0
    end
    // Horizon 4
    if evalB + 3.0 < test_lenB
      if predsB[3] == test_proto_seqB[evalB + 3.0]
        correct_B4 = correct_B4 + 1.0
      end
      total_B4 = total_B4 + 1.0
    end
    // Horizon 5
    if evalB + 4.0 < test_lenB
      if predsB[4] == test_proto_seqB[evalB + 4.0]
        correct_B5 = correct_B5 + 1.0
      end
      total_B5 = total_B5 + 1.0
    end
    // Horizon 6
    if evalB + 5.0 < test_lenB
      if predsB[5] == test_proto_seqB[evalB + 5.0]
        correct_B6 = correct_B6 + 1.0
      end
      total_B6 = total_B6 + 1.0
    end
  end
  evalB = evalB + 1.0
end

let accB1 = correct_B1 / total_B1
let accB2 = correct_B2 / total_B2
let accB3 = correct_B3 / total_B3
let accB4 = correct_B4 / total_B4
let accB5 = correct_B5 / total_B5
let accB6 = correct_B6 / total_B6
let pctB1 = floor(accB1 * 1000.0) / 10.0
let pctB2 = floor(accB2 * 1000.0) / 10.0
let pctB3 = floor(accB3 * 1000.0) / 10.0
let pctB4 = floor(accB4 * 1000.0) / 10.0
let pctB5 = floor(accB5 * 1000.0) / 10.0
let pctB6 = floor(accB6 * 1000.0) / 10.0
print("")
print("  Horizon | Correct/Total | Accuracy")
print("  --------|---------------|--------")
print("  step-1  | {correct_B1:.0}/{total_B1:.0}       | {pctB1}%")
print("  step-2  | {correct_B2:.0}/{total_B2:.0}       | {pctB2}%")
print("  step-3  | {correct_B3:.0}/{total_B3:.0}       | {pctB3}%")
print("  step-4  | {correct_B4:.0}/{total_B4:.0}       | {pctB4}%")
print("  step-5  | {correct_B5:.0}/{total_B5:.0}       | {pctB5}%")
print("  step-6  | {correct_B6:.0}/{total_B6:.0}       | {pctB6}%")

if accB1 >= 0.95
  print("PASS B-step1: {pctB1}% >= 95%")
else
  print("FAIL B-step1: {pctB1}% < 95%")
end
if accB6 >= 0.90
  print("PASS B-step6: {pctB6}% >= 90%")
else
  print("FAIL B-step6: {pctB6}% < 90%")
end
print("")

// =====================================================================
// Sub-test C: Regime Change, 1-3 Step Lookahead (400 obs)
// First 200: ABAB pattern, next 200: ABCABC pattern
// Train on full 400, but build Markov table from second regime only
// (last 200 proto IDs)
// Test: 50 new ABCABC observations, predict 1-3 steps ahead
// Expected: >= 85% at step-1 (regime-aware prediction)
// =====================================================================
print("--- Sub-test C: Regime Change Multi-Step (400+50 obs) ---")

let mut brainC = octobrain_new(2.0)
let mut p_stateC = proto_new()
let mut p_embsC = []
let mut p_mcC = []
let mut e_stateC = embed_new()
let mut W_embedC = []
let mut obs_bufferC = []
let mut edge_stateC = edges_new()
let mut enC = []
let mut eaC = []
let mut eoC = []
let mut epC = []
let mut ewC = []
let mut eactC = []
let mut windowC = []
let mut W_scoreC = []

// Phase 1: Feed first 200 ABAB observations
let mut proto_seqC = []
let mut sc = 0.0
while sc < 200.0
  // ABAB: even=A, odd=B
  let half_c = sc / 2.0
  let is_even_c = floor(half_c) * 2.0
  let mut dataC1 = []
  if is_even_c == sc
    push(dataC1, 1.0)
    push(dataC1, 0.0)
    push(dataC1, 0.0)
  else
    push(dataC1, 0.0)
    push(dataC1, 1.0)
    push(dataC1, 0.0)
  end
  let _obsC1 = octobrain_observe(brainC, p_stateC, p_embsC, p_mcC, e_stateC, W_embedC, obs_bufferC, edge_stateC, enC, eaC, eoC, epC, ewC, eactC, windowC, W_scoreC, dataC1)
  let pidC1 = map_get(p_stateC, "last_match_id")
  push(proto_seqC, pidC1)
  sc = sc + 1.0
end

let statsC_mid = octobrain_stats(brainC, p_stateC, edge_stateC)
let pcC_mid = map_get(statsC_mid, "proto_count")
print("After ABAB regime (200 obs): protos={pcC_mid}")

// Phase 2: Feed next 200 ABCABC observations (regime 2)
let regime2_start = len(proto_seqC)
let mut sc2 = 0.0
while sc2 < 200.0
  let mod3c = sc2 - floor(sc2 / 3.0) * 3.0
  let mut dataC2 = []
  if mod3c < 0.5
    push(dataC2, 1.0)
    push(dataC2, 0.0)
    push(dataC2, 0.0)
  elif mod3c < 1.5
    push(dataC2, 0.0)
    push(dataC2, 1.0)
    push(dataC2, 0.0)
  else
    push(dataC2, 0.0)
    push(dataC2, 0.0)
    push(dataC2, 1.0)
  end
  let _obsC2 = octobrain_observe(brainC, p_stateC, p_embsC, p_mcC, e_stateC, W_embedC, obs_bufferC, edge_stateC, enC, eaC, eoC, epC, ewC, eactC, windowC, W_scoreC, dataC2)
  let pidC2 = map_get(p_stateC, "last_match_id")
  push(proto_seqC, pidC2)
  sc2 = sc2 + 1.0
end

let statsC = octobrain_stats(brainC, p_stateC, edge_stateC)
let pcC = map_get(statsC, "proto_count")
let tcC = map_get(statsC, "transition_count")
print("After full training (400 obs): protos={pcC}, transitions={tcC}")

// Build second-order Markov table from SECOND REGIME ONLY (last 200 proto IDs)
let full_lenC = len(proto_seqC)
let regime2_len = 200.0
let mut regime2_seq = []
let mut r2i = 0.0
while r2i < regime2_len
  let r2_idx = regime2_start + r2i
  push(regime2_seq, proto_seqC[r2_idx])
  r2i = r2i + 1.0
end

let tableC = markov2_build(regime2_seq, regime2_len, pcC)
print("Built Markov table from regime 2 only ({regime2_len:.0} protos)")

// Test phase: 50 new ABCABC observations, continuing the cycle
let test_countC = 50.0
let mut test_proto_seqC = []
let mut tc = 0.0
while tc < test_countC
  // Continue ABCABC from where regime 2 left off (position 200+tc in cycle)
  let posC = 200.0 + tc
  let mod3tc = posC - floor(posC / 3.0) * 3.0
  let mut tdataC = []
  if mod3tc < 0.5
    push(tdataC, 1.0)
    push(tdataC, 0.0)
    push(tdataC, 0.0)
  elif mod3tc < 1.5
    push(tdataC, 0.0)
    push(tdataC, 1.0)
    push(tdataC, 0.0)
  else
    push(tdataC, 0.0)
    push(tdataC, 0.0)
    push(tdataC, 1.0)
  end
  let _tobsC = octobrain_observe(brainC, p_stateC, p_embsC, p_mcC, e_stateC, W_embedC, obs_bufferC, edge_stateC, enC, eaC, eoC, epC, ewC, eactC, windowC, W_scoreC, tdataC)
  let tpidC = map_get(p_stateC, "last_match_id")
  push(test_proto_seqC, tpidC)
  tc = tc + 1.0
end

let test_lenC = len(test_proto_seqC)
print("Test protos recorded: {test_lenC:.0}")

// Build full sequence for context (training + test)
let mut full_seqC = []
let mut fsc = 0.0
while fsc < full_lenC
  push(full_seqC, proto_seqC[fsc])
  fsc = fsc + 1.0
end
let mut fsc2 = 0.0
while fsc2 < test_lenC
  push(full_seqC, test_proto_seqC[fsc2])
  fsc2 = fsc2 + 1.0
end

// Accuracy counters for horizons 1-3
let max_horizon_C = 3.0
let mut correct_C1 = 0.0
let mut correct_C2 = 0.0
let mut correct_C3 = 0.0
let mut total_C1 = 0.0
let mut total_C2 = 0.0
let mut total_C3 = 0.0

let mut evalC = 0.0
while evalC < test_lenC
  let abs_posC = full_lenC + evalC
  if abs_posC >= 2.0
    let prev_pC = full_seqC[abs_posC - 2.0]
    let curr_pC = full_seqC[abs_posC - 1.0]
    let mut ctxC = []
    push(ctxC, prev_pC)
    push(ctxC, curr_pC)
    let predsC = predict_n_steps(tableC, 2.0, ctxC, pcC, max_horizon_C)

    // Horizon 1
    if evalC < test_lenC
      if predsC[0] == test_proto_seqC[evalC]
        correct_C1 = correct_C1 + 1.0
      end
      total_C1 = total_C1 + 1.0
    end
    // Horizon 2
    if evalC + 1.0 < test_lenC
      if predsC[1] == test_proto_seqC[evalC + 1.0]
        correct_C2 = correct_C2 + 1.0
      end
      total_C2 = total_C2 + 1.0
    end
    // Horizon 3
    if evalC + 2.0 < test_lenC
      if predsC[2] == test_proto_seqC[evalC + 2.0]
        correct_C3 = correct_C3 + 1.0
      end
      total_C3 = total_C3 + 1.0
    end
  end
  evalC = evalC + 1.0
end

let accC1 = correct_C1 / total_C1
let accC2 = correct_C2 / total_C2
let accC3 = correct_C3 / total_C3
let pctC1 = floor(accC1 * 1000.0) / 10.0
let pctC2 = floor(accC2 * 1000.0) / 10.0
let pctC3 = floor(accC3 * 1000.0) / 10.0
print("")
print("  Horizon | Correct/Total | Accuracy")
print("  --------|---------------|--------")
print("  step-1  | {correct_C1:.0}/{total_C1:.0}       | {pctC1}%")
print("  step-2  | {correct_C2:.0}/{total_C2:.0}       | {pctC2}%")
print("  step-3  | {correct_C3:.0}/{total_C3:.0}       | {pctC3}%")

if accC1 >= 0.80
  print("PASS C-step1: {pctC1}% >= 80%")
else
  print("FAIL C-step1: {pctC1}% < 80%")
end
print("")

// =====================================================================
// Summary
// =====================================================================
print("=== Multi-Step Prediction Benchmark Summary ===")
print("")
print("Test A (Sine wave):")
print("  step-1: {pctA1}% (threshold: 80%)  step-3: {pctA3}% (threshold: 50%)")
print("Test B (ABCABC cycle):")
print("  step-1: {pctB1}% (threshold: 95%)  step-6: {pctB6}% (threshold: 90%)")
print("Test C (Regime change):")
print("  step-1: {pctC1}% (threshold: 80%)")
print("")

let mut pass_total = 0.0
let mut fail_total = 0.0
if accA1 >= 0.80
  pass_total = pass_total + 1.0
else
  fail_total = fail_total + 1.0
end
if accA3 >= 0.50
  pass_total = pass_total + 1.0
else
  fail_total = fail_total + 1.0
end
if accB1 >= 0.95
  pass_total = pass_total + 1.0
else
  fail_total = fail_total + 1.0
end
if accB6 >= 0.90
  pass_total = pass_total + 1.0
else
  fail_total = fail_total + 1.0
end
if accC1 >= 0.80
  pass_total = pass_total + 1.0
else
  fail_total = fail_total + 1.0
end

print("Result: {pass_total:.0}/5 criteria passed, {fail_total:.0}/5 failed")
print("")
print("--- multi-step prediction benchmark complete ---")
