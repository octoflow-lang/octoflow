// OctoBrain Extended N-Gram NLP Benchmark
// Does more character context improve NLP transition prediction?
// Tests N-gram sizes 3, 4, 5, 6 on the same English text corpus.
//
// Training: "the quick brown fox jumps over the lazy dog " x20 (~900 chars)
// Test:     "the cat sat on the mat the dog ran " x10 (~350 chars)
//
// Uses auto_center from preprocess.flow instead of manual mean computation.
//
// PASS/FAIL criteria:
//   - N=4 accuracy > N=3 accuracy (longer context helps)
//   - N=5 accuracy >= 0.60 (not worse than trigrams)
//   - All N-gram sizes have proto_count <= 30
//   - Best N-gram accuracy >= 0.70
//
// Run: powershell.exe -NoProfile -ExecutionPolicy Bypass -File "C:\OctoFlow\run_test.ps1" run --bin octoflow -- run "C:\OctoFlow\OctoBrain\examples\bench_nlp_ngram.flow"

use "../lib/octobrain"
use "../lib/text"
use "../lib/preprocess"
use "../lib/proto"

print("=== OctoBrain Extended N-Gram NLP Benchmark ===")
print("")

// ── Build training text ────────────────────────────────────────
let train_base = "the quick brown fox jumps over the lazy dog "
let mut train_text = ""
let mut rep = 0.0
while rep < 20.0
  train_text = train_text + train_base
  rep = rep + 1.0
end
let train_len = len(train_text)
let train_len_int = int(train_len)
print("Training: '{train_base}' x20 = {train_len_int} chars")

// ── Build test text ────────────────────────────────────────────
let test_base = "the cat sat on the mat the dog ran "
let mut test_text = ""
let mut rep2 = 0.0
while rep2 < 10.0
  test_text = test_text + test_base
  rep2 = rep2 + 1.0
end
let test_len = len(test_text)
let test_len_int = int(test_len)
print("Test: '{test_base}' x10 = {test_len_int} chars")
print("")

// ── Convert to codes once ──────────────────────────────────────
let train_codes = text_to_codes(train_text)
let test_codes = text_to_codes(test_text)
let train_codes_len = len(train_codes)
let test_codes_len = len(test_codes)

// ── Storage for results ────────────────────────────────────────
// Store results in flat arrays: [accuracy_3, accuracy_4, accuracy_5, accuracy_6]
let mut accuracies = []
let mut proto_counts = []
let mut new_proto_counts = []

// ══════════════════════════════════════════════════════════════
// N=3 test
// ══════════════════════════════════════════════════════════════

print("--- N=3 (trigram) ---")

let mut brain3 = octobrain_new(2.0)
let mut ps3 = proto_new()
let mut pe3 = []
let mut pm3 = []
let mut es3 = embed_new()
let mut we3 = []
let mut ob3 = []
let mut eds3 = edges_new()
let mut en3 = []
let mut ea3 = []
let mut eo3 = []
let mut ep3 = []
let mut ew3 = []
let mut eact3 = []
let mut win3 = []
let mut ws3 = []

// Auto-centering state
let mut cm3 = []
let mut cc3 = [0.0]

let gram_size_3 = 3.0
let train_max_3 = train_codes_len - gram_size_3 + 1.0

// Training pass — record proto sequence
let mut tseq3 = []
let mut pos3 = 0.0
while pos3 < train_max_3
  let raw3 = text_ngram(train_codes, pos3, gram_size_3)
  let centered3 = auto_center(raw3, cm3, cc3)
  let d3 = octobrain_observe(brain3, ps3, pe3, pm3, es3, we3, ob3, eds3, en3, ea3, eo3, ep3, ew3, eact3, win3, ws3, centered3)
  let pid3 = map_get(ps3, "last_match_id")
  push(tseq3, pid3)
  pos3 = pos3 + 1.0
end

let train_pc3 = map_get(ps3, "proto_count")
let train_pc3_int = int(train_pc3)
print("  Training protos: {train_pc3_int}")

// Build Markov table
let mut trans3 = []
let ts3 = train_pc3 * train_pc3
let mut ti3 = 0.0
while ti3 < ts3
  push(trans3, 0.0)
  ti3 = ti3 + 1.0
end
let sl3 = len(tseq3)
let mut si3 = 1.0
while si3 < sl3
  let f3 = tseq3[si3 - 1.0]
  let t3 = tseq3[si3]
  let idx3 = f3 * train_pc3 + t3
  trans3[idx3] = trans3[idx3] + 1.0
  si3 = si3 + 1.0
end

// Test pass
let pre_pc3 = map_get(ps3, "proto_count")
let test_max_3 = test_codes_len - gram_size_3 + 1.0
let mut correct3 = 0.0
let mut total3 = 0.0
let mut tp3 = 0.0
while tp3 < test_max_3
  let traw3 = text_ngram(test_codes, tp3, gram_size_3)
  let tcen3 = auto_center(traw3, cm3, cc3)

  if tp3 > 0.0
    let cur3 = map_get(ps3, "last_match_id")
    let mut bn3 = 0.0
    let mut bc3 = -1.0
    let mut cj3 = 0.0
    while cj3 < train_pc3
      let ci3 = cur3 * train_pc3 + cj3
      if ci3 < ts3
        if trans3[ci3] > bc3
          bc3 = trans3[ci3]
          bn3 = cj3
        end
      end
      cj3 = cj3 + 1.0
    end
    let dt3 = octobrain_observe(brain3, ps3, pe3, pm3, es3, we3, ob3, eds3, en3, ea3, eo3, ep3, ew3, eact3, win3, ws3, tcen3)
    let act3 = map_get(ps3, "last_match_id")
    if bn3 == act3
      correct3 = correct3 + 1.0
    end
    total3 = total3 + 1.0
  else
    let dt3f = octobrain_observe(brain3, ps3, pe3, pm3, es3, we3, ob3, eds3, en3, ea3, eo3, ep3, ew3, eact3, win3, ws3, tcen3)
  end
  tp3 = tp3 + 1.0
end

let acc3 = correct3 / total3
let pct3 = floor(acc3 * 1000.0) / 10.0
let post_pc3 = map_get(ps3, "proto_count")
let new_p3 = post_pc3 - pre_pc3
let new_p3_int = int(new_p3)
push(accuracies, acc3)
push(proto_counts, train_pc3)
push(new_proto_counts, new_p3)
print("  Accuracy: {pct3}%, New test protos: {new_p3_int}")

// ══════════════════════════════════════════════════════════════
// N=4 test
// ══════════════════════════════════════════════════════════════

print("--- N=4 (4-gram) ---")

let mut brain4 = octobrain_new(2.0)
let mut ps4 = proto_new()
let mut pe4 = []
let mut pm4 = []
let mut es4 = embed_new()
let mut we4 = []
let mut ob4 = []
let mut eds4 = edges_new()
let mut en4 = []
let mut ea4 = []
let mut eo4 = []
let mut ep4 = []
let mut ew4 = []
let mut eact4 = []
let mut win4 = []
let mut ws4 = []
let mut cm4 = []
let mut cc4 = [0.0]

let gram_size_4 = 4.0
let train_max_4 = train_codes_len - gram_size_4 + 1.0

let mut tseq4 = []
let mut pos4 = 0.0
while pos4 < train_max_4
  let raw4 = text_ngram(train_codes, pos4, gram_size_4)
  let centered4 = auto_center(raw4, cm4, cc4)
  let d4 = octobrain_observe(brain4, ps4, pe4, pm4, es4, we4, ob4, eds4, en4, ea4, eo4, ep4, ew4, eact4, win4, ws4, centered4)
  let pid4 = map_get(ps4, "last_match_id")
  push(tseq4, pid4)
  pos4 = pos4 + 1.0
end

let train_pc4 = map_get(ps4, "proto_count")
let train_pc4_int = int(train_pc4)
print("  Training protos: {train_pc4_int}")

let mut trans4 = []
let ts4 = train_pc4 * train_pc4
let mut ti4 = 0.0
while ti4 < ts4
  push(trans4, 0.0)
  ti4 = ti4 + 1.0
end
let sl4 = len(tseq4)
let mut si4 = 1.0
while si4 < sl4
  let f4 = tseq4[si4 - 1.0]
  let t4 = tseq4[si4]
  let idx4 = f4 * train_pc4 + t4
  trans4[idx4] = trans4[idx4] + 1.0
  si4 = si4 + 1.0
end

let pre_pc4 = map_get(ps4, "proto_count")
let test_max_4 = test_codes_len - gram_size_4 + 1.0
let mut correct4 = 0.0
let mut total4 = 0.0
let mut tp4 = 0.0
while tp4 < test_max_4
  let traw4 = text_ngram(test_codes, tp4, gram_size_4)
  let tcen4 = auto_center(traw4, cm4, cc4)

  if tp4 > 0.0
    let cur4 = map_get(ps4, "last_match_id")
    let mut bn4 = 0.0
    let mut bc4 = -1.0
    let mut cj4 = 0.0
    while cj4 < train_pc4
      let ci4 = cur4 * train_pc4 + cj4
      if ci4 < ts4
        if trans4[ci4] > bc4
          bc4 = trans4[ci4]
          bn4 = cj4
        end
      end
      cj4 = cj4 + 1.0
    end
    let dt4 = octobrain_observe(brain4, ps4, pe4, pm4, es4, we4, ob4, eds4, en4, ea4, eo4, ep4, ew4, eact4, win4, ws4, tcen4)
    let act4 = map_get(ps4, "last_match_id")
    if bn4 == act4
      correct4 = correct4 + 1.0
    end
    total4 = total4 + 1.0
  else
    let dt4f = octobrain_observe(brain4, ps4, pe4, pm4, es4, we4, ob4, eds4, en4, ea4, eo4, ep4, ew4, eact4, win4, ws4, tcen4)
  end
  tp4 = tp4 + 1.0
end

let acc4 = correct4 / total4
let pct4 = floor(acc4 * 1000.0) / 10.0
let post_pc4 = map_get(ps4, "proto_count")
let new_p4 = post_pc4 - pre_pc4
let new_p4_int = int(new_p4)
push(accuracies, acc4)
push(proto_counts, train_pc4)
push(new_proto_counts, new_p4)
print("  Accuracy: {pct4}%, New test protos: {new_p4_int}")

// ══════════════════════════════════════════════════════════════
// N=5 test
// ══════════════════════════════════════════════════════════════

print("--- N=5 (5-gram) ---")

let mut brain5 = octobrain_new(2.0)
let mut ps5 = proto_new()
let mut pe5 = []
let mut pm5 = []
let mut es5 = embed_new()
let mut we5 = []
let mut ob5 = []
let mut eds5 = edges_new()
let mut en5 = []
let mut ea5 = []
let mut eo5 = []
let mut ep5 = []
let mut ew5 = []
let mut eact5 = []
let mut win5 = []
let mut ws5 = []
let mut cm5 = []
let mut cc5 = [0.0]

let gram_size_5 = 5.0
let train_max_5 = train_codes_len - gram_size_5 + 1.0

let mut tseq5 = []
let mut pos5 = 0.0
while pos5 < train_max_5
  let raw5 = text_ngram(train_codes, pos5, gram_size_5)
  let centered5 = auto_center(raw5, cm5, cc5)
  let d5 = octobrain_observe(brain5, ps5, pe5, pm5, es5, we5, ob5, eds5, en5, ea5, eo5, ep5, ew5, eact5, win5, ws5, centered5)
  let pid5 = map_get(ps5, "last_match_id")
  push(tseq5, pid5)
  pos5 = pos5 + 1.0
end

let train_pc5 = map_get(ps5, "proto_count")
let train_pc5_int = int(train_pc5)
print("  Training protos: {train_pc5_int}")

let mut trans5 = []
let ts5 = train_pc5 * train_pc5
let mut ti5 = 0.0
while ti5 < ts5
  push(trans5, 0.0)
  ti5 = ti5 + 1.0
end
let sl5 = len(tseq5)
let mut si5 = 1.0
while si5 < sl5
  let f5 = tseq5[si5 - 1.0]
  let t5 = tseq5[si5]
  let idx5 = f5 * train_pc5 + t5
  trans5[idx5] = trans5[idx5] + 1.0
  si5 = si5 + 1.0
end

let pre_pc5 = map_get(ps5, "proto_count")
let test_max_5 = test_codes_len - gram_size_5 + 1.0
let mut correct5 = 0.0
let mut total5 = 0.0
let mut tp5 = 0.0
while tp5 < test_max_5
  let traw5 = text_ngram(test_codes, tp5, gram_size_5)
  let tcen5 = auto_center(traw5, cm5, cc5)

  if tp5 > 0.0
    let cur5 = map_get(ps5, "last_match_id")
    let mut bn5 = 0.0
    let mut bc5 = -1.0
    let mut cj5 = 0.0
    while cj5 < train_pc5
      let ci5 = cur5 * train_pc5 + cj5
      if ci5 < ts5
        if trans5[ci5] > bc5
          bc5 = trans5[ci5]
          bn5 = cj5
        end
      end
      cj5 = cj5 + 1.0
    end
    let dt5 = octobrain_observe(brain5, ps5, pe5, pm5, es5, we5, ob5, eds5, en5, ea5, eo5, ep5, ew5, eact5, win5, ws5, tcen5)
    let act5 = map_get(ps5, "last_match_id")
    if bn5 == act5
      correct5 = correct5 + 1.0
    end
    total5 = total5 + 1.0
  else
    let dt5f = octobrain_observe(brain5, ps5, pe5, pm5, es5, we5, ob5, eds5, en5, ea5, eo5, ep5, ew5, eact5, win5, ws5, tcen5)
  end
  tp5 = tp5 + 1.0
end

let acc5 = correct5 / total5
let pct5 = floor(acc5 * 1000.0) / 10.0
let post_pc5 = map_get(ps5, "proto_count")
let new_p5 = post_pc5 - pre_pc5
let new_p5_int = int(new_p5)
push(accuracies, acc5)
push(proto_counts, train_pc5)
push(new_proto_counts, new_p5)
print("  Accuracy: {pct5}%, New test protos: {new_p5_int}")

// ══════════════════════════════════════════════════════════════
// N=6 test
// ══════════════════════════════════════════════════════════════

print("--- N=6 (6-gram) ---")

let mut brain6 = octobrain_new(2.0)
let mut ps6 = proto_new()
let mut pe6 = []
let mut pm6 = []
let mut es6 = embed_new()
let mut we6 = []
let mut ob6 = []
let mut eds6 = edges_new()
let mut en6 = []
let mut ea6 = []
let mut eo6 = []
let mut ep6 = []
let mut ew6 = []
let mut eact6 = []
let mut win6 = []
let mut ws6 = []
let mut cm6 = []
let mut cc6 = [0.0]

let gram_size_6 = 6.0
let train_max_6 = train_codes_len - gram_size_6 + 1.0

let mut tseq6 = []
let mut pos6 = 0.0
while pos6 < train_max_6
  let raw6 = text_ngram(train_codes, pos6, gram_size_6)
  let centered6 = auto_center(raw6, cm6, cc6)
  let d6 = octobrain_observe(brain6, ps6, pe6, pm6, es6, we6, ob6, eds6, en6, ea6, eo6, ep6, ew6, eact6, win6, ws6, centered6)
  let pid6 = map_get(ps6, "last_match_id")
  push(tseq6, pid6)
  pos6 = pos6 + 1.0
end

let train_pc6 = map_get(ps6, "proto_count")
let train_pc6_int = int(train_pc6)
print("  Training protos: {train_pc6_int}")

let mut trans6 = []
let ts6 = train_pc6 * train_pc6
let mut ti6 = 0.0
while ti6 < ts6
  push(trans6, 0.0)
  ti6 = ti6 + 1.0
end
let sl6 = len(tseq6)
let mut si6 = 1.0
while si6 < sl6
  let f6 = tseq6[si6 - 1.0]
  let t6 = tseq6[si6]
  let idx6 = f6 * train_pc6 + t6
  trans6[idx6] = trans6[idx6] + 1.0
  si6 = si6 + 1.0
end

let pre_pc6 = map_get(ps6, "proto_count")
let test_max_6 = test_codes_len - gram_size_6 + 1.0
let mut correct6 = 0.0
let mut total6 = 0.0
let mut tp6 = 0.0
while tp6 < test_max_6
  let traw6 = text_ngram(test_codes, tp6, gram_size_6)
  let tcen6 = auto_center(traw6, cm6, cc6)

  if tp6 > 0.0
    let cur6 = map_get(ps6, "last_match_id")
    let mut bn6 = 0.0
    let mut bc6 = -1.0
    let mut cj6 = 0.0
    while cj6 < train_pc6
      let ci6 = cur6 * train_pc6 + cj6
      if ci6 < ts6
        if trans6[ci6] > bc6
          bc6 = trans6[ci6]
          bn6 = cj6
        end
      end
      cj6 = cj6 + 1.0
    end
    let dt6 = octobrain_observe(brain6, ps6, pe6, pm6, es6, we6, ob6, eds6, en6, ea6, eo6, ep6, ew6, eact6, win6, ws6, tcen6)
    let act6 = map_get(ps6, "last_match_id")
    if bn6 == act6
      correct6 = correct6 + 1.0
    end
    total6 = total6 + 1.0
  else
    let dt6f = octobrain_observe(brain6, ps6, pe6, pm6, es6, we6, ob6, eds6, en6, ea6, eo6, ep6, ew6, eact6, win6, ws6, tcen6)
  end
  tp6 = tp6 + 1.0
end

let acc6 = correct6 / total6
let pct6 = floor(acc6 * 1000.0) / 10.0
let post_pc6 = map_get(ps6, "proto_count")
let new_p6 = post_pc6 - pre_pc6
let new_p6_int = int(new_p6)
push(accuracies, acc6)
push(proto_counts, train_pc6)
push(new_proto_counts, new_p6)
print("  Accuracy: {pct6}%, New test protos: {new_p6_int}")

// ══════════════════════════════════════════════════════════════
// Results Summary
// ══════════════════════════════════════════════════════════════

print("")
print("=== Results Summary ===")
print("")
print("N-gram | Accuracy | Proto Count | New Test Protos | Threshold")
print("-------+----------+-------------+-----------------+----------")

let thr3 = compute_threshold(3.0)
let thr4 = compute_threshold(4.0)
let thr5 = compute_threshold(5.0)
let thr6 = compute_threshold(6.0)
print("     3 |   {pct3}% |          {train_pc3_int} |              {new_p3_int} |     {thr3:.2}")
print("     4 |   {pct4}% |          {train_pc4_int} |              {new_p4_int} |     {thr4:.2}")
print("     5 |   {pct5}% |          {train_pc5_int} |              {new_p5_int} |     {thr5:.2}")
print("     6 |   {pct6}% |          {train_pc6_int} |              {new_p6_int} |     {thr6:.2}")

print("")
print("=== PASS/FAIL Analysis ===")

let mut npass = 0.0
let mut nfail = 0.0

// Criterion 1: N=4 accuracy > N=3 accuracy
if acc4 > acc3
  print("PASS: N=4 ({pct4}%) > N=3 ({pct3}%) — longer context helps")
  npass = npass + 1.0
else
  print("FAIL: N=4 ({pct4}%) <= N=3 ({pct3}%) — longer context didn't help")
  nfail = nfail + 1.0
end

// Criterion 2: N=5 accuracy >= 0.60
if acc5 >= 0.60
  print("PASS: N=5 accuracy = {pct5}% >= 60%")
  npass = npass + 1.0
else
  print("FAIL: N=5 accuracy = {pct5}% < 60%")
  nfail = nfail + 1.0
end

// Criterion 3: All N-gram sizes have proto_count <= 30
if train_pc3 <= 30.0 && train_pc4 <= 30.0 && train_pc5 <= 30.0 && train_pc6 <= 30.0
  print("PASS: All proto counts <= 30")
  npass = npass + 1.0
else
  print("FAIL: Some proto count > 30")
  nfail = nfail + 1.0
end

// Criterion 4: Best accuracy >= 0.70
let mut best_acc = acc3
if acc4 > best_acc
  best_acc = acc4
end
if acc5 > best_acc
  best_acc = acc5
end
if acc6 > best_acc
  best_acc = acc6
end
let best_pct = floor(best_acc * 1000.0) / 10.0
if best_acc >= 0.70
  print("PASS: Best accuracy = {best_pct}% >= 70%")
  npass = npass + 1.0
else
  if best_acc >= 0.50
    print("NOTE: Best accuracy = {best_pct}% < 70% but >= 50% (acceptable)")
    npass = npass + 1.0
  else
    print("FAIL: Best accuracy = {best_pct}% < 50%")
    nfail = nfail + 1.0
  end
end

let npass_int = int(npass)
let nfail_int = int(nfail)
print("")
print("Result: {npass_int}/4 criteria passed, {nfail_int}/4 failed")

if npass >= 3.0
  print("OVERALL: PASS")
else
  print("OVERALL: FAIL")
end

print("")
print("--- extended N-gram NLP benchmark complete ---")
