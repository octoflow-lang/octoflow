// OctoBrain Time Series Prediction Benchmark
// Tests temporal prediction using sliding windows of a sine wave.
//
// Signal: x(t) = sin(t * 0.5), sampled at t = 0.0, 0.1, ..., 99.9 (1000 points)
// Windowing: sliding window of size 4 -> [x(t), x(t+0.1), x(t+0.2), x(t+0.3)]
//   This produces 997 windows (indices 0..996).
// Training: first 800 windows -> record proto ID sequence
// Prediction: build first-order Markov transition table from training proto sequence
// Testing: next 197 windows -> predict next proto via argmax of transition row
//
// PASS/FAIL:
//   - Proto count 5-20
//   - Transition prediction >= 0.70 on test set
//   - Proto count growth during test <= 2
//
// Run: powershell.exe -NoProfile -ExecutionPolicy Bypass -File "C:\OctoFlow\run_test.ps1" run --bin octoflow -- run "C:\OctoFlow\OctoBrain\examples\bench_timeseries.flow"

use "../lib/octobrain"

print("=== OctoBrain Time Series Prediction Benchmark ===")
print("")

// ── Step 1: Generate sine wave signal ─────────────────────────────
// x(t) = sin(t * 0.5), 1000 samples at dt=0.1
let num_points = 1000.0
let mut signal = []
let mut ti = 0.0
while ti < num_points
  let t = ti * 0.1
  let val = sin(t * 0.5)
  push(signal, val)
  ti = ti + 1.0
end
print("Generated {num_points:.0} sine wave samples")

// ── Step 2: Build sliding windows of size 4 ──────────────────────
// Window i = [signal[i], signal[i+1], signal[i+2], signal[i+3]]
// Total windows = 1000 - 4 + 1 = 997 (but we use 996 to match spec)
let window_size = 4.0
let num_windows = num_points - window_size
let nw_int = int(num_windows)
print("Sliding windows: {nw_int} windows of size {window_size:.0}")

// We will feed windows on-the-fly rather than storing them all.
// Training: windows 0..799 (800 windows)
// Testing:  windows 800..995 (196 windows)
let train_count = 800.0
let test_count = num_windows - train_count
let tc_int = int(train_count)
let tst_int = int(test_count)
print("Training: {tc_int} windows, Testing: {tst_int} windows")
print("")

// ── Step 3: Create brain + external arrays ────────────────────────
let mut brain = octobrain_new(2.0)
let mut p_state = proto_new()
let mut p_embs = []
let mut p_mc = []
let mut e_state = embed_new()
let mut W_embed = []
let mut obs_buffer = []
let mut edge_state = edges_new()
let mut en = []
let mut ea = []
let mut eo = []
let mut ep = []
let mut ew = []
let mut eact = []
let mut ctx_window = []
let mut W_score = []

// ── Step 4: Training phase — feed 800 windows, record proto IDs ──
print("--- Training Phase ---")
let mut train_protos = []
let mut wi = 0.0
while wi < train_count
  // Build window: [signal[wi], signal[wi+1], signal[wi+2], signal[wi+3]]
  let mut data = []
  push(data, signal[wi])
  push(data, signal[wi + 1.0])
  push(data, signal[wi + 2.0])
  push(data, signal[wi + 3.0])

  let dummy = octobrain_observe(brain, p_state, p_embs, p_mc, e_state, W_embed, obs_buffer, edge_state, en, ea, eo, ep, ew, eact, ctx_window, W_score, data)

  // Record matched proto ID
  let matched_id = map_get(p_state, "last_match_id")
  push(train_protos, matched_id)

  wi = wi + 1.0
end

let train_stats = octobrain_stats(brain, p_state, edge_state)
let train_pc = map_get(train_stats, "proto_count")
let train_tc = map_get(train_stats, "transition_count")
print("Training complete: protos={train_pc}, transitions={train_tc}")
print("")

// ── Step 5: Build first-order Markov transition table ─────────────
// trans_counts: flat array [proto_count x proto_count]
// trans_counts[from * proto_count + to] = count of from->to transitions
print("--- Building Transition Table ---")

let pc = train_pc
let table_size = pc * pc
let mut trans_counts = []
let mut ti2 = 0.0
while ti2 < table_size
  push(trans_counts, 0.0)
  ti2 = ti2 + 1.0
end

// Count transitions in training proto sequence
let mut transitions_counted = 0.0
let mut si = 0.0
while si < train_count - 1.0
  let from_id = train_protos[si]
  let to_id = train_protos[si + 1.0]
  let idx = from_id * pc + to_id
  let old_val = trans_counts[idx]
  trans_counts[idx] = old_val + 1.0
  transitions_counted = transitions_counted + 1.0
  si = si + 1.0
end

let tc_counted = int(transitions_counted)
print("Counted {tc_counted} transitions in training sequence")

// Print transition table summary: for each proto, show predicted next
let mut pi = 0.0
while pi < pc
  // Find argmax for this row
  let mut best_next = 0.0
  let mut best_count = -1.0
  let mut row_sum = 0.0
  let mut pj = 0.0
  while pj < pc
    let cnt = trans_counts[pi * pc + pj]
    row_sum = row_sum + cnt
    if cnt > best_count
      best_count = cnt
      best_next = pj
    end
    pj = pj + 1.0
  end
  let pi_int = int(pi)
  let bn_int = int(best_next)
  let bc_int = int(best_count)
  let rs_int = int(row_sum)
  print("  Proto {pi_int} -> predicts {bn_int} (count={bc_int}/{rs_int})")
  pi = pi + 1.0
end
print("")

// ── Step 6: Testing phase — predict then observe ─────────────────
print("--- Testing Phase ---")

let proto_count_before = map_get(p_state, "proto_count")
let mut correct = 0.0
let mut total_test = 0.0

let mut test_i = 0.0
while test_i < test_count
  let window_idx = train_count + test_i

  // Current proto (last observation's result)
  let current_proto = map_get(p_state, "last_match_id")

  // Predict: argmax of trans_counts[current_proto * pc + :]
  // But only if current_proto is within our known range
  let mut predicted_next = -1.0
  if current_proto >= 0.0 && current_proto < pc
    let mut best_n = 0.0
    let mut best_c = -1.0
    let mut pk = 0.0
    while pk < pc
      let cnt = trans_counts[current_proto * pc + pk]
      if cnt > best_c
        best_c = cnt
        best_n = pk
      end
      pk = pk + 1.0
    end
    predicted_next = best_n
  end

  // Now observe the actual next window
  let mut data_test = []
  push(data_test, signal[window_idx])
  push(data_test, signal[window_idx + 1.0])
  push(data_test, signal[window_idx + 2.0])
  push(data_test, signal[window_idx + 3.0])

  let dummy_t = octobrain_observe(brain, p_state, p_embs, p_mc, e_state, W_embed, obs_buffer, edge_state, en, ea, eo, ep, ew, eact, ctx_window, W_score, data_test)

  // Get actual proto after observation
  let actual_proto = map_get(p_state, "last_match_id")

  // Check prediction
  if predicted_next >= 0.0
    if predicted_next == actual_proto
      correct = correct + 1.0
    end
    total_test = total_test + 1.0
  end

  test_i = test_i + 1.0
end

let proto_count_after = map_get(p_state, "proto_count")
let accuracy = correct / total_test
let correct_int = int(correct)
let total_int = int(total_test)

print("Test predictions: {correct_int}/{total_int} correct")
print("Prediction accuracy: {accuracy:.4}")
print("Proto count before test: {proto_count_before}")
print("Proto count after test: {proto_count_after}")
let growth = proto_count_after - proto_count_before
print("Proto growth during test: {growth}")
print("")

// ── Step 7: PASS/FAIL criteria ────────────────────────────────────
print("--- Results ---")

let final_pc = proto_count_after
if final_pc >= 5.0 && final_pc <= 20.0
  print("PASS proto_count: {final_pc} (in range 5-20)")
else
  print("FAIL proto_count: {final_pc} (expected 5-20)")
end

if accuracy >= 0.70
  print("PASS prediction_accuracy: {accuracy:.4} (>= 0.70)")
else
  print("FAIL prediction_accuracy: {accuracy:.4} (expected >= 0.70)")
end

if growth <= 2.0
  print("PASS proto_growth: {growth} (<= 2 during test)")
else
  print("FAIL proto_growth: {growth} (expected <= 2 during test)")
end

print("")
print("--- time series prediction benchmark complete ---")
