// OctoBrain Sequence Type Classification Benchmark
// Can the brain tell different sequence types apart?
// Feed sequences of different types, see if prototypes separate by type.
//
// 4 sequence types, 50 examples each = 200 total:
//   Class 0: Arithmetic sequences — seq_arithmetic(start, step, 8)
//   Class 1: Geometric sequences  — seq_geometric(1.0, ratio, 8)
//   Class 2: Fibonacci-like sequences — (a, b) then f(n)=f(n-1)+f(n-2) for 8 terms
//   Class 3: Random sequences — sin-based deterministic pseudo-random
//
// Each sequence has 8 values as feature vector.
// Zero-centering is mandatory for positive-only features.
//
// PASS/FAIL criteria:
//   - Proto count 4-20 (structure discovered)
//   - Accuracy >= 0.60 (4 classes, random baseline = 0.25)
//   - At least 3 of 4 classes have a proto with purity >= 0.60
//
// Run:
//   powershell.exe -NoProfile -ExecutionPolicy Bypass -File "C:\OctoFlow\run_test.ps1" run --bin octoflow -- run "C:\OctoFlow\OctoBrain\examples\bench_seqclass.flow" --max-iters 20000000

use "../lib/octobrain"
use "../lib/sequence"
use "../lib/benchmark"

print("=== OctoBrain Sequence Type Classification Benchmark ===")
print("")

// ── Step 1: Generate all 200 sequences (50 per class) ─────────────────
// Each sequence is 8 floats. Store as flat array: data_flat = [200 x 8]
let num_samples = 200.0
let dim = 8.0
let num_classes = 4.0
let samples_per_class = 50.0

let mut data_flat = []
let mut labels = []

// ── Class 0: Arithmetic sequences ─────────────────────────────────────
// 50 variants: start in {1..10}, step in {1..5}
// We cycle through: for s in 1..10, for d in 1..5 => 50 combos
print("Generating Class 0: Arithmetic sequences...")
let mut arith_count = 0.0
let mut arith_start = 1.0
while arith_start <= 10.0 && arith_count < samples_per_class
  let mut arith_step = 1.0
  while arith_step <= 5.0 && arith_count < samples_per_class
    let seq = seq_arithmetic(arith_start, arith_step, dim)
    // Flatten into data_flat
    let mut k = 0.0
    while k < dim
      push(data_flat, seq[k])
      k = k + 1.0
    end
    push(labels, 0.0)
    arith_count = arith_count + 1.0
    arith_step = arith_step + 1.0
  end
  arith_start = arith_start + 1.0
end
let ac_int = int(arith_count)
print("  Generated {ac_int} arithmetic sequences")

// ── Class 1: Geometric sequences ──────────────────────────────────────
// 50 variants: ratio from 1.1 to 2.0 in steps of ~0.018
// ratio_i = 1.1 + i * (2.0 - 1.1) / 49.0 = 1.1 + i * 0.01836...
print("Generating Class 1: Geometric sequences...")
let mut geo_count = 0.0
while geo_count < samples_per_class
  let ratio = 1.1 + geo_count * 0.9 / 49.0
  let seq = seq_geometric(1.0, ratio, dim)
  let mut k = 0.0
  while k < dim
    push(data_flat, seq[k])
    k = k + 1.0
  end
  push(labels, 1.0)
  geo_count = geo_count + 1.0
end
let gc_int = int(geo_count)
print("  Generated {gc_int} geometric sequences")

// ── Class 2: Fibonacci-like sequences ─────────────────────────────────
// Start with (a, b), then f(n)=f(n-1)+f(n-2) for 8 terms
// Vary a in {1..5}, b in {1..10} => 50 combos
print("Generating Class 2: Fibonacci-like sequences...")
let mut fib_count = 0.0
let mut fib_a = 1.0
while fib_a <= 5.0 && fib_count < samples_per_class
  let mut fib_b = 1.0
  while fib_b <= 10.0 && fib_count < samples_per_class
    // Generate 8-term Fibonacci-like: start with (fib_a, fib_b)
    let mut seq = []
    let mut fa = fib_a
    let mut fb = fib_b
    let mut fi = 0.0
    while fi < dim
      push(seq, fa)
      let tmp = fa + fb
      fa = fb
      fb = tmp
      fi = fi + 1.0
    end
    // Flatten into data_flat
    let mut k = 0.0
    while k < dim
      push(data_flat, seq[k])
      k = k + 1.0
    end
    push(labels, 2.0)
    fib_count = fib_count + 1.0
    fib_b = fib_b + 1.0
  end
  fib_a = fib_a + 1.0
end
let fc_int = int(fib_count)
print("  Generated {fc_int} Fibonacci-like sequences")

// ── Class 3: Random sequences ─────────────────────────────────────────
// Deterministic pseudo-random using sin: data[i] = sin(seed * 1000.0 + i * 7.13)
// This avoids dependency on OctoFlow random() seed support.
print("Generating Class 3: Random (sin-based pseudo-random) sequences...")
let mut rand_count = 0.0
let mut seed = 1.0
while seed <= samples_per_class
  let mut ri = 0.0
  while ri < dim
    let val = sin(seed * 1000.0 + ri * 7.13)
    push(data_flat, val)
    ri = ri + 1.0
  end
  push(labels, 3.0)
  rand_count = rand_count + 1.0
  seed = seed + 1.0
end
let rc_int = int(rand_count)
print("  Generated {rc_int} random sequences")

let total_features = len(data_flat)
let total_labels = len(labels)
print("")
print("Total: {total_labels} samples x {dim:.0} features = {total_features} values")
print("")

// ── Step 2: Compute means and center data ─────────────────────────────
let means = compute_means(data_flat, num_samples, dim)
let m0 = means[0]
let m1 = means[1]
let m2 = means[2]
let m3 = means[3]
let m4 = means[4]
let m5 = means[5]
let m6 = means[6]
let m7 = means[7]
print("Feature means: [{m0:.2}, {m1:.2}, {m2:.2}, {m3:.2}, {m4:.2}, {m5:.2}, {m6:.2}, {m7:.2}]")

let centered = center_data(data_flat, means, num_samples, dim)
print("Data centered (zero-mean per feature)")
print("")

// ── Step 3: Create brain and feed all 200 centered samples ────────────
let mut brain = octobrain_new(2.0)
let mut p_state = proto_new()
let mut p_embs = []
let mut p_mc = []
let mut e_state = embed_new()
let mut W_embed = []
let mut obs_buffer = []
let mut edge_state = edges_new()
let mut en = []
let mut ea = []
let mut eo = []
let mut ep = []
let mut ew = []
let mut eact = []
let mut window_arr = []
let mut W_score = []

let mut match_protos = []

print("--- Feeding 200 centered samples to brain ---")
let mut i = 0.0
while i < num_samples
  // Extract 8-feature vector for this sample from centered data
  let mut sample = []
  let mut j = 0.0
  while j < dim
    push(sample, centered[i * dim + j])
    j = j + 1.0
  end

  let _obs = octobrain_observe(brain, p_state, p_embs, p_mc, e_state, W_embed, obs_buffer, edge_state, en, ea, eo, ep, ew, eact, window_arr, W_score, sample)

  // Record which prototype matched this sample
  let proto_id = map_get(p_state, "last_match_id")
  push(match_protos, proto_id)

  // Print milestones
  if i == 49.0 || i == 99.0 || i == 149.0 || i == 199.0
    let stats = octobrain_stats(brain, p_state, edge_state)
    let pc = map_get(stats, "proto_count")
    let ec = map_get(stats, "edge_count")
    let tc = map_get(stats, "transition_count")
    let step_int = int(i + 1.0)
    print("  Step {step_int}: protos={pc}, edges={ec}, transitions={tc}")
  end

  i = i + 1.0
end

print("Fed 200 observations to brain")
print("")

// ── Step 4: Brain stats ───────────────────────────────────────────────
let stats = octobrain_stats(brain, p_state, edge_state)
let proto_count = map_get(stats, "proto_count")
let edge_count = map_get(stats, "edge_count")
let transition_count = map_get(stats, "transition_count")
let obs_count = map_get(stats, "obs_count")

print("Brain stats:")
print("  Prototypes: {proto_count}")
print("  Edges: {edge_count}")
print("  Transitions: {transition_count}")
print("  Observations: {obs_count}")
print("")

// ── Step 5: Build mapping and compute accuracy ────────────────────────
let mapping = build_mapping(match_protos, labels, proto_count, num_classes)

// Print the mapping
print("Proto -> Class mapping:")
let mut mi = 0.0
while mi < proto_count
  let mapped_class = mapping[mi]
  let mc_int = int(mapped_class)
  let mi_int = int(mi)
  print("  Proto {mi_int} -> Class {mc_int}")
  mi = mi + 1.0
end
print("")

let acc = compute_accuracy(match_protos, labels, mapping, num_samples)
print("Accuracy: {acc:.4}")
print("")

// ── Step 6: Confusion matrix ──────────────────────────────────────────
print("Confusion Matrix:")
let _cm = print_confusion(match_protos, labels, mapping, num_samples, num_classes)
print("")

// ── Step 7: Per-prototype purity ──────────────────────────────────────
print("Prototype Purity:")
let _pu = print_purity(match_protos, labels, proto_count, num_classes, num_samples)
print("")

// ── Step 8: Count classes with a pure proto (purity >= 0.60) ──────────
// For each class, check if any proto has purity >= 0.60 for that class.
let mut pure_classes = 0.0
let mut cls = 0.0
while cls < num_classes
  let mut best_purity_for_class = 0.0
  let mut p = 0.0
  while p < proto_count
    // Count how many samples of this class matched this proto
    let mut class_count = 0.0
    let mut total_count = 0.0
    let mut si = 0.0
    while si < num_samples
      if match_protos[si] == p
        total_count = total_count + 1.0
        if labels[si] == cls
          class_count = class_count + 1.0
        end
      end
      si = si + 1.0
    end
    if total_count > 0.0
      let purity = class_count / total_count
      if purity > best_purity_for_class
        best_purity_for_class = purity
      end
    end
    p = p + 1.0
  end
  let cls_int = int(cls)
  if best_purity_for_class >= 0.60
    pure_classes = pure_classes + 1.0
    print("Class {cls_int}: best proto purity = {best_purity_for_class:.3} >= 0.60")
  else
    print("Class {cls_int}: best proto purity = {best_purity_for_class:.3} < 0.60")
  end
  cls = cls + 1.0
end
let pure_int = int(pure_classes)
print("Classes with pure proto (>= 0.60): {pure_int}/4")
print("")

// ── Step 9: PASS/FAIL criteria ────────────────────────────────────────
print("=== Results ===")

let mut pass_count = 0.0
let mut fail_count = 0.0

// Criterion 1: Proto count 4-20
if proto_count >= 4.0 && proto_count <= 20.0
  print("PASS proto_count: {proto_count} (in range 4-20)")
  pass_count = pass_count + 1.0
else
  print("FAIL proto_count: {proto_count} (expected 4-20)")
  fail_count = fail_count + 1.0
end

// Criterion 2: Accuracy >= 0.60
if acc >= 0.60
  print("PASS accuracy: {acc:.4} >= 0.60 (random baseline = 0.25)")
  pass_count = pass_count + 1.0
else
  print("FAIL accuracy: {acc:.4} < 0.60 (random baseline = 0.25)")
  fail_count = fail_count + 1.0
end

// Criterion 3: At least 3 of 4 classes have a proto with purity >= 0.60
if pure_classes >= 3.0
  print("PASS purity: {pure_int}/4 classes have a pure proto (>= 3 required)")
  pass_count = pass_count + 1.0
else
  print("FAIL purity: {pure_int}/4 classes have a pure proto (>= 3 required)")
  fail_count = fail_count + 1.0
end

let pass_int = int(pass_count)
let fail_int = int(fail_count)
print("")
print("Result: {pass_int}/3 criteria passed, {fail_int}/3 failed")

if pass_count == 3.0
  print("OVERALL: PASS")
else
  print("OVERALL: FAIL")
end

print("")
print("--- sequence type classification benchmark complete ---")
