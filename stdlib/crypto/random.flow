// stdlib/crypto/random.flow â€” Random generation utilities
//
// Functions: random_float, random_int, random_hex, uuid_v4, random_token,
//            random_choice, random_shuffle, random_sample, random_bool,
//            dice_roll, coin_flip, weighted_choice, random_normal
//
// Usage:
//   use "random"
//   let x = random_float(0.0, 100.0)   // uniform [0, 100)
//   let d = dice_roll(6.0)              // 1..6
//   let arr = [1.0, 2.0, 3.0, 4.0, 5.0]
//   random_shuffle(arr)                  // in-place Fisher-Yates

fn random_float(lo, hi)
  return lo + random() * (hi - lo)
end

fn random_int(lo, hi)
  return floor(lo + random() * (hi - lo + 1.0))
end

fn random_hex(length)
  let chars = "0123456789abcdef"
  let mut result = ""
  let mut i = 0.0
  while i < length
    let idx = floor(random() * 16.0)
    result = result + char_at(chars, idx)
    i = i + 1.0
  end
  return result
end

fn uuid_v4()
  // Generate UUID v4 format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
  let h1 = random_hex(8.0)
  let h2 = random_hex(4.0)
  let h3 = "4" + random_hex(3.0)
  let y_chars = "89ab"
  let y = char_at(y_chars, floor(random() * 4.0))
  let h4 = y + random_hex(3.0)
  let h5 = random_hex(12.0)
  return h1 + "-" + h2 + "-" + h3 + "-" + h4 + "-" + h5
end

fn random_token(length)
  let chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
  let n = len(chars)
  let mut result = ""
  let mut i = 0.0
  while i < length
    let idx = floor(random() * n)
    result = result + char_at(chars, idx)
    i = i + 1.0
  end
  return result
end

fn random_choice(arr)
  let n = len(arr)
  let idx = floor(random() * n)
  return arr[idx]
end

fn random_shuffle(arr)
  let n = len(arr)
  let mut i = n - 1.0
  while i > 0.0
    let j = floor(random() * (i + 1.0))
    let tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
    i = i - 1.0
  end
  return arr
end

fn random_sample(arr, k)
    // Sample k elements without replacement. Returns new array.
    // Uses partial Fisher-Yates on a copy.
    let n = len(arr)
    let mut copy = []
    let mut i = 0.0
    while i < n
        push(copy, arr[i])
        i = i + 1.0
    end

    let mut count = k
    if count > n
        count = n
    end

    i = 0.0
    while i < count
        let j = floor(random() * (n - i)) + i
        let tmp = copy[i]
        copy[i] = copy[j]
        copy[j] = tmp
        i = i + 1.0
    end

    let mut result = []
    i = 0.0
    while i < count
        push(result, copy[i])
        i = i + 1.0
    end
    return result
end

fn random_bool()
    // Return 1.0 or 0.0 with equal probability.
    if random() < 0.5
        return 1.0
    end
    return 0.0
end

fn dice_roll(sides)
    // Roll a die with given number of sides. Returns 1..sides.
    return floor(random() * sides) + 1.0
end

fn coin_flip()
    // Return "heads" or "tails".
    if random() < 0.5
        return "heads"
    end
    return "tails"
end

fn weighted_choice(values, weights)
    // Choose from values array using weights array.
    // Weights don't need to sum to 1.
    let n = len(values)
    if n == 0.0
        return 0.0
    end

    let mut total = 0.0
    let mut i = 0.0
    while i < n
        total = total + weights[i]
        i = i + 1.0
    end

    let mut r = random() * total
    i = 0.0
    while i < n
        r = r - weights[i]
        if r <= 0.0
            return values[i]
        end
        i = i + 1.0
    end
    return values[n - 1.0]
end

fn random_normal(mean, std)
    // Approximate normal distribution using Box-Muller transform.
    // Uses two uniform randoms to produce one normal variate.
    let u1 = random()
    let u2 = random()
    // Clamp u1 away from 0 to avoid log(0)
    let mut safe_u1 = u1
    if safe_u1 < 0.0001
        safe_u1 = 0.0001
    end
    let z = sqrt(-2.0 * log(safe_u1)) * cos(2.0 * 3.14159265358979 * u2)
    return mean + std * z
end
