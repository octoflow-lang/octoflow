// stdlib/data/transform.flow — Data transformations (CPU + GPU)
//
// Functions: normalize, standardize, one_hot, clip, interpolate_missing,
//            resample, bin_data, scale_to_range

fn normalize(arr)
  // Min-max normalization to [0, 1]
  let n = len(arr)
  let mut mn = arr[0]
  let mut mx = arr[0]
  for x in arr
    if x < mn
      mn = x
    end
    if x > mx
      mx = x
    end
  end
  let range = mx - mn
  if range == 0.0
    let mut result = []
    let mut i = 0.0
    while i < n
      push(result, 0.0)
      i = i + 1.0
    end
    return result
  end
  let mut result = []
  for x in arr
    push(result, (x - mn) / range)
  end
  return result
end

fn standardize(arr)
  // Z-score standardization (mean=0, std=1)
  let m = mean(arr)
  let sd = stddev(arr)
  if sd == 0.0
    let n = len(arr)
    let mut result = []
    let mut i = 0.0
    while i < n
      push(result, 0.0)
      i = i + 1.0
    end
    return result
  end
  let mut result = []
  for x in arr
    push(result, (x - m) / sd)
  end
  return result
end

fn one_hot(labels, num_classes)
  // One-hot encoding: labels → flat matrix (n * num_classes)
  let n = len(labels)
  let mut result = []
  for label in labels
    let mut j = 0.0
    while j < num_classes
      if j == label
        push(result, 1.0)
      else
        push(result, 0.0)
      end
      j = j + 1.0
    end
  end
  return result
end

fn clip(arr, lo, hi)
  let mut result = []
  for x in arr
    if x < lo
      push(result, lo)
    elif x > hi
      push(result, hi)
    else
      push(result, x)
    end
  end
  return result
end

fn interpolate_missing(arr, missing_val)
  // Linear interpolation for missing values
  let n = len(arr)
  let mut result = []
  let mut i = 0.0
  while i < n
    push(result, arr[i])
    i = i + 1.0
  end
  i = 0.0
  while i < n
    if result[i] == missing_val
      // Find previous valid
      let mut prev_idx = i - 1.0
      while prev_idx >= 0.0 && result[prev_idx] == missing_val
        prev_idx = prev_idx - 1.0
      end
      // Find next valid
      let mut next_idx = i + 1.0
      while next_idx < n && result[next_idx] == missing_val
        next_idx = next_idx + 1.0
      end
      if prev_idx >= 0.0 && next_idx < n
        let span = next_idx - prev_idx
        let frac = (i - prev_idx) / span
        result[i] = result[prev_idx] + frac * (result[next_idx] - result[prev_idx])
      elif prev_idx >= 0.0
        result[i] = result[prev_idx]
      elif next_idx < n
        result[i] = result[next_idx]
      end
    end
    i = i + 1.0
  end
  return result
end

fn resample(arr, factor)
  // Downsample by taking every Nth element
  let n = len(arr)
  let mut result = []
  let mut i = 0.0
  while i < n
    push(result, arr[floor(i)])
    i = i + factor
  end
  return result
end

fn bin_data(arr, num_bins)
  // Histogram binning: returns array of counts per bin
  let n = len(arr)
  let mut mn = arr[0]
  let mut mx = arr[0]
  for x in arr
    if x < mn
      mn = x
    end
    if x > mx
      mx = x
    end
  end
  let bin_width = (mx - mn) / num_bins
  let mut counts = []
  let mut i = 0.0
  while i < num_bins
    push(counts, 0.0)
    i = i + 1.0
  end
  for x in arr
    let mut bin = floor((x - mn) / bin_width)
    if bin >= num_bins
      bin = num_bins - 1.0
    end
    if bin < 0.0
      bin = 0.0
    end
    counts[bin] = counts[bin] + 1.0
  end
  return counts
end

fn scale_to_range(arr, new_min, new_max)
  let mut mn = arr[0]
  let mut mx = arr[0]
  for x in arr
    if x < mn
      mn = x
    end
    if x > mx
      mx = x
    end
  end
  let old_range = mx - mn
  let new_range = new_max - new_min
  if old_range == 0.0
    let n = len(arr)
    let mut result = []
    let mut i = 0.0
    while i < n
      push(result, new_min)
      i = i + 1.0
    end
    return result
  end
  let mut result = []
  for x in arr
    push(result, (x - mn) / old_range * new_range + new_min)
  end
  return result
end
