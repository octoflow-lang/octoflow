// test_transform.flow — Verify data transform stdlib functions
// Run from stdlib/data/: octoflow run test_transform.flow

use "transform"

let mut counters = [0.0, 0.0]

fn check(counters, label, got, expected)
  if got == expected
    counters[0] = counters[0] + 1.0
    return 1.0
  end
  counters[1] = counters[1] + 1.0
  print("  FAIL: {label} — got {got}, expected {expected}")
  return 0.0
end

fn check_near(counters, label, got, expected, tol)
  let d = abs(got - expected)
  if d < tol
    counters[0] = counters[0] + 1.0
    return 1.0
  end
  counters[1] = counters[1] + 1.0
  print("  FAIL: {label} — got {got}, expected {expected}")
  return 0.0
end

print("=== DATA TRANSFORM STDLIB VERIFICATION ===")
print(" ")

// ── normalize ────────────────────────────────────────────
// NOTE: native normalize() shadows .flow normalize() — returns L2 unit vector
// This is KNOWN_ISSUES #4 (builtin name collision)
print("--- normalize (L2 - native builtin shadows .flow min-max) ---")
let mut n_in = [3.0, 4.0]
let n_out = normalize(n_in)
// L2 norm of [3,4] = 5, so normalize = [0.6, 0.8]
let _c = check_near(counters, "norm L2[0]", n_out[0], 0.6, 0.01)
let _c = check_near(counters, "norm L2[1]", n_out[1], 0.8, 0.01)

// ── standardize ──────────────────────────────────────────
print("--- standardize ---")
let mut s_in = [10.0, 20.0, 30.0, 40.0, 50.0]
let s_out = standardize(s_in)
// Mean should be ~0
let s_sum = s_out[0] + s_out[1] + s_out[2] + s_out[3] + s_out[4]
let _c = check_near(counters, "std mean~0", s_sum / 5.0, 0.0, 0.1)

// ── clip ─────────────────────────────────────────────────
print("--- clip ---")
let mut c_in = [-5.0, 0.0, 5.0, 10.0, 15.0]
let c_out = clip(c_in, 0.0, 10.0)
let _c = check(counters, "clip[-5]", c_out[0], 0.0)
let _c = check(counters, "clip[5]", c_out[2], 5.0)
let _c = check(counters, "clip[15]", c_out[4], 10.0)

// (in_range is from validate.flow — tested in test_validate.flow)

// ── scale_to_range ───────────────────────────────────────
print("--- scale_to_range ---")
let mut sr_in = [0.0, 0.5, 1.0]
let sr_out = scale_to_range(sr_in, 10.0, 20.0)
let _c = check_near(counters, "scale[0]", sr_out[0], 10.0, 0.1)
let _c = check_near(counters, "scale[1]", sr_out[1], 15.0, 0.1)
let _c = check_near(counters, "scale[2]", sr_out[2], 20.0, 0.1)

// ── bin_data ─────────────────────────────────────────────
// bin_data returns COUNTS per bin (histogram), not bin indices
print("--- bin_data ---")
let mut b_in = [1.0, 5.0, 10.0, 15.0, 20.0]
let b_out = bin_data(b_in, 4.0)
let _c = check(counters, "bin num_bins", len(b_out), 4.0)
// Sum of counts should equal input length
let b_sum = b_out[0] + b_out[1] + b_out[2] + b_out[3]
let _c = check(counters, "bin sum", b_sum, 5.0)

// ── interpolate_missing ──────────────────────────────────
print("--- interpolate_missing ---")
let mut im_in = [1.0, -999.0, 3.0, -999.0, 5.0]
let im_out = interpolate_missing(im_in, -999.0)
let _c = check_near(counters, "interp[1]", im_out[1], 2.0, 0.01)
let _c = check_near(counters, "interp[3]", im_out[3], 4.0, 0.01)

// ── one_hot ──────────────────────────────────────────────
print("--- one_hot ---")
let mut oh_in = [0.0, 1.0, 2.0]
let oh_out = one_hot(oh_in, 3.0)
// one_hot([0,1,2], 3) → [1,0,0, 0,1,0, 0,0,1] = 9 elements
let _c = check(counters, "oh len", len(oh_out), 9.0)
let _c = check(counters, "oh[0]", oh_out[0], 1.0)
let _c = check(counters, "oh[1]", oh_out[1], 0.0)
let _c = check(counters, "oh[4]", oh_out[4], 1.0)

// ── resample ─────────────────────────────────────────────
// resample is DOWNSAMPLING — takes every Nth element
print("--- resample ---")
let mut rs_in = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
let rs_out = resample(rs_in, 2.0)
// Takes elements at 0, 2, 4 → [1, 3, 5]
let _c = check(counters, "resample len", len(rs_out), 3.0)
let _c = check(counters, "resamp[0]", rs_out[0], 1.0)
let _c = check(counters, "resamp[1]", rs_out[1], 3.0)
let _c = check(counters, "resamp[2]", rs_out[2], 5.0)

// ── SUMMARY ──────────────────────────────────────────────
let pass = counters[0]
let fail = counters[1]
let total = pass + fail
print(" ")
print("=== DATA TRANSFORM VERIFICATION SUMMARY ===")
print("  pass: {pass}/{total}")
print("  fail: {fail}")
if fail == 0.0
  print("  ALL PASS")
else
  print("  FAILURES DETECTED")
end
