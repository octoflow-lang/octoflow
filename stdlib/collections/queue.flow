// stdlib/collections/queue.flow â€” Queue (FIFO) data structure
//
// Map-based O(1) enqueue/dequeue using head/tail indices.
// Values stored as string keys: "v_0", "v_1", etc.
//
// Functions: queue_create, queue_enqueue, queue_dequeue, queue_peek,
//            queue_size, queue_is_empty, queue_clear, queue_to_array,
//            queue_contains, queue_enqueue_all
//
// Usage:
//   use "queue"
//   let mut q = queue_create()
//   queue_enqueue(q, 10.0)
//   queue_enqueue(q, 20.0)
//   queue_peek(q)         // "10" (string â€” use float() to convert)
//   queue_dequeue(q)      // "10"
//
// Uses map-based O(1) dequeue (same pattern as collections.flow)

fn queue_create()
  let mut q = map()
  map_set(q, "head", "0")
  map_set(q, "tail", "0")
  return q
end

fn queue_enqueue(q, val)
  let tail = float(map_get(q, "tail"))
  let key = "v_" + str(tail)
  map_set(q, key, str(val))
  map_set(q, "tail", str(tail + 1.0))
  return 0.0
end

fn queue_dequeue(q)
  let head = float(map_get(q, "head"))
  let tail = float(map_get(q, "tail"))
  if head >= tail
    return ""
  end
  let key = "v_" + str(head)
  let val = map_get(q, key)
  map_remove(q, key)
  map_set(q, "head", str(head + 1.0))
  return val
end

fn queue_peek(q)
  let head = float(map_get(q, "head"))
  let tail = float(map_get(q, "tail"))
  if head >= tail
    return ""
  end
  let key = "v_" + str(head)
  return map_get(q, key)
end

fn queue_size(q)
  let head = float(map_get(q, "head"))
  let tail = float(map_get(q, "tail"))
  return tail - head
end

fn queue_is_empty(q)
  if queue_size(q) == 0.0
    return 1.0
  end
  return 0.0
end

fn queue_clear(q)
  let mut head = float(map_get(q, "head"))
  let tail = float(map_get(q, "tail"))
  while head < tail
    let key = "v_" + str(head)
    map_remove(q, key)
    head = head + 1.0
  end
  map_set(q, "head", "0")
  map_set(q, "tail", "0")
  return 0.0
end

fn queue_to_array(q)
    // Return all values front-to-back as a flat array of strings.
    let mut head = float(map_get(q, "head"))
    let tail = float(map_get(q, "tail"))
    let mut result = []
    while head < tail
        let key = "v_" + str(head)
        push(result, float(map_get(q, key)))
        head = head + 1.0
    end
    return result
end

fn queue_contains(q, val)
    // Check if value exists in queue. Compares as strings.
    let mut head = float(map_get(q, "head"))
    let tail = float(map_get(q, "tail"))
    let target = str(val)
    while head < tail
        let key = "v_" + str(head)
        if map_get(q, key) == target
            return 1.0
        end
        head = head + 1.0
    end
    return 0.0
end

fn queue_enqueue_all(q, arr)
    // Enqueue all elements from an array.
    let n = len(arr)
    let mut i = 0.0
    while i < n
        queue_enqueue(q, arr[i])
        i = i + 1.0
    end
    return 0.0
end
