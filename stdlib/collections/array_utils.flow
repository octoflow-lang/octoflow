// stdlib/collections/array_utils.flow — Array manipulation utilities
//
// Functions: array_unique, array_zip, array_unzip, array_chunk,
//            array_take, array_drop, array_rotate_left, array_rotate_right,
//            array_remove_at, array_insert_at, array_flatten_2d,
//            array_interleave, array_repeat_each, array_compact
//
// Note: OctoFlow arrays are flat (no nested arrays). These operate on
// flat numeric arrays. For push/pop/extend/array_copy, use builtins.
//
// Usage:
//   use "array_utils"
//   let mut arr = [1.0, 2.0, 2.0, 3.0, 1.0]
//   let mut unique = array_unique(arr)  // [1.0, 2.0, 3.0]

// ── Deduplication ───────────────────────────────────────────────

fn array_unique(arr)
    // Remove duplicates, preserving first occurrence order.
    let n = len(arr)
    let mut result = []
    let mut seen = map()
    let mut i = 0.0
    while i < n
        let key = str(arr[i])
        if map_has(seen, key) == 0.0
            map_set(seen, key, "1")
            push(result, arr[i])
        end
        i = i + 1.0
    end
    return result
end

// ── Zip / Unzip ─────────────────────────────────────────────────

fn array_zip(a, b)
    // Interleave two arrays: [a0,b0,a1,b1,...].
    // Stops at the shorter array's length.
    let na = len(a)
    let nb = len(b)
    let mut n = na
    if nb < n
        n = nb
    end
    let mut result = []
    let mut i = 0.0
    while i < n
        push(result, a[i])
        push(result, b[i])
        i = i + 1.0
    end
    return result
end

fn array_unzip_first(arr)
    // Extract elements at even indices: [arr[0], arr[2], arr[4], ...]
    let n = len(arr)
    let mut result = []
    let mut i = 0.0
    while i < n
        push(result, arr[i])
        i = i + 2.0
    end
    return result
end

fn array_unzip_second(arr)
    // Extract elements at odd indices: [arr[1], arr[3], arr[5], ...]
    let n = len(arr)
    let mut result = []
    let mut i = 1.0
    while i < n
        push(result, arr[i])
        i = i + 2.0
    end
    return result
end

// ── Chunking ────────────────────────────────────────────────────

fn array_chunk_count(arr, chunk_size)
    // Return number of chunks when splitting arr into chunks of chunk_size.
    let n = len(arr)
    if chunk_size < 1.0
        return 0.0
    end
    return ceil(n / chunk_size)
end

fn array_chunk_get(arr, chunk_size, chunk_idx)
    // Get the chunk_idx-th chunk (0-indexed) of size chunk_size.
    let n = len(arr)
    let start = chunk_idx * chunk_size
    let mut result = []
    let mut i = start
    let end_idx = start + chunk_size
    while i < end_idx && i < n
        push(result, arr[i])
        i = i + 1.0
    end
    return result
end

// ── Take / Drop ─────────────────────────────────────────────────

fn array_take(arr, count)
    // Return first count elements.
    let n = len(arr)
    let mut result = []
    let mut limit = count
    if limit > n
        limit = n
    end
    let mut i = 0.0
    while i < limit
        push(result, arr[i])
        i = i + 1.0
    end
    return result
end

fn array_drop(arr, count)
    // Return array with first count elements removed.
    let n = len(arr)
    let mut result = []
    let mut i = count
    while i < n
        push(result, arr[i])
        i = i + 1.0
    end
    return result
end

fn array_take_last(arr, count)
    // Return last count elements.
    let n = len(arr)
    let mut start = n - count
    if start < 0.0
        start = 0.0
    end
    let mut result = []
    let mut i = start
    while i < n
        push(result, arr[i])
        i = i + 1.0
    end
    return result
end

// ── Rotation ────────────────────────────────────────────────────

fn array_rotate_left(arr, k)
    // Rotate array left by k positions. Returns new array.
    // [1,2,3,4,5] rotated left by 2 → [3,4,5,1,2]
    let n = len(arr)
    if n < 2.0
        let mut copy = []
        let mut ci = 0.0
        while ci < n
            push(copy, arr[ci])
            ci = ci + 1.0
        end
        return copy
    end
    // Normalize k
    let mut shift = k
    while shift < 0.0
        shift = shift + n
    end
    while shift >= n
        shift = shift - n
    end
    let mut result = []
    let mut i = shift
    while i < n
        push(result, arr[i])
        i = i + 1.0
    end
    i = 0.0
    while i < shift
        push(result, arr[i])
        i = i + 1.0
    end
    return result
end

fn array_rotate_right(arr, k)
    // Rotate array right by k positions.
    // [1,2,3,4,5] rotated right by 2 → [4,5,1,2,3]
    let n = len(arr)
    return array_rotate_left(arr, n - k)
end

// ── Insert / Remove ─────────────────────────────────────────────

fn array_insert_at(arr, idx, val)
    // Insert val at index idx, shifting elements right. Returns new array.
    let n = len(arr)
    let mut result = []
    let mut i = 0.0
    while i < idx && i < n
        push(result, arr[i])
        i = i + 1.0
    end
    push(result, val)
    while i < n
        push(result, arr[i])
        i = i + 1.0
    end
    return result
end

fn array_remove_at(arr, idx)
    // Remove element at index idx. Returns new array.
    let n = len(arr)
    let mut result = []
    let mut i = 0.0
    while i < n
        if i != idx
            push(result, arr[i])
        end
        i = i + 1.0
    end
    return result
end

// ── Other Utilities ─────────────────────────────────────────────

fn array_compact(arr)
    // Remove all zero values from array. Returns new array.
    let n = len(arr)
    let mut result = []
    let mut i = 0.0
    while i < n
        if arr[i] != 0.0
            push(result, arr[i])
        end
        i = i + 1.0
    end
    return result
end

fn array_repeat_each(arr, count)
    // Repeat each element count times. [1,2,3] with count=2 → [1,1,2,2,3,3]
    let n = len(arr)
    let mut result = []
    let mut i = 0.0
    while i < n
        let mut j = 0.0
        while j < count
            push(result, arr[i])
            j = j + 1.0
        end
        i = i + 1.0
    end
    return result
end

fn array_interleave(a, b)
    // Same as array_zip — alias for readability.
    return array_zip(a, b)
end

fn array_cumsum(arr)
    // Cumulative sum. [1,2,3,4] → [1,3,6,10]
    let n = len(arr)
    let mut result = []
    let mut total = 0.0
    let mut i = 0.0
    while i < n
        total = total + arr[i]
        push(result, total)
        i = i + 1.0
    end
    return result
end

fn array_diff(arr)
    // First differences. [1,3,6,10] → [2,3,4]
    let n = len(arr)
    let mut result = []
    let mut i = 1.0
    while i < n
        push(result, arr[i] - arr[i - 1.0])
        i = i + 1.0
    end
    return result
end
