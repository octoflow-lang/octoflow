// stdlib/collections/skip_list.flow â€” Probabilistic sorted data structure
//
// Skip list with O(log n) expected search, insert, and delete.
// Uses map-based node storage with linked-list levels.
//
// Node format (map keys):
//   "size" = number of elements
//   "max_level" = current max level (0-indexed)
//   "head_0", "head_1", ... = head pointers per level (-1.0 = null)
//   "v_N" = value of node N
//   "n_N_L" = next pointer of node N at level L (-1.0 = null)
//   "lvl_N" = level count of node N
//   "_counter" = next node ID
//
// Functions: skip_create, skip_insert, skip_search, skip_remove,
//            skip_min, skip_max, skip_size, skip_to_array, skip_contains,
//            skip_range
//
// Usage:
//   use "skip_list"
//   let mut sl = skip_create()
//   skip_insert(sl, 5.0)
//   skip_insert(sl, 3.0)
//   skip_insert(sl, 8.0)
//   skip_search(sl, 5.0)    // 1.0 (found)
//   skip_min(sl)             // 3.0
//   skip_to_array(sl)        // [3.0, 5.0, 8.0]

fn _skip_random_level(max_lvl)
    // Generate random level with probability 0.5 per level.
    let mut lvl = 0.0
    // Simple deterministic pseudo-random: use global counter
    while lvl < max_lvl
        let r = random_float()
        if r < 0.5
            break
        end
        lvl = lvl + 1.0
    end
    return lvl
end

fn skip_create()
    // Create empty skip list. Max 16 levels.
    let mut sl = map()
    map_set(sl, "size", "0")
    map_set(sl, "max_level", "0")
    map_set(sl, "_counter", "0")
    // Initialize head pointers
    let mut i = 0.0
    while i < 16.0
        map_set(sl, "head_" + str(i), "-1")
        i = i + 1.0
    end
    return sl
end

fn skip_size(sl)
    return to_num(map_get(sl, "size"))
end

fn skip_insert(sl, value)
    // Insert value into skip list. Maintains sorted order.
    let max_lvl = 15.0
    let node_lvl = _skip_random_level(max_lvl)

    // Update max level if needed
    let cur_max = to_num(map_get(sl, "max_level"))
    let mut new_max = cur_max
    if node_lvl > cur_max
        new_max = node_lvl
        map_set(sl, "max_level", str(new_max))
    end

    // Allocate node
    let id = to_num(map_get(sl, "_counter"))
    map_set(sl, "_counter", str(id + 1.0))
    map_set(sl, "v_" + str(id), str(value))
    map_set(sl, "lvl_" + str(id), str(node_lvl))

    // Find insert position at each level and link
    let mut lvl = new_max
    while lvl >= 0.0
        // Walk through level to find insert position
        let head_key = "head_" + str(lvl)
        let head_id = to_num(map_get(sl, head_key))

        if head_id < 0.0 || value <= to_num(map_get(sl, "v_" + str(head_id)))
            // Insert before head at this level
            if lvl <= node_lvl
                map_set(sl, "n_" + str(id) + "_" + str(lvl), str(head_id))
                map_set(sl, head_key, str(id))
            end
        else
            // Walk forward
            let mut prev = head_id
            let mut curr = to_num(map_get(sl, "n_" + str(prev) + "_" + str(lvl)))
            while curr >= 0.0 && to_num(map_get(sl, "v_" + str(curr))) < value
                prev = curr
                curr = to_num(map_get(sl, "n_" + str(prev) + "_" + str(lvl)))
            end
            // Insert after prev at this level
            if lvl <= node_lvl
                map_set(sl, "n_" + str(id) + "_" + str(lvl), str(curr))
                map_set(sl, "n_" + str(prev) + "_" + str(lvl), str(id))
            end
        end
        lvl = lvl - 1.0
    end

    let sz = to_num(map_get(sl, "size"))
    map_set(sl, "size", str(sz + 1.0))
    return 0.0
end

fn skip_search(sl, value)
    // Search for value. Returns 1.0 if found, 0.0 if not.
    let max_lvl = to_num(map_get(sl, "max_level"))
    let mut lvl = max_lvl
    let mut curr = -1.0

    while lvl >= 0.0
        let mut node = -1.0
        if curr < 0.0
            node = to_num(map_get(sl, "head_" + str(lvl)))
        else
            node = to_num(map_get(sl, "n_" + str(curr) + "_" + str(lvl)))
        end

        while node >= 0.0
            let nv = to_num(map_get(sl, "v_" + str(node)))
            if nv == value
                return 1.0
            end
            if nv > value
                break
            end
            curr = node
            node = to_num(map_get(sl, "n_" + str(node) + "_" + str(lvl)))
        end
        lvl = lvl - 1.0
    end
    return 0.0
end

fn skip_contains(sl, value)
    return skip_search(sl, value)
end

fn skip_remove(sl, value)
    // Remove first occurrence of value. Returns 1.0 if removed, 0.0 if not found.
    let max_lvl = to_num(map_get(sl, "max_level"))

    // Find the node to remove and its predecessors at each level
    let mut found_id = -1.0

    // First, find the node ID
    let mut node = to_num(map_get(sl, "head_0"))
    while node >= 0.0
        let nv = to_num(map_get(sl, "v_" + str(node)))
        if nv == value
            found_id = node
            break
        end
        if nv > value
            break
        end
        node = to_num(map_get(sl, "n_" + str(node) + "_0"))
    end

    if found_id < 0.0
        return 0.0
    end

    let node_lvl = to_num(map_get(sl, "lvl_" + str(found_id)))

    // Unlink at each level
    let mut lvl = 0.0
    while lvl <= node_lvl
        let head_key = "head_" + str(lvl)
        let head_id = to_num(map_get(sl, head_key))
        if head_id == found_id
            let next = to_num(map_get(sl, "n_" + str(found_id) + "_" + str(lvl)))
            map_set(sl, head_key, str(next))
        else
            // Walk to find predecessor
            let mut prev = head_id
            while prev >= 0.0
                let next = to_num(map_get(sl, "n_" + str(prev) + "_" + str(lvl)))
                if next == found_id
                    let skip_next = to_num(map_get(sl, "n_" + str(found_id) + "_" + str(lvl)))
                    map_set(sl, "n_" + str(prev) + "_" + str(lvl), str(skip_next))
                    break
                end
                prev = next
            end
        end
        lvl = lvl + 1.0
    end

    let sz = to_num(map_get(sl, "size"))
    map_set(sl, "size", str(sz - 1.0))
    return 1.0
end

fn skip_min(sl)
    // Return minimum (first) element. Returns -1.0 if empty.
    let head = to_num(map_get(sl, "head_0"))
    if head < 0.0
        return -1.0
    end
    return to_num(map_get(sl, "v_" + str(head)))
end

fn skip_max(sl)
    // Return maximum (last) element. Returns -1.0 if empty.
    let head = to_num(map_get(sl, "head_0"))
    if head < 0.0
        return -1.0
    end
    let mut node = head
    let mut next = to_num(map_get(sl, "n_" + str(node) + "_0"))
    while next >= 0.0
        node = next
        next = to_num(map_get(sl, "n_" + str(node) + "_0"))
    end
    return to_num(map_get(sl, "v_" + str(node)))
end

fn skip_to_array(sl)
    // Return all elements in sorted order.
    let mut result = []
    let mut node = to_num(map_get(sl, "head_0"))
    while node >= 0.0
        push(result, to_num(map_get(sl, "v_" + str(node))))
        node = to_num(map_get(sl, "n_" + str(node) + "_0"))
    end
    return result
end

fn skip_range(sl, lo, hi)
    // Return all elements in [lo, hi] range (inclusive).
    let mut result = []
    let mut node = to_num(map_get(sl, "head_0"))
    while node >= 0.0
        let v = to_num(map_get(sl, "v_" + str(node)))
        if v > hi
            break
        end
        if v >= lo
            push(result, v)
        end
        node = to_num(map_get(sl, "n_" + str(node) + "_0"))
    end
    return result
end
