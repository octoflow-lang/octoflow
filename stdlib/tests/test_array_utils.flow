// test_array_utils.flow — Tests for stdlib/array_utils.flow
// Functions tested: arr_contains, index_of, arr_sum, arr_avg, arr_min, arr_max,
//   swap, reverse, fill, binary_search, arr_unique, arr_flatten, arr_zip, arr_count

let mut pass = 0.0
let mut fail = 0.0

// -- Inline from array_utils.flow --

fn arr_contains(arr, val)
  for x in arr
    if x == val
      return 1.0
    end
  end
  return 0.0
end

fn arr_index_of(arr, val)
  let mut i = 0.0
  for x in arr
    if x == val
      return i
    end
    i = i + 1.0
  end
  return -1.0
end

fn arr_sum(arr)
  let mut total = 0.0
  for x in arr
    total = total + x
  end
  return total
end

fn arr_avg(arr)
  let mut total = 0.0
  for x in arr
    total = total + x
  end
  return total / len(arr)
end

fn arr_min(arr)
  let mut result = arr[0]
  for x in arr
    if x < result
      result = x
    end
  end
  return result
end

fn arr_max(arr)
  let mut result = arr[0]
  for x in arr
    if x > result
      result = x
    end
  end
  return result
end

fn swap(arr, i, j)
  let tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
  return 0.0
end

fn arr_reverse(arr)
  let n = len(arr)
  let half = floor(n / 2.0)
  for i in range(0, half)
    let j = n - 1.0 - i
    let tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
  end
  return 0.0
end

fn fill(arr, val)
  let n = len(arr)
  for i in range(0, n)
    arr[i] = val
  end
  return 0.0
end

fn binary_search(arr, target)
  let mut lo = 0.0
  let mut hi = len(arr) - 1.0
  for i in range(0, 30)
    if lo > hi
      return -1.0
    end
    let mid = floor((lo + hi) / 2.0)
    if arr[mid] == target
      return mid
    end
    if arr[mid] < target
      lo = mid + 1.0
    end
    if arr[mid] > target
      hi = mid - 1.0
    end
  end
  return -1.0
end

fn arr_sort(arr)
  let n = len(arr)
  let mut i = 1.0
  while i < n
    let key = arr[i]
    let mut j = i - 1.0
    while j >= 0.0
      if arr[j] > key
        arr[j + 1.0] = arr[j]
        j = j - 1.0
      else
        break
      end
    end
    arr[j + 1.0] = key
    i = i + 1.0
  end
  return arr
end

fn arr_slice(arr, start, stop)
  let n = len(arr)
  let mut s = start
  let mut e = stop
  if s < 0.0
    s = 0.0
  end
  if e > n
    e = n
  end
  let mut result = []
  let mut i = s
  while i < e
    push(result, arr[i])
    i = i + 1.0
  end
  return result
end

fn arr_unique(arr)
  let mut seen = map()
  let mut result = []
  for x in arr
    let key = str(x)
    if map_has(seen, key) == 0.0
      map_set(seen, key, "1")
      push(result, x)
    end
  end
  return result
end

fn arr_zip(a, b)
  let n = len(a)
  let m = len(b)
  let mut mn = n
  if m < mn
    mn = m
  end
  let mut result = []
  let mut i = 0.0
  while i < mn
    push(result, a[i])
    push(result, b[i])
    i = i + 1.0
  end
  return result
end

fn arr_count(arr, val)
  let mut c = 0.0
  for x in arr
    if x == val
      c = c + 1.0
    end
  end
  return c
end

// -- Tests --

print("=== test_array_utils ===")

// Test 1: arr_contains — found
let data = [10.0, 20.0, 30.0, 40.0]
if arr_contains(data, 30.0) == 1.0
  pass = pass + 1.0
else
  print("  FAIL: arr_contains found")
  fail = fail + 1.0
end

// Test 2: arr_contains — not found
if arr_contains(data, 99.0) == 0.0
  pass = pass + 1.0
else
  print("  FAIL: arr_contains not found")
  fail = fail + 1.0
end

// Test 3: arr_index_of — found
let idx = arr_index_of(data, 30.0)
if idx == 2.0
  pass = pass + 1.0
else
  print("  FAIL: index_of expected 2 got {idx}")
  fail = fail + 1.0
end

// Test 4: arr_index_of — not found
let idx2 = arr_index_of(data, 99.0)
if idx2 == -1.0
  pass = pass + 1.0
else
  print("  FAIL: index_of not found expected -1 got {idx2}")
  fail = fail + 1.0
end

// Test 5: arr_sum
let s = arr_sum(data)
if s == 100.0
  pass = pass + 1.0
else
  print("  FAIL: arr_sum expected 100 got {s}")
  fail = fail + 1.0
end

// Test 6: arr_avg
let a = arr_avg(data)
if a == 25.0
  pass = pass + 1.0
else
  print("  FAIL: arr_avg expected 25 got {a}")
  fail = fail + 1.0
end

// Test 7: arr_min
let mn = arr_min(data)
if mn == 10.0
  pass = pass + 1.0
else
  print("  FAIL: arr_min expected 10 got {mn}")
  fail = fail + 1.0
end

// Test 8: arr_max
let mx = arr_max(data)
if mx == 40.0
  pass = pass + 1.0
else
  print("  FAIL: arr_max expected 40 got {mx}")
  fail = fail + 1.0
end

// Test 9: swap
let mut sarr = [1.0, 2.0, 3.0]
let _sw = swap(sarr, 0.0, 2.0)
if sarr[0] == 3.0 && sarr[2] == 1.0
  pass = pass + 1.0
else
  print("  FAIL: swap")
  fail = fail + 1.0
end

// Test 10: reverse
let mut rarr = [1.0, 2.0, 3.0, 4.0]
let _rv = arr_reverse(rarr)
if rarr[0] == 4.0 && rarr[1] == 3.0 && rarr[2] == 2.0 && rarr[3] == 1.0
  pass = pass + 1.0
else
  print("  FAIL: reverse")
  fail = fail + 1.0
end

// Test 11: fill
let mut farr = [0.0, 0.0, 0.0]
let _fl = fill(farr, 7.0)
if farr[0] == 7.0 && farr[1] == 7.0 && farr[2] == 7.0
  pass = pass + 1.0
else
  print("  FAIL: fill")
  fail = fail + 1.0
end

// Test 12: binary_search — found
let sorted = [1.0, 3.0, 5.0, 7.0, 9.0]
let bs = binary_search(sorted, 5.0)
if bs == 2.0
  pass = pass + 1.0
else
  print("  FAIL: binary_search found expected 2 got {bs}")
  fail = fail + 1.0
end

// Test 13: binary_search — not found
let bs2 = binary_search(sorted, 4.0)
if bs2 == -1.0
  pass = pass + 1.0
else
  print("  FAIL: binary_search not found expected -1 got {bs2}")
  fail = fail + 1.0
end

// Test 14: arr_unique
let dupes = [1.0, 2.0, 3.0, 2.0, 1.0, 4.0]
let uniq = arr_unique(dupes)
let uniq_len = len(uniq)
if uniq_len == 4.0
  pass = pass + 1.0
else
  print("  FAIL: arr_unique expected len 4 got {uniq_len}")
  fail = fail + 1.0
end

// Test 15: arr_unique preserves order
if uniq[0] == 1.0 && uniq[1] == 2.0 && uniq[2] == 3.0 && uniq[3] == 4.0
  pass = pass + 1.0
else
  print("  FAIL: arr_unique order")
  fail = fail + 1.0
end

// Test 16: arr_unique on empty
let mut empty_arr = []
let empty_uniq = arr_unique(empty_arr)
let empty_len = len(empty_uniq)
if empty_len == 0.0
  pass = pass + 1.0
else
  print("  FAIL: arr_unique empty")
  fail = fail + 1.0
end

// Test 17: arr_zip
let za = [1.0, 2.0, 3.0]
let zb = [10.0, 20.0, 30.0]
let zipped = arr_zip(za, zb)
let zip_len = len(zipped)
if zip_len == 6.0 && zipped[0] == 1.0 && zipped[1] == 10.0 && zipped[4] == 3.0 && zipped[5] == 30.0
  pass = pass + 1.0
else
  print("  FAIL: arr_zip")
  fail = fail + 1.0
end

// Test 18: arr_zip unequal lengths
let zc = [1.0, 2.0]
let zd = [10.0, 20.0, 30.0]
let zipped2 = arr_zip(zc, zd)
let zip2_len = len(zipped2)
if zip2_len == 4.0
  pass = pass + 1.0
else
  print("  FAIL: arr_zip unequal expected 4 got {zip2_len}")
  fail = fail + 1.0
end

// Test 19: arr_count
let count_arr = [1.0, 2.0, 1.0, 3.0, 1.0]
let c = arr_count(count_arr, 1.0)
if c == 3.0
  pass = pass + 1.0
else
  print("  FAIL: arr_count expected 3 got {c}")
  fail = fail + 1.0
end

// Test 20: arr_count — not found
let c2 = arr_count(count_arr, 99.0)
if c2 == 0.0
  pass = pass + 1.0
else
  print("  FAIL: arr_count not found expected 0 got {c2}")
  fail = fail + 1.0
end

// Test 21: arr_sort
let mut unsorted = [5.0, 2.0, 8.0, 1.0, 9.0, 3.0]
let _sorted = arr_sort(unsorted)
if unsorted[0] == 1.0 && unsorted[1] == 2.0 && unsorted[2] == 3.0 && unsorted[5] == 9.0
  pass = pass + 1.0
else
  print("  FAIL: arr_sort")
  fail = fail + 1.0
end

// Test 22: arr_sort — already sorted
let mut already = [1.0, 2.0, 3.0]
let _s2 = arr_sort(already)
if already[0] == 1.0 && already[1] == 2.0 && already[2] == 3.0
  pass = pass + 1.0
else
  print("  FAIL: arr_sort already sorted")
  fail = fail + 1.0
end

// Test 23: arr_slice — middle portion
let src = [10.0, 20.0, 30.0, 40.0, 50.0]
let slc = arr_slice(src, 1.0, 4.0)
let slc_len = len(slc)
if slc_len == 3.0 && slc[0] == 20.0 && slc[1] == 30.0 && slc[2] == 40.0
  pass = pass + 1.0
else
  print("  FAIL: arr_slice(1,4)")
  fail = fail + 1.0
end

// Test 24: arr_slice — full array
let slc2 = arr_slice(src, 0.0, 5.0)
let slc2_len = len(slc2)
if slc2_len == 5.0
  pass = pass + 1.0
else
  print("  FAIL: arr_slice full expected 5 got {slc2_len}")
  fail = fail + 1.0
end

// Test 25: arr_slice — clamped bounds
let slc3 = arr_slice(src, -1.0, 100.0)
let slc3_len = len(slc3)
if slc3_len == 5.0
  pass = pass + 1.0
else
  print("  FAIL: arr_slice clamped expected 5 got {slc3_len}")
  fail = fail + 1.0
end

// Summary
let total = pass + fail
print("")
print("--- test_array_utils ---")
print("  pass: {pass}/{total}")
if fail > 0.0
  print("  FAIL: {fail} failures")
else
  print("  ALL PASS")
end
