// test_physics2d.flow — Tests for stdlib/game/physics2d.flow
// Functions tested: phys_add_body, phys_gravity, phys_integrate,
//   phys_bounce_walls, phys_collide_pairs, phys_kinetic_energy

let mut pass = 0.0
let mut fail = 0.0

// -- Inline from game/physics2d.flow --

fn phys_add_body(bx, by, bvx, bvy, bmass, bradius, x, y, vx, vy, mass, radius)
  push(bx, x)
  push(by, y)
  push(bvx, vx)
  push(bvy, vy)
  push(bmass, mass)
  push(bradius, radius)
  return len(bx) - 1.0
end

fn phys_gravity(by, bvy, bmass, dt, g)
  let n = len(bvy)
  for i in range(0, n)
    bvy[i] = bvy[i] + g * dt
  end
  return n
end

fn phys_integrate(bx, by, bvx, bvy, dt)
  let n = len(bx)
  for i in range(0, n)
    bx[i] = bx[i] + bvx[i] * dt
    by[i] = by[i] + bvy[i] * dt
  end
  return n
end

fn phys_bounce_walls(bx, by, bvx, bvy, bradius, min_x, min_y, max_x, max_y, restitution)
  let n = len(bx)
  let mut bounces = 0.0
  for i in range(0, n)
    let r = bradius[i]
    if bx[i] - r < min_x
      bx[i] = min_x + r
      bvx[i] = 0.0 - bvx[i] * restitution
      bounces = bounces + 1.0
    end
    if bx[i] + r > max_x
      bx[i] = max_x - r
      bvx[i] = 0.0 - bvx[i] * restitution
      bounces = bounces + 1.0
    end
    if by[i] - r < min_y
      by[i] = min_y + r
      bvy[i] = 0.0 - bvy[i] * restitution
      bounces = bounces + 1.0
    end
    if by[i] + r > max_y
      by[i] = max_y - r
      bvy[i] = 0.0 - bvy[i] * restitution
      bounces = bounces + 1.0
    end
  end
  return bounces
end

fn phys_dist_sq(x1, y1, x2, y2)
  let dx = x2 - x1
  let dy = y2 - y1
  return dx * dx + dy * dy
end

fn phys_collide_pairs(bx, by, bvx, bvy, bmass, bradius)
  let n = len(bx)
  let mut collisions = 0.0
  for i in range(0, n)
    let j_start = i + 1.0
    for j in range(j_start, n)
      let dx = bx[j] - bx[i]
      let dy = by[j] - by[i]
      let dist_sq = dx * dx + dy * dy
      let min_dist = bradius[i] + bradius[j]
      let min_dist_sq = min_dist * min_dist
      if dist_sq < min_dist_sq && dist_sq > 0.0
        collisions = collisions + 1.0
        let dist = sqrt(dist_sq)
        let nx = dx / dist
        let ny = dy / dist
        let dvx = bvx[j] - bvx[i]
        let dvy = bvy[j] - bvy[i]
        let dvn = dvx * nx + dvy * ny
        if dvn < 0.0
          let m_sum = bmass[i] + bmass[j]
          let impulse = 2.0 * dvn / m_sum
          bvx[i] = bvx[i] + impulse * bmass[j] * nx
          bvy[i] = bvy[i] + impulse * bmass[j] * ny
          bvx[j] = bvx[j] - impulse * bmass[i] * nx
          bvy[j] = bvy[j] - impulse * bmass[i] * ny
        end
        let overlap = min_dist - dist
        let sep = overlap / 2.0
        bx[i] = bx[i] - sep * nx
        by[i] = by[i] - sep * ny
        bx[j] = bx[j] + sep * nx
        by[j] = by[j] + sep * ny
      end
    end
  end
  return collisions
end

fn phys_kinetic_energy(bvx, bvy, bmass)
  let n = len(bvx)
  let mut ke = 0.0
  for i in range(0, n)
    let v_sq = bvx[i] * bvx[i] + bvy[i] * bvy[i]
    ke = ke + 0.5 * bmass[i] * v_sq
  end
  return ke
end

// -- Tests --

print("=== test_physics2d ===")

// Test 1: Add bodies and verify arrays
let mut bx = []
let mut by = []
let mut bvx = []
let mut bvy = []
let mut bmass = []
let mut bradius = []
let idx0 = phys_add_body(bx, by, bvx, bvy, bmass, bradius, 10.0, 20.0, 1.0, 0.0, 5.0, 1.0)
let idx1 = phys_add_body(bx, by, bvx, bvy, bmass, bradius, 50.0, 20.0, -1.0, 0.0, 5.0, 1.0)
let body_count = len(bx)
if body_count == 2.0 && idx0 == 0.0 && idx1 == 1.0
  pass = pass + 1.0
else
  print("  FAIL: add_body expected 2 bodies, got {body_count}")
  fail = fail + 1.0
end
if bx[0] == 10.0 && by[0] == 20.0 && bvx[0] == 1.0 && bmass[0] == 5.0
  pass = pass + 1.0
else
  print("  FAIL: body 0 values incorrect")
  fail = fail + 1.0
end

// Test 2: Gravity increases vy
let vy_before = bvy[0]
let _gn = phys_gravity(by, bvy, bmass, 1.0, 9.81)
let vy_after = bvy[0]
let vy_diff = abs(vy_after - vy_before - 9.81)
if vy_diff < 0.01
  pass = pass + 1.0
else
  print("  FAIL: gravity expected vy increase of 9.81, got diff={vy_diff}")
  fail = fail + 1.0
end

// Reset vy for clean integration test
bvy[0] = 0.0
bvy[1] = 0.0

// Test 3: Integration moves positions
let x0_before = bx[0]
let _in = phys_integrate(bx, by, bvx, bvy, 2.0)
// body 0: vx=1.0, dt=2.0 => x += 2.0
let x0_after = bx[0]
let x_diff = abs(x0_after - x0_before - 2.0)
if x_diff < 0.01
  pass = pass + 1.0
else
  print("  FAIL: integration expected x+=2 got delta={x_diff}")
  fail = fail + 1.0
end

// Test 4: Wall bounce — body at edge gets bounced back
// Reset to controlled state
let mut wx = []
let mut wy = []
let mut wvx = []
let mut wvy = []
let mut wm = []
let mut wr = []
let _w0 = phys_add_body(wx, wy, wvx, wvy, wm, wr, 0.5, 50.0, -5.0, 0.0, 1.0, 1.0)
// body at x=0.5 with radius=1.0, so x-r = -0.5 < min_x=0
let bounces = phys_bounce_walls(wx, wy, wvx, wvy, wr, 0.0, 0.0, 100.0, 100.0, 1.0)
if bounces >= 1.0
  pass = pass + 1.0
else
  print("  FAIL: wall bounce expected at least 1 bounce, got {bounces}")
  fail = fail + 1.0
end
// Velocity should be reversed
if wvx[0] > 0.0
  pass = pass + 1.0
else
  print("  FAIL: wall bounce expected positive vx after left wall bounce, got {wvx[0]}")
  fail = fail + 1.0
end
// Position should be clamped to min_x + radius = 1.0
let clamp_diff = abs(wx[0] - 1.0)
if clamp_diff < 0.01
  pass = pass + 1.0
else
  print("  FAIL: position not clamped after bounce, expected 1.0 got {wx[0]}")
  fail = fail + 1.0
end

// Test 5: Kinetic energy calculation
let mut kbvx = [3.0, 4.0]
let mut kbvy = [4.0, 3.0]
let mut km = [2.0, 2.0]
// body 0: 0.5 * 2 * (9+16) = 25
// body 1: 0.5 * 2 * (16+9) = 25
// total = 50
let ke = phys_kinetic_energy(kbvx, kbvy, km)
let ke_diff = abs(ke - 50.0)
if ke_diff < 0.01
  pass = pass + 1.0
else
  print("  FAIL: kinetic energy expected 50.0 got {ke}")
  fail = fail + 1.0
end

// Test 6: Collision energy conservation (approximate)
// Two equal-mass balls approaching each other head-on
let mut cx = []
let mut cy = []
let mut cvx = []
let mut cvy = []
let mut cm = []
let mut cr = []
// Ball A at x=4.5, moving right at 3.0
let _c0 = phys_add_body(cx, cy, cvx, cvy, cm, cr, 4.5, 10.0, 3.0, 0.0, 1.0, 1.0)
// Ball B at x=5.5, moving left at -3.0 (approaching, within radius sum = 2.0, dist = 1.0)
let _c1 = phys_add_body(cx, cy, cvx, cvy, cm, cr, 5.5, 10.0, -3.0, 0.0, 1.0, 1.0)

let ke_before = phys_kinetic_energy(cvx, cvy, cm)
let _colls = phys_collide_pairs(cx, cy, cvx, cvy, cm, cr)
let ke_after = phys_kinetic_energy(cvx, cvy, cm)

// For elastic collision of equal masses, KE should be conserved
let ke_ratio = ke_after / ke_before
let ke_err = abs(ke_ratio - 1.0)
if ke_err < 0.05
  pass = pass + 1.0
else
  print("  FAIL: KE not conserved in elastic collision, before={ke_before} after={ke_after} ratio={ke_ratio}")
  fail = fail + 1.0
end

// Test 7: After head-on elastic collision of equal masses, velocities swap
// Ball A should now move left (negative vx), Ball B should move right (positive vx)
if cvx[0] < 0.0 && cvx[1] > 0.0
  pass = pass + 1.0
else
  print("  FAIL: velocity swap expected, got vx0={cvx[0]} vx1={cvx[1]}")
  fail = fail + 1.0
end

// Summary
let total = pass + fail
print("")
print("--- test_physics2d ---")
print("  pass: {pass}/{total}")
if fail > 0.0
  print("  FAIL: {fail} failures")
else
  print("  ALL PASS")
end
