// test_gpu_histogram.flow — GPU Histogram unit test
//
// Test 1: N=256, 4 bins, input=[0..255], uniform → all bins = 64
// Test 2: N=256, 4 bins, input=[0,0,...,0] → bin 0 = 256, rest = 0
//
// Run: octoflow run stdlib/tests/test_gpu_histogram.flow --allow-ffi --allow-read

use "../gpu/runtime"

rt_init()

let pipe_hist = rt_load_pipeline("tests/gpu_shaders/34_histogram.spv", 2.0, 16.0)
let pipe_conv = rt_load_pipeline("tests/gpu_shaders/35_uint_to_float.spv", 2.0, 4.0)

// ── Test 1: Uniform distribution [0..255] into 4 bins ──────────────
let N1 = 256.0
let NBINS1 = 4.0
let MIN1 = 0.0
let WIDTH1 = 64.0

let mut input1 = []
let mut i = 0.0
while i < N1
  push(input1, i)
  i = i + 1.0
end

let buf_in1 = rt_create_buffer(N1 * 4.0)
let buf_hist1 = rt_create_buffer(NBINS1 * 4.0)
let buf_out1 = rt_create_buffer(NBINS1 * 4.0)
rt_upload(buf_in1, input1)

let mut zeros4 = [0.0, 0.0, 0.0, 0.0]
rt_upload(buf_hist1, zeros4)

rt_chain_begin(2.0, 2.0)
let mut pc1 = [N1, NBINS1, MIN1, WIDTH1]
rt_chain_push_constants(pipe_hist, pc1)
let mut bufs1a = [buf_in1, buf_hist1]
rt_chain_dispatch(pipe_hist, bufs1a, 1.0)
let mut pc1b = [NBINS1]
rt_chain_push_constants(pipe_conv, pc1b)
let mut bufs1b = [buf_hist1, buf_out1]
rt_chain_dispatch(pipe_conv, bufs1b, 1.0)
rt_chain_end()
rt_chain_submit_wait()

rt_download(buf_out1, NBINS1)

let mut pass1 = 1.0
print("Test 1: Histogram of [0..255] into 4 bins:")
let mut i = 0.0
while i < NBINS1
  let got = rt_result[int(i)]
  if got != 64.0
    print("  FAIL: bin {i} = {got}, expected 64")
    pass1 = 0.0
  end
  i = i + 1.0
end

let b0 = rt_result[0]
let b1 = rt_result[1]
let b2 = rt_result[2]
let b3 = rt_result[3]
print("  Result: [{b0}, {b1}, {b2}, {b3}]")
if pass1 == 1.0
  print("  PASS: Test 1 BIT EXACT")
end

// ── Test 2: All zeros → bin 0 gets everything ──────────────────────
let mut input2 = []
let mut i = 0.0
while i < N1
  push(input2, 0.0)
  i = i + 1.0
end

let buf_in2 = rt_create_buffer(N1 * 4.0)
let buf_hist2 = rt_create_buffer(NBINS1 * 4.0)
let buf_out2 = rt_create_buffer(NBINS1 * 4.0)
rt_upload(buf_in2, input2)
rt_upload(buf_hist2, zeros4)

rt_chain_begin(2.0, 2.0)
let mut pc2 = [N1, NBINS1, MIN1, WIDTH1]
rt_chain_push_constants(pipe_hist, pc2)
let mut bufs2a = [buf_in2, buf_hist2]
rt_chain_dispatch(pipe_hist, bufs2a, 1.0)
let mut pc2b = [NBINS1]
rt_chain_push_constants(pipe_conv, pc2b)
let mut bufs2b = [buf_hist2, buf_out2]
rt_chain_dispatch(pipe_conv, bufs2b, 1.0)
rt_chain_end()
rt_chain_submit_wait()

rt_download(buf_out2, NBINS1)

let mut pass2 = 1.0
let c0 = rt_result[0]
let c1 = rt_result[1]
let c2 = rt_result[2]
let c3 = rt_result[3]
print("Test 2: Histogram of 256 zeros:")
print("  Result: [{c0}, {c1}, {c2}, {c3}]")
if c0 != 256.0
  print("  FAIL: bin 0 = {c0}, expected 256")
  pass2 = 0.0
end
if c1 != 0.0
  print("  FAIL: bin 1 = {c1}, expected 0")
  pass2 = 0.0
end
if c2 != 0.0
  print("  FAIL: bin 2 = {c2}, expected 0")
  pass2 = 0.0
end
if c3 != 0.0
  print("  FAIL: bin 3 = {c3}, expected 0")
  pass2 = 0.0
end
if pass2 == 1.0
  print("  PASS: Test 2 BIT EXACT")
end

// ── Overall ────────────────────────────────────────────────────────
if pass1 == 1.0
  if pass2 == 1.0
    print("PASS: gpu_histogram all tests BIT EXACT")
  end
end

rt_cleanup()
