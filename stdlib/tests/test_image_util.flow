// test_image_util.flow — Tests for stdlib/media/image_util.flow
// Functions tested: img_get_pixel, img_set_pixel, img_fill, img_grayscale,
//   img_brightness, img_mse, img_psnr, img_crop, img_flip_h, img_flip_v
// Run: octoflow run stdlib/tests/test_image_util.flow

let mut pass = 0.0
let mut fail = 0.0

// -- Inline from media/image_util.flow --

fn img_get_pixel(r, g, b, w, x, y, result)
  let idx = int(y * w + x)
  result[0] = r[idx]
  result[1] = g[idx]
  result[2] = b[idx]
  return 1.0
end

fn img_set_pixel(r, g, b, w, x, y, pr, pg, pb)
  let idx = int(y * w + x)
  r[idx] = pr
  g[idx] = pg
  b[idx] = pb
  return 1.0
end

fn img_fill(r, g, b, w, h, pr, pg, pb)
  let count = w * h
  while len(r) > 0.0
    pop(r)
  end
  while len(g) > 0.0
    pop(g)
  end
  while len(b) > 0.0
    pop(b)
  end
  let mut i = 0.0
  while i < count
    push(r, pr)
    push(g, pg)
    push(b, pb)
    i = i + 1.0
  end
  return count
end

fn img_grayscale(r, g, b, count)
  let mut i = 0.0
  while i < count
    let idx = int(i)
    let gray = floor(0.299 * r[idx] + 0.587 * g[idx] + 0.114 * b[idx])
    let clamped = clamp(gray, 0.0, 255.0)
    r[idx] = clamped
    g[idx] = clamped
    b[idx] = clamped
    i = i + 1.0
  end
  return count
end

fn img_brightness(r, g, b, count, amount)
  let mut i = 0.0
  while i < count
    let idx = int(i)
    let nr = r[idx] + amount
    let ng = g[idx] + amount
    let nb = b[idx] + amount
    r[idx] = clamp(nr, 0.0, 255.0)
    g[idx] = clamp(ng, 0.0, 255.0)
    b[idx] = clamp(nb, 0.0, 255.0)
    i = i + 1.0
  end
  return count
end

fn img_mse(r1, g1, b1, r2, g2, b2, count)
  let mut sum = 0.0
  let mut i = 0.0
  while i < count
    let idx = int(i)
    let dr = r1[idx] - r2[idx]
    let dg = g1[idx] - g2[idx]
    let db = b1[idx] - b2[idx]
    sum = sum + dr * dr + dg * dg + db * db
    i = i + 1.0
  end
  return sum / (count * 3.0)
end

fn img_psnr(mse_val)
  if mse_val < 0.0001
    return 999.0
  end
  let ratio = 255.0 * 255.0 / mse_val
  let log_ratio = log(ratio)
  let log_10 = log(10.0)
  return 10.0 * log_ratio / log_10
end

fn img_crop(r, g, b, w, cx, cy, cw, ch, out_r, out_g, out_b)
  while len(out_r) > 0.0
    pop(out_r)
  end
  while len(out_g) > 0.0
    pop(out_g)
  end
  while len(out_b) > 0.0
    pop(out_b)
  end
  let mut row = 0.0
  while row < ch
    let mut col = 0.0
    while col < cw
      let src_idx = int((cy + row) * w + (cx + col))
      push(out_r, r[src_idx])
      push(out_g, g[src_idx])
      push(out_b, b[src_idx])
      col = col + 1.0
    end
    row = row + 1.0
  end
  return cw * ch
end

fn img_flip_h(r, g, b, w, h)
  let half_w = floor(w / 2.0)
  let mut row = 0.0
  while row < h
    let mut col = 0.0
    while col < half_w
      let left = int(row * w + col)
      let right = int(row * w + (w - 1.0 - col))
      let tr = r[left]
      r[left] = r[right]
      r[right] = tr
      let tg = g[left]
      g[left] = g[right]
      g[right] = tg
      let tb = b[left]
      b[left] = b[right]
      b[right] = tb
      col = col + 1.0
    end
    row = row + 1.0
  end
  return 1.0
end

fn img_flip_v(r, g, b, w, h)
  let half_h = floor(h / 2.0)
  let mut row = 0.0
  while row < half_h
    let mut col = 0.0
    while col < w
      let top = int(row * w + col)
      let bot = int((h - 1.0 - row) * w + col)
      let tr = r[top]
      r[top] = r[bot]
      r[bot] = tr
      let tg = g[top]
      g[top] = g[bot]
      g[bot] = tg
      let tb = b[top]
      b[top] = b[bot]
      b[bot] = tb
      col = col + 1.0
    end
    row = row + 1.0
  end
  return 1.0
end

// -- Tests --

print("=== test_image_util ===")

// Test 1: set/get pixel roundtrip on a 4x3 image
let mut r1 = []
let mut g1 = []
let mut b1 = []
let fc = img_fill(r1, g1, b1, 4.0, 3.0, 0.0, 0.0, 0.0)
let sp = img_set_pixel(r1, g1, b1, 4.0, 2.0, 1.0, 100.0, 150.0, 200.0)
let mut result = [0.0, 0.0, 0.0]
let gp = img_get_pixel(r1, g1, b1, 4.0, 2.0, 1.0, result)
if result[0] == 100.0 && result[1] == 150.0 && result[2] == 200.0
  pass = pass + 1.0
else
  print("  FAIL: set/get pixel roundtrip")
  fail = fail + 1.0
end

// Test 2: fill — all pixels have expected color
let mut r2 = []
let mut g2 = []
let mut b2 = []
let fc2 = img_fill(r2, g2, b2, 3.0, 2.0, 50.0, 100.0, 200.0)
let fill_len = len(r2)
if fill_len == 6.0 && r2[0] == 50.0 && g2[3] == 100.0 && b2[5] == 200.0
  pass = pass + 1.0
else
  print("  FAIL: fill — len={fill_len}")
  fail = fail + 1.0
end

// Test 3: grayscale — known RGB -> expected gray
// RGB(100, 200, 50): gray = floor(0.299*100 + 0.587*200 + 0.114*50)
// = floor(29.9 + 117.4 + 5.7) = floor(153.0) = 153
let mut r3 = [100.0]
let mut g3 = [200.0]
let mut b3 = [50.0]
let gs = img_grayscale(r3, g3, b3, 1.0)
if r3[0] == 153.0 && g3[0] == 153.0 && b3[0] == 153.0
  pass = pass + 1.0
else
  print("  FAIL: grayscale expected 153, got r={r3[0]}")
  fail = fail + 1.0
end

// Test 4: brightness — positive, clamped to 255
let mut r4 = [200.0]
let mut g4 = [100.0]
let mut b4 = [10.0]
let br = img_brightness(r4, g4, b4, 1.0, 100.0)
if r4[0] == 255.0 && g4[0] == 200.0 && b4[0] == 110.0
  pass = pass + 1.0
else
  print("  FAIL: brightness +100")
  fail = fail + 1.0
end

// Test 5: brightness — negative, clamped to 0
let mut r5 = [30.0]
let mut g5 = [100.0]
let mut b5 = [200.0]
let br2 = img_brightness(r5, g5, b5, 1.0, -50.0)
if r5[0] == 0.0 && g5[0] == 50.0 && b5[0] == 150.0
  pass = pass + 1.0
else
  print("  FAIL: brightness -50")
  fail = fail + 1.0
end

// Test 6: MSE — identical images = 0
let mut ra = [10.0, 20.0]
let mut ga = [30.0, 40.0]
let mut ba = [50.0, 60.0]
let mut rb = [10.0, 20.0]
let mut gb = [30.0, 40.0]
let mut bb = [50.0, 60.0]
let mse_zero = img_mse(ra, ga, ba, rb, gb, bb, 2.0)
if mse_zero == 0.0
  pass = pass + 1.0
else
  print("  FAIL: MSE identical expected 0, got {mse_zero}")
  fail = fail + 1.0
end

// Test 7: MSE — different images > 0
let mut rc = [0.0]
let mut gc = [0.0]
let mut bc = [0.0]
let mut rd = [10.0]
let mut gd = [10.0]
let mut bd = [10.0]
let mse_diff = img_mse(rc, gc, bc, rd, gd, bd, 1.0)
// MSE = (100 + 100 + 100) / 3 = 100
if mse_diff == 100.0
  pass = pass + 1.0
else
  print("  FAIL: MSE different expected 100, got {mse_diff}")
  fail = fail + 1.0
end

// Test 8: PSNR — MSE=0 -> high value (999)
let psnr_high = img_psnr(0.0)
if psnr_high == 999.0
  pass = pass + 1.0
else
  print("  FAIL: PSNR mse=0 expected 999, got {psnr_high}")
  fail = fail + 1.0
end

// Test 9: PSNR — MSE>0 -> finite positive value
let psnr_finite = img_psnr(100.0)
if psnr_finite > 0.0 && psnr_finite < 999.0
  pass = pass + 1.0
else
  print("  FAIL: PSNR mse=100 expected finite positive, got {psnr_finite}")
  fail = fail + 1.0
end

// Test 10: crop — extract 2x2 from 4x3 image at (1,1)
let mut cr = []
let mut cg = []
let mut cb = []
let fcc = img_fill(cr, cg, cb, 4.0, 3.0, 0.0, 0.0, 0.0)
// Set pixel at (2,1) = row1 col2 => index 1*4+2=6
cr[6] = 77.0
cg[6] = 88.0
cb[6] = 99.0
let mut crop_r = []
let mut crop_g = []
let mut crop_b = []
let crp = img_crop(cr, cg, cb, 4.0, 1.0, 1.0, 2.0, 2.0, crop_r, crop_g, crop_b)
let crop_len = len(crop_r)
// Cropped region starts at (1,1), width=2, height=2
// Row 0 of crop = src row 1, cols 1..2 => src indices 5,6
// Row 1 of crop = src row 2, cols 1..2 => src indices 9,10
// crop[1] = src[6] = 77.0
if crop_len == 4.0 && crop_r[1] == 77.0 && crop_g[1] == 88.0 && crop_b[1] == 99.0
  pass = pass + 1.0
else
  print("  FAIL: crop len={crop_len}")
  fail = fail + 1.0
end

// Test 11: flip_h — pixels moved to expected positions
// 3x1 image: [10, 20, 30] -> [30, 20, 10]
let mut fhr = [10.0, 20.0, 30.0]
let mut fhg = [0.0, 0.0, 0.0]
let mut fhb = [0.0, 0.0, 0.0]
let fhres = img_flip_h(fhr, fhg, fhb, 3.0, 1.0)
if fhr[0] == 30.0 && fhr[1] == 20.0 && fhr[2] == 10.0
  pass = pass + 1.0
else
  print("  FAIL: flip_h")
  fail = fail + 1.0
end

// Test 12: flip_v — rows swapped
// 2x2 image, row0=[10, 20], row1=[30, 40]
// After flip_v: row0=[30, 40], row1=[10, 20]
let mut fvr = [10.0, 20.0, 30.0, 40.0]
let mut fvg = [0.0, 0.0, 0.0, 0.0]
let mut fvb = [0.0, 0.0, 0.0, 0.0]
let fvres = img_flip_v(fvr, fvg, fvb, 2.0, 2.0)
if fvr[0] == 30.0 && fvr[1] == 40.0 && fvr[2] == 10.0 && fvr[3] == 20.0
  pass = pass + 1.0
else
  print("  FAIL: flip_v")
  fail = fail + 1.0
end

// Summary
let total = pass + fail
print("")
print("--- test_image_util ---")
print("  pass: {pass}/{total}")
if fail > 0.0
  print("  FAIL: {fail} failures")
else
  print("  ALL PASS")
end
