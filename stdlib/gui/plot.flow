// plot.flow — OctoFlow Charting Library
//
// Provides line, scatter, bar, heatmap, and candlestick charts
// rendered on canvas widgets. Built for the trading community.
//
// Usage:
//   use "gui"
//   use "plot"
//   let cvs = gui_canvas(10.0, 10.0, 800.0, 400.0)
//   let p = plot_create(cvs, 0.0, 100.0, 0.0, 50.0)
//   let _s = plot_series_line(p, x_data, y_data, 0.0, 200.0, 255.0)
//   let _d = plot_draw(p)

use "gui_core"
use "canvas"

// ── Theme Color Helpers (fallback if _tc not loaded) ────────────────

fn _plot_text_r()
  if len(_tc) > 17.0
    return _tc[15]
  end
  return 220.0
end

fn _plot_text_g()
  if len(_tc) > 17.0
    return _tc[16]
  end
  return 222.0
end

fn _plot_text_b()
  if len(_tc) > 17.0
    return _tc[17]
  end
  return 228.0
end

fn _plot_accent_r()
  if len(_tc) > 20.0
    return _tc[18]
  end
  return 99.0
end

fn _plot_accent_g()
  if len(_tc) > 20.0
    return _tc[19]
  end
  return 130.0
end

fn _plot_accent_b()
  if len(_tc) > 20.0
    return _tc[20]
  end
  return 237.0
end

fn _plot_panel_r()
  if len(_tc) > 5.0
    return _tc[3]
  end
  return 30.0
end

fn _plot_panel_g()
  if len(_tc) > 5.0
    return _tc[4]
  end
  return 31.0
end

fn _plot_panel_b()
  if len(_tc) > 5.0
    return _tc[5]
  end
  return 40.0
end

fn _plot_border_r()
  if len(_tc) > 23.0
    return _tc[21]
  end
  return 44.0
end

fn _plot_border_g()
  if len(_tc) > 23.0
    return _tc[22]
  end
  return 46.0
end

fn _plot_border_b()
  if len(_tc) > 23.0
    return _tc[23]
  end
  return 58.0
end

// ── Chart Type Constants ────────────────────────────────────────────
let PLOT_LINE = 1.0
let PLOT_SCATTER = 2.0
let PLOT_BAR = 3.0
let PLOT_HEATMAP = 4.0
let PLOT_CANDLE = 5.0
let PLOT_AREA = 6.0

// ── Plot Registry (parallel arrays, one per plot) ───────────────────
let mut _plot_canvas = []
let mut _plot_x_min = []
let mut _plot_x_max = []
let mut _plot_y_min = []
let mut _plot_y_max = []
let mut _plot_pad_left = []
let mut _plot_pad_bottom = []
let mut _plot_pad_top = []
let mut _plot_pad_right = []

// ── Series Registry (flat, stride-based) ────────────────────────────
// Each series: plot_id, type, data_start, data_count, r, g, b, extra
let mut _pseries_plot = []
let mut _pseries_type = []
let mut _pseries_start = []
let mut _pseries_count = []
let mut _pseries_r = []
let mut _pseries_g = []
let mut _pseries_b = []
let mut _pseries_extra = []

// ── Series XY Data (flat storage, shared across all series) ─────────
let mut _pseries_x = []
let mut _pseries_y = []

// ── OHLC Candle Data (separate flat arrays) ─────────────────────────
let mut _pcandle_open = []
let mut _pcandle_high = []
let mut _pcandle_low = []
let mut _pcandle_close = []
let mut _pcandle_start = []
let mut _pcandle_count = []
let mut _pcandle_up_r = []
let mut _pcandle_up_g = []
let mut _pcandle_up_b = []
let mut _pcandle_dn_r = []
let mut _pcandle_dn_g = []
let mut _pcandle_dn_b = []

// ── Plot Creation ───────────────────────────────────────────────────

fn plot_create(canvas_id, x_min, x_max, y_min, y_max)
  let id = len(_plot_canvas)
  push(_plot_canvas, canvas_id)
  push(_plot_x_min, x_min)
  push(_plot_x_max, x_max)
  push(_plot_y_min, y_min)
  push(_plot_y_max, y_max)
  push(_plot_pad_left, 0.0)
  push(_plot_pad_bottom, 0.0)
  push(_plot_pad_top, 0.0)
  push(_plot_pad_right, 0.0)
  return id
end

fn plot_set_padding(plot_id, pad_left, pad_bottom)
  let ii = int(plot_id)
  _plot_pad_left[ii] = pad_left
  _plot_pad_bottom[ii] = pad_bottom
  return 0.0
end

fn plot_set_padding_full(plot_id, pad_left, pad_bottom, pad_top, pad_right)
  let ii = int(plot_id)
  _plot_pad_left[ii] = pad_left
  _plot_pad_bottom[ii] = pad_bottom
  _plot_pad_top[ii] = pad_top
  _plot_pad_right[ii] = pad_right
  return 0.0
end

fn plot_set_range(plot_id, x_min, x_max, y_min, y_max)
  let ii = int(plot_id)
  _plot_x_min[ii] = x_min
  _plot_x_max[ii] = x_max
  _plot_y_min[ii] = y_min
  _plot_y_max[ii] = y_max
  return 0.0
end

// ── Coordinate Mapping ──────────────────────────────────────────────

fn _plot_map_x(plot_id, data_x)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let cw = _gui_w[cid]
  let pl = _plot_pad_left[ii]
  let pr = _plot_pad_right[ii]
  let xmin = _plot_x_min[ii]
  let xmax = _plot_x_max[ii]
  let xrange = xmax - xmin
  if xrange <= 0.0
    return pl
  end
  let plot_w = cw - pl - pr
  return pl + (data_x - xmin) / xrange * plot_w
end

fn _plot_map_y(plot_id, data_y)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let ch = _gui_h[cid]
  let pb = _plot_pad_bottom[ii]
  let pt = _plot_pad_top[ii]
  let ymin = _plot_y_min[ii]
  let ymax = _plot_y_max[ii]
  let yrange = ymax - ymin
  if yrange <= 0.0
    return ch - pb
  end
  let plot_h = ch - pb - pt
  // Invert Y: data_y=ymax → canvas_y=pt, data_y=ymin → canvas_y=ch-pb
  return ch - pb - (data_y - ymin) / yrange * plot_h
end

// ── Series: Line ────────────────────────────────────────────────────

fn plot_series_line(plot_id, x_arr, y_arr, r, g, b)
  let sid = len(_pseries_plot)
  let start = len(_pseries_x)
  let n = len(x_arr)
  // Copy data into flat storage
  let mut i = 0.0
  while i < n
    let ii = int(i)
    push(_pseries_x, x_arr[ii])
    push(_pseries_y, y_arr[ii])
    i = i + 1.0
  end
  push(_pseries_plot, plot_id)
  push(_pseries_type, PLOT_LINE)
  push(_pseries_start, start)
  push(_pseries_count, n)
  push(_pseries_r, r)
  push(_pseries_g, g)
  push(_pseries_b, b)
  push(_pseries_extra, 0.0)
  return sid
end

// ── Series: Area ────────────────────────────────────────────────────

fn plot_series_area(plot_id, x_arr, y_arr, r, g, b)
  let sid = len(_pseries_plot)
  let start = len(_pseries_x)
  let n = len(x_arr)
  let mut i = 0.0
  while i < n
    let ii = int(i)
    push(_pseries_x, x_arr[ii])
    push(_pseries_y, y_arr[ii])
    i = i + 1.0
  end
  push(_pseries_plot, plot_id)
  push(_pseries_type, PLOT_AREA)
  push(_pseries_start, start)
  push(_pseries_count, n)
  push(_pseries_r, r)
  push(_pseries_g, g)
  push(_pseries_b, b)
  push(_pseries_extra, 0.0)
  return sid
end

// ── Series: Scatter ─────────────────────────────────────────────────

fn plot_series_scatter(plot_id, x_arr, y_arr, r, g, b)
  let sid = len(_pseries_plot)
  let start = len(_pseries_x)
  let n = len(x_arr)
  let mut i = 0.0
  while i < n
    let ii = int(i)
    push(_pseries_x, x_arr[ii])
    push(_pseries_y, y_arr[ii])
    i = i + 1.0
  end
  push(_pseries_plot, plot_id)
  push(_pseries_type, PLOT_SCATTER)
  push(_pseries_start, start)
  push(_pseries_count, n)
  push(_pseries_r, r)
  push(_pseries_g, g)
  push(_pseries_b, b)
  push(_pseries_extra, 0.0)
  return sid
end

// ── Series: Bar ─────────────────────────────────────────────────────

fn plot_series_bar(plot_id, x_arr, y_arr, r, g, b, bar_width)
  let sid = len(_pseries_plot)
  let start = len(_pseries_x)
  let n = len(x_arr)
  let mut i = 0.0
  while i < n
    let ii = int(i)
    push(_pseries_x, x_arr[ii])
    push(_pseries_y, y_arr[ii])
    i = i + 1.0
  end
  push(_pseries_plot, plot_id)
  push(_pseries_type, PLOT_BAR)
  push(_pseries_start, start)
  push(_pseries_count, n)
  push(_pseries_r, r)
  push(_pseries_g, g)
  push(_pseries_b, b)
  push(_pseries_extra, bar_width)
  return sid
end

// ── Series: Candlestick ─────────────────────────────────────────────

fn plot_series_candle(plot_id, x_arr, open, high, low, close, up_r, up_g, up_b, dn_r, dn_g, dn_b)
  let sid = len(_pseries_plot)
  let candle_start = len(_pcandle_open)
  let n = len(x_arr)
  // Store x in series data
  let data_start = len(_pseries_x)
  let mut i = 0.0
  while i < n
    let ii = int(i)
    push(_pseries_x, x_arr[ii])
    push(_pseries_y, 0.0)
    // OHLC data
    push(_pcandle_open, open[ii])
    push(_pcandle_high, high[ii])
    push(_pcandle_low, low[ii])
    push(_pcandle_close, close[ii])
    i = i + 1.0
  end
  push(_pseries_plot, plot_id)
  push(_pseries_type, PLOT_CANDLE)
  push(_pseries_start, data_start)
  push(_pseries_count, n)
  push(_pseries_r, 0.0)
  push(_pseries_g, 0.0)
  push(_pseries_b, 0.0)
  push(_pseries_extra, 0.0)
  // Candle metadata
  push(_pcandle_start, candle_start)
  push(_pcandle_count, n)
  push(_pcandle_up_r, up_r)
  push(_pcandle_up_g, up_g)
  push(_pcandle_up_b, up_b)
  push(_pcandle_dn_r, dn_r)
  push(_pcandle_dn_g, dn_g)
  push(_pcandle_dn_b, dn_b)
  return sid
end

// ── Autoscale ───────────────────────────────────────────────────────
// Compute min/max from all series data and add 5% padding

fn plot_autoscale(plot_id)
  let nseries = len(_pseries_plot)
  let mut first = 1.0
  let mut xmin = 0.0
  let mut xmax = 1.0
  let mut ymin = 0.0
  let mut ymax = 1.0
  let mut s = 0.0
  while s < nseries
    let si = int(s)
    if _pseries_plot[si] == plot_id
      let stype = _pseries_type[si]
      let start = int(_pseries_start[si])
      let count = int(_pseries_count[si])
      let mut j = 0.0
      while j < count
        let ji = start + int(j)
        let xv = _pseries_x[ji]
        if stype == PLOT_CANDLE
          // Find candle index for OHLC
          let candle_sid = _find_candle_idx(s)
          if candle_sid >= 0.0
            let ci = int(_pcandle_start[int(candle_sid)]) + int(j)
            let o = _pcandle_open[ci]
            let h = _pcandle_high[ci]
            let l = _pcandle_low[ci]
            let c = _pcandle_close[ci]
            if first == 1.0
              xmin = xv
              xmax = xv
              ymin = l
              ymax = h
              first = 0.0
            else
              if xv < xmin
                xmin = xv
              end
              if xv > xmax
                xmax = xv
              end
              if l < ymin
                ymin = l
              end
              if h > ymax
                ymax = h
              end
            end
          end
        else
          let yv = _pseries_y[ji]
          if first == 1.0
            xmin = xv
            xmax = xv
            ymin = yv
            ymax = yv
            first = 0.0
          else
            if xv < xmin
              xmin = xv
            end
            if xv > xmax
              xmax = xv
            end
            if yv < ymin
              ymin = yv
            end
            if yv > ymax
              ymax = yv
            end
          end
        end
        j = j + 1.0
      end
    end
    s = s + 1.0
  end
  // Add 5% padding
  let xrange = xmax - xmin
  let yrange = ymax - ymin
  let xpad = xrange * 0.05
  let ypad = yrange * 0.05
  if xpad <= 0.0
    xpad = 1.0
  end
  if ypad <= 0.0
    ypad = 1.0
  end
  let ii = int(plot_id)
  _plot_x_min[ii] = xmin - xpad
  _plot_x_max[ii] = xmax + xpad
  _plot_y_min[ii] = ymin - ypad
  _plot_y_max[ii] = ymax + ypad
  return 0.0
end

// Find candle index for a series (candle series push to _pcandle_start/count in order)
fn _find_candle_idx(series_id)
  let mut candle_count = 0.0
  let mut s = 0.0
  while s <= series_id
    let si = int(s)
    if _pseries_type[si] == PLOT_CANDLE
      if s == series_id
        return candle_count
      end
      candle_count = candle_count + 1.0
    end
    s = s + 1.0
  end
  return -1.0
end

// ── Grid Lines ──────────────────────────────────────────────────────

fn plot_grid(plot_id, x_ticks, y_ticks)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let ch = _gui_h[cid]
  let cw = _gui_w[cid]
  let xmin = _plot_x_min[ii]
  let xmax = _plot_x_max[ii]
  let ymin = _plot_y_min[ii]
  let ymax = _plot_y_max[ii]
  // Grid line color (dim)
  let gr = 60.0
  let gg = 62.0
  let gb = 68.0
  // Vertical grid lines
  if x_ticks > 0.0
    let xrange = xmax - xmin
    let xstep = xrange / x_ticks
    let mut xi = 1.0
    while xi < x_ticks
      let xv = xmin + xi * xstep
      let px = _plot_map_x(plot_id, xv)
      let _l = gui_canvas_line(cid, px, 0.0, px, ch, gr, gg, gb)
      xi = xi + 1.0
    end
  end
  // Horizontal grid lines
  if y_ticks > 0.0
    let yrange = ymax - ymin
    let ystep = yrange / y_ticks
    let mut yi = 1.0
    while yi < y_ticks
      let yv = ymin + yi * ystep
      let py = _plot_map_y(plot_id, yv)
      let _l = gui_canvas_line(cid, 0.0, py, cw, py, gr, gg, gb)
      yi = yi + 1.0
    end
  end
  return 0.0
end

// ── Axis Tick Labels ────────────────────────────────────────────────
// Render numeric tick labels along grid lines

fn plot_grid_labels(plot_id, x_ticks, y_ticks)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let ch = _gui_h[cid]
  let xmin = _plot_x_min[ii]
  let xmax = _plot_x_max[ii]
  let ymin = _plot_y_min[ii]
  let ymax = _plot_y_max[ii]
  let pl = _plot_pad_left[ii]
  let pb = _plot_pad_bottom[ii]
  // Y-axis tick labels
  if y_ticks > 0.0
    let yrange = ymax - ymin
    let ystep = yrange / y_ticks
    let mut yk = 0.0
    while yk <= y_ticks
      let yval = ymin + yk * ystep
      let ypos = _plot_map_y(plot_id, yval)
      let label = str(floor(yval * 10.0) / 10.0)
      let _t = gui_canvas_text_colored(cid, pl - 30.0, ypos - 3.0, label, 1.0, _plot_text_r(), _plot_text_g(), _plot_text_b())
      yk = yk + 1.0
    end
  end
  // X-axis tick labels
  if x_ticks > 0.0
    let xrange = xmax - xmin
    let xstep = xrange / x_ticks
    let mut xk = 0.0
    while xk <= x_ticks
      let xval = xmin + xk * xstep
      let xpos = _plot_map_x(plot_id, xval)
      let label = str(floor(xval * 10.0) / 10.0)
      let _t = gui_canvas_text_colored(cid, xpos - 8.0, ch - pb + 4.0, label, 1.0, _plot_text_r(), _plot_text_g(), _plot_text_b())
      xk = xk + 1.0
    end
  end
  return 0.0
end

// ── Crosshair ───────────────────────────────────────────────────────
// Draw crosshair at mouse position (canvas-relative coordinates)

fn plot_crosshair(plot_id, mx, my)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let cw = _gui_w[cid]
  let ch = _gui_h[cid]
  // Crosshair color
  let cr = 200.0
  let cg = 200.0
  let cb = 200.0
  // Horizontal line
  let _h = gui_canvas_line(cid, 0.0, my, cw, my, cr, cg, cb)
  // Vertical line
  let _v = gui_canvas_line(cid, mx, 0.0, mx, ch, cr, cg, cb)
  return 0.0
end

// ── Internal Renderers ──────────────────────────────────────────────

fn _plot_draw_line_series(plot_id, sid)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let si = int(sid)
  let start = int(_pseries_start[si])
  let count = _pseries_count[si]
  let r = _pseries_r[si]
  let g = _pseries_g[si]
  let b = _pseries_b[si]
  let mut j = 0.0
  while j < count - 1.0
    let j1 = start + int(j)
    let j2 = j1 + 1
    let x1 = _plot_map_x(plot_id, _pseries_x[j1])
    let y1 = _plot_map_y(plot_id, _pseries_y[j1])
    let x2 = _plot_map_x(plot_id, _pseries_x[j2])
    let y2 = _plot_map_y(plot_id, _pseries_y[j2])
    let _l = gui_canvas_line(cid, x1, y1, x2, y2, r, g, b)
    j = j + 1.0
  end
  return 0.0
end

fn _plot_draw_scatter_series(plot_id, sid)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let si = int(sid)
  let start = int(_pseries_start[si])
  let count = _pseries_count[si]
  let r = _pseries_r[si]
  let g = _pseries_g[si]
  let b = _pseries_b[si]
  let mut j = 0.0
  while j < count
    let ji = start + int(j)
    let px = _plot_map_x(plot_id, _pseries_x[ji])
    let py = _plot_map_y(plot_id, _pseries_y[ji])
    // 3x3 dot
    let _f = gui_canvas_fill(cid, px - 1.0, py - 1.0, 3.0, 3.0, r, g, b)
    j = j + 1.0
  end
  return 0.0
end

fn _plot_draw_bar_series(plot_id, sid)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let si = int(sid)
  let start = int(_pseries_start[si])
  let count = _pseries_count[si]
  let r = _pseries_r[si]
  let g = _pseries_g[si]
  let b = _pseries_b[si]
  let bar_w = _pseries_extra[si]
  // Y position of zero line
  let y_zero = _plot_map_y(plot_id, 0.0)
  let mut j = 0.0
  while j < count
    let ji = start + int(j)
    let px = _plot_map_x(plot_id, _pseries_x[ji])
    let py = _plot_map_y(plot_id, _pseries_y[ji])
    // Map bar_width from data units to pixels
    let bw_px = _plot_map_x(plot_id, _pseries_x[ji] + bar_w) - px
    let mut bw = bw_px
    if bw < 1.0
      bw = 1.0
    end
    // Draw from zero to value
    let mut by = py
    let mut bh = y_zero - py
    if bh < 0.0
      by = y_zero
      bh = py - y_zero
    end
    if bh > 0.0
      let _f = gui_canvas_fill(cid, px, by, bw, bh, r, g, b)
    end
    j = j + 1.0
  end
  return 0.0
end

fn _plot_draw_candle_series(plot_id, sid)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let si = int(sid)
  let start = int(_pseries_start[si])
  let count = _pseries_count[si]
  // Find candle metadata
  let candle_sid = int(_find_candle_idx(sid))
  if candle_sid < 0.0
    return 0.0
  end
  let c_start = int(_pcandle_start[candle_sid])
  let up_r = _pcandle_up_r[candle_sid]
  let up_g = _pcandle_up_g[candle_sid]
  let up_b = _pcandle_up_b[candle_sid]
  let dn_r = _pcandle_dn_r[candle_sid]
  let dn_g = _pcandle_dn_g[candle_sid]
  let dn_b = _pcandle_dn_b[candle_sid]
  // Calculate body width from data spacing
  let mut body_w = 6.0
  if count > 1.0
    let x0 = _plot_map_x(plot_id, _pseries_x[start])
    let x1 = _plot_map_x(plot_id, _pseries_x[start + 1])
    let spacing = x1 - x0
    if spacing > 0.0
      body_w = spacing * 0.7
      if body_w < 1.0
        body_w = 1.0
      end
      if body_w > 20.0
        body_w = 20.0
      end
    end
  end
  let half_w = floor(body_w / 2.0)
  let mut j = 0.0
  while j < count
    let ji = start + int(j)
    let ci = c_start + int(j)
    let px = _plot_map_x(plot_id, _pseries_x[ji])
    let o = _pcandle_open[ci]
    let h = _pcandle_high[ci]
    let l = _pcandle_low[ci]
    let c = _pcandle_close[ci]
    let py_h = _plot_map_y(plot_id, h)
    let py_l = _plot_map_y(plot_id, l)
    let py_o = _plot_map_y(plot_id, o)
    let py_c = _plot_map_y(plot_id, c)
    // Determine direction
    let mut cr = up_r
    let mut cg = up_g
    let mut cb = up_b
    if c < o
      cr = dn_r
      cg = dn_g
      cb = dn_b
    end
    // Wick: vertical line from high to low
    let _wk = gui_canvas_line(cid, px, py_h, px, py_l, cr, cg, cb)
    // Body: filled rect from open to close
    let mut body_top = py_o
    let mut body_bot = py_c
    if py_c < py_o
      body_top = py_c
      body_bot = py_o
    end
    let body_h = body_bot - body_top
    if body_h < 1.0
      // Doji: horizontal line
      let _dj = gui_canvas_line(cid, px - half_w, py_o, px + half_w, py_o, cr, cg, cb)
    else
      let _bd = gui_canvas_fill(cid, px - half_w, body_top, body_w, body_h, cr, cg, cb)
    end
    j = j + 1.0
  end
  return 0.0
end

// ── Area Chart ──────────────────────────────────────────────────────
// Line chart with filled region below the line to the x-axis baseline.

fn _plot_draw_area_series(plot_id, sid)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let si = int(sid)
  let start = int(_pseries_start[si])
  let count = _pseries_count[si]
  let r = _pseries_r[si]
  let g = _pseries_g[si]
  let b = _pseries_b[si]
  if count < 2.0
    return 0.0
  end
  // Dimmed fill color (40% brightness)
  let fill_r = r * 0.4
  let fill_g = g * 0.4
  let fill_b = b * 0.4
  // Baseline Y position (data y=0 mapped to canvas)
  let baseline = _plot_map_y(plot_id, 0.0)
  // Draw filled vertical strips between consecutive points
  let mut j = 0.0
  while j < count - 1.0
    let j1 = start + int(j)
    let j2 = j1 + 1
    let x1 = _plot_map_x(plot_id, _pseries_x[j1])
    let y1 = _plot_map_y(plot_id, _pseries_y[j1])
    let x2 = _plot_map_x(plot_id, _pseries_x[j2])
    let y2 = _plot_map_y(plot_id, _pseries_y[j2])
    let strip_w = x2 - x1
    if strip_w > 0.0
      // Top of fill = min(y1, y2)
      let mut fill_y = y1
      if y2 < fill_y
        fill_y = y2
      end
      let fill_h = baseline - fill_y
      if fill_h > 0.0
        let _f = gui_canvas_fill(cid, x1, fill_y, strip_w, fill_h, fill_r, fill_g, fill_b)
      end
    end
    j = j + 1.0
  end
  // Draw line on top
  let _l = _plot_draw_line_series(plot_id, sid)
  return 0.0
end

// ── Main Draw ───────────────────────────────────────────────────────

fn plot_draw(plot_id)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  // Clear canvas
  let _clr = gui_canvas_clear(cid)
  // Draw all series belonging to this plot
  let nseries = len(_pseries_plot)
  let mut s = 0.0
  while s < nseries
    let si = int(s)
    if _pseries_plot[si] == plot_id
      let stype = _pseries_type[si]
      if stype == PLOT_LINE
        let _d = _plot_draw_line_series(plot_id, s)
      elif stype == PLOT_SCATTER
        let _d = _plot_draw_scatter_series(plot_id, s)
      elif stype == PLOT_BAR
        let _d = _plot_draw_bar_series(plot_id, s)
      elif stype == PLOT_CANDLE
        let _d = _plot_draw_candle_series(plot_id, s)
      elif stype == PLOT_HEATMAP
        let _d = _plot_draw_heatmap_series(plot_id, s)
      elif stype == PLOT_AREA
        let _d = _plot_draw_area_series(plot_id, s)
      end
    end
    s = s + 1.0
  end
  _gs[9] = 1.0
  return 0.0
end

// ── Heatmap Renderer ──────────────────────────────────────────────

fn _plot_draw_heatmap_series(plot_id, sid)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let si = int(sid)
  let start = int(_pseries_start[si])
  let count = _pseries_count[si]
  // Heatmap uses y values as intensity (0.0-1.0 range)
  // Color mapping: blue(0) -> green(0.5) -> red(1)
  let mut j = 0.0
  while j < count
    let ji = start + int(j)
    let px = _plot_map_x(plot_id, _pseries_x[ji])
    let py = _plot_map_y(plot_id, _pseries_y[ji])
    let mut intensity = _pseries_y[ji]
    if intensity < 0.0
      intensity = 0.0
    end
    if intensity > 1.0
      intensity = 1.0
    end
    // Map intensity to color
    let mut cr = 0.0
    let mut cg = 0.0
    let mut cb = 0.0
    if intensity < 0.5
      // Blue to green
      let t = intensity * 2.0
      cb = (1.0 - t) * 255.0
      cg = t * 255.0
    else
      // Green to red
      let t = (intensity - 0.5) * 2.0
      cg = (1.0 - t) * 255.0
      cr = t * 255.0
    end
    // Draw a 5x5 heat cell
    let _f = gui_canvas_fill(cid, px - 2.0, py - 2.0, 5.0, 5.0, cr, cg, cb)
    j = j + 1.0
  end
  return 0.0
end

// ── Axis Labels, Title, Legend ──────────────────────────────────────

// Plot title — centered above the plot area
fn plot_title(plot_id, title)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let cw = _gui_w[int(cid)]
  let pl = _plot_pad_left[ii]
  let pr = _plot_pad_right[ii]
  let pt = _plot_pad_top[ii]
  let plot_w = cw - pl - pr
  let tw = len(title) * 10.0
  let tx = pl + (plot_w - tw) / 2.0
  let ty = 4.0
  let _t = gui_canvas_text_colored(cid, tx, ty, title, 2.0, _plot_text_r(), _plot_text_g(), _plot_text_b())
  return 0.0
end

// X-axis label — centered below the plot area
fn plot_x_label(plot_id, label)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let cw = _gui_w[int(cid)]
  let ch = _gui_h[int(cid)]
  let pl = _plot_pad_left[ii]
  let pr = _plot_pad_right[ii]
  let pb = _plot_pad_bottom[ii]
  let plot_w = cw - pl - pr
  let tw = len(label) * 10.0
  let tx = pl + (plot_w - tw) / 2.0
  let ty = ch - 14.0
  let _t = gui_canvas_text_colored(cid, tx, ty, label, 2.0, _plot_accent_r(), _plot_accent_g(), _plot_accent_b())
  return 0.0
end

// Y-axis label — placed at top-left of plot area (horizontal)
fn plot_y_label(plot_id, label)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let pt = _plot_pad_top[ii]
  let tx = 4.0
  let ty = pt + 4.0
  let _t = gui_canvas_text_colored(cid, tx, ty, label, 2.0, _plot_accent_r(), _plot_accent_g(), _plot_accent_b())
  return 0.0
end

// Legend — shows series names and colors in a box
// Series names stored in _pseries_extra_name
let mut _pseries_name = []

fn plot_series_name(series_id, name)
  // Ensure name array is large enough
  while len(_pseries_name) <= series_id
    push(_pseries_name, "")
  end
  _pseries_name[int(series_id)] = name
  return 0.0
end

fn plot_legend(plot_id)
  let ii = int(plot_id)
  let cid = int(_plot_canvas[ii])
  let cw = _gui_w[int(cid)]
  let pt = _plot_pad_top[ii]
  let pr = _plot_pad_right[ii]
  // Draw legend box in top-right
  let nseries = len(_pseries_plot)
  let mut legend_count = 0.0
  let mut s = 0.0
  while s < nseries
    let si = int(s)
    if _pseries_plot[si] == plot_id
      if _pseries_count[si] > 0.0
        legend_count = legend_count + 1.0
      end
    end
    s = s + 1.0
  end
  if legend_count == 0.0
    return 0.0
  end
  let row_h = 16.0
  let leg_h = legend_count * row_h + 8.0
  let leg_w = 100.0
  let leg_x = cw - pr - leg_w - 4.0
  let leg_y = pt + 4.0
  // Background
  let _lbg = gui_canvas_fill(cid, leg_x, leg_y, leg_w, leg_h, _plot_panel_r(), _plot_panel_g(), _plot_panel_b())
  let _lbd = gui_canvas_rect(cid, leg_x, leg_y, leg_w, leg_h, _plot_border_r(), _plot_border_g(), _plot_border_b())
  // Entries
  let mut row = 0.0
  s = 0.0
  while s < nseries
    let si = int(s)
    if _pseries_plot[si] == plot_id
      if _pseries_count[si] > 0.0
        let ry = leg_y + 4.0 + row * row_h
        // Color swatch
        let _sw = gui_canvas_fill(cid, leg_x + 4.0, ry + 2.0, 10.0, 10.0, _pseries_r[si], _pseries_g[si], _pseries_b[si])
        // Name
        let mut sname = "Series " + str(s)
        if int(s) < len(_pseries_name)
          let named = _pseries_name[int(s)]
          if len(named) > 0.0
            sname = named
          end
        end
        let _sn = gui_canvas_text_colored(cid, leg_x + 18.0, ry + 1.0, sname, 1.0, _plot_text_r(), _plot_text_g(), _plot_text_b())
        row = row + 1.0
      end
    end
    s = s + 1.0
  end
  return 0.0
end

// ── Clear All Series ────────────────────────────────────────────────

fn plot_clear(plot_id)
  // Remove all series data for this plot by marking as invalid
  // Note: this is a soft clear — arrays stay allocated
  let nseries = len(_pseries_plot)
  let mut s = 0.0
  while s < nseries
    let si = int(s)
    if _pseries_plot[si] == plot_id
      _pseries_count[si] = 0.0
    end
    s = s + 1.0
  end
  return 0.0
end
