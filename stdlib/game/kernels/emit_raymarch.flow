// emit_raymarch.flow — SDF Ray March GPU compute shader emitter
//
// Generates a SPIR-V compute kernel for real-time SDF ray marching.
// Reads scene objects from register buffer (binding 0), camera from push constants.
// Writes planar RGB framebuffer to output (binding 2).
//
// Push constants (27 floats):
//   pc[0]  = total pixels      pc[1]  = width       pc[2]  = height
//   pc[3]  = object count      pc[4]  = light count
//   pc[5..7]   = eye position   pc[8..10]  = forward direction
//   pc[11..13] = right direction pc[14..16] = up direction
//   pc[17] = fov factor (tan(fov/2))
//   pc[18..20] = ambient light (r, g, b)
//   pc[21..26] = main light (x, y, z, r, g, b)
//
// Register buffer layout (binding 0):
//   obj[i*16 + 0]  = type (1=sphere, 2=box, 3=plane, 4=cylinder, 5=torus, 6=capsule)
//   obj[i*16 + 1..3] = position (x, y, z)
//   obj[i*16 + 4..7] = params (type-dependent: radius/half-size/normal/etc)
//   obj[i*16 + 8..10] = material color (r, g, b)

use "../../compiler/ir"

fn emit_raymarch(out_path)
  ir_new()
  ir_input_count = 2.0

  // ── Constants ──────────────────────────────────────────
  let entry = ir_block("entry")

  let c0f = ir_const_f(entry, 0.0)
  let c1f = ir_const_f(entry, 1.0)
  let c2f = ir_const_f(entry, 2.0)
  let c255 = ir_const_f(entry, 255.0)
  let c_half = ir_const_f(entry, 0.5)
  let c_eps = ir_const_f(entry, 0.001)
  let c_big = ir_const_f(entry, 99999.0)
  let c_max_steps = ir_const_f(entry, 64.0)
  let c_max_t = ir_const_f(entry, 100.0)
  let c_n1f = ir_const_f(entry, -1.0)
  let c_3f = ir_const_f(entry, 3.0)
  let c_4f = ir_const_f(entry, 4.0)
  let c_5f = ir_const_f(entry, 5.0)
  let c_6f = ir_const_f(entry, 6.0)

  let c0u = ir_const_u(entry, 0.0)
  let c1u = ir_const_u(entry, 1.0)
  let c2u = ir_const_u(entry, 2.0)
  let c3u = ir_const_u(entry, 3.0)
  let c4u = ir_const_u(entry, 4.0)
  let c5u = ir_const_u(entry, 5.0)
  let c6u = ir_const_u(entry, 6.0)
  let c8u = ir_const_u(entry, 8.0)
  let c9u = ir_const_u(entry, 9.0)
  let c10u = ir_const_u(entry, 10.0)
  let c7u = ir_const_u(entry, 7.0)
  let c16u = ir_const_u(entry, 16.0)

  // ── Push Constants ─────────────────────────────────────
  let pc_total = ir_push_const(entry, 0.0)
  let pc_w = ir_push_const(entry, 1.0)
  let pc_h = ir_push_const(entry, 2.0)
  let pc_obj_n = ir_push_const(entry, 3.0)
  let pc_lit_n = ir_push_const(entry, 4.0)
  let pc_ex = ir_push_const(entry, 5.0)
  let pc_ey = ir_push_const(entry, 6.0)
  let pc_ez = ir_push_const(entry, 7.0)
  let pc_fx = ir_push_const(entry, 8.0)
  let pc_fy = ir_push_const(entry, 9.0)
  let pc_fz = ir_push_const(entry, 10.0)
  let pc_rx = ir_push_const(entry, 11.0)
  let pc_ry = ir_push_const(entry, 12.0)
  let pc_rz = ir_push_const(entry, 13.0)
  let pc_ux = ir_push_const(entry, 14.0)
  let pc_uy = ir_push_const(entry, 15.0)
  let pc_uz = ir_push_const(entry, 16.0)
  let pc_fov = ir_push_const(entry, 17.0)
  let pc_ar = ir_push_const(entry, 18.0)
  let pc_ag = ir_push_const(entry, 19.0)
  let pc_ab = ir_push_const(entry, 20.0)
  let pc_lx = ir_push_const(entry, 21.0)
  let pc_ly = ir_push_const(entry, 22.0)
  let pc_lz = ir_push_const(entry, 23.0)
  let pc_lr = ir_push_const(entry, 24.0)
  let pc_lg = ir_push_const(entry, 25.0)
  let pc_lb = ir_push_const(entry, 26.0)

  // ── Bounds Check ───────────────────────────────────────
  let gid = ir_load_gid(entry)
  let gid_f = ir_utof(entry, gid)
  let in_bounds = ir_folt(entry, gid_f, pc_total)

  let main_m = ir_block("main_m")
  let work = ir_block("work")
  ir_selection_merge(entry, main_m)
  ir_term_cond_branch(entry, in_bounds, work, main_m)

  // ── Pixel → Ray ───────────────────────────────────────
  let wu = ir_ftou(work, pc_w)
  let pxu = ir_umod(work, gid, wu)
  let pyu = ir_udiv(work, gid, wu)
  let pxf = ir_utof(work, pxu)
  let pyf = ir_utof(work, pyu)

  // NDC
  let aspect = ir_fdiv(work, pc_w, pc_h)
  let nx_raw = ir_fsub(work, ir_fmul(work, c2f, ir_fdiv(work, pxf, pc_w)), c1f)
  let ny_raw = ir_fsub(work, c1f, ir_fmul(work, c2f, ir_fdiv(work, pyf, pc_h)))
  let ndcx = ir_fmul(work, ir_fmul(work, nx_raw, aspect), pc_fov)
  let ndcy = ir_fmul(work, ny_raw, pc_fov)

  // dir = normalize(forward + right*ndcx + up*ndcy)
  let drx = ir_fadd(work, pc_fx, ir_fadd(work, ir_fmul(work, pc_rx, ndcx), ir_fmul(work, pc_ux, ndcy)))
  let dry = ir_fadd(work, pc_fy, ir_fadd(work, ir_fmul(work, pc_ry, ndcx), ir_fmul(work, pc_uy, ndcy)))
  let drz = ir_fadd(work, pc_fz, ir_fadd(work, ir_fmul(work, pc_rz, ndcx), ir_fmul(work, pc_uz, ndcy)))
  let dl2 = ir_fadd(work, ir_fmul(work, drx, drx), ir_fadd(work, ir_fmul(work, dry, dry), ir_fmul(work, drz, drz)))
  let dli = ir_fdiv(work, c1f, ir_sqrt(work, dl2))
  let dx = ir_fmul(work, drx, dli)
  let dy = ir_fmul(work, dry, dli)
  let dz = ir_fmul(work, drz, dli)

  // ── March Loop ─────────────────────────────────────────
  let mh = ir_block("mh")
  let mb = ir_block("mb")
  let mc = ir_block("mc")
  let mm = ir_block("mm")

  ir_term_branch(work, mh)
  ir_loop_merge(mh, mm, mc)

  let phi_step = ir_phi(mh, IR_TYPE_FLOAT)
  let phi_t = ir_phi(mh, IR_TYPE_FLOAT)
  let phi_hit = ir_phi(mh, IR_TYPE_FLOAT)
  let phi_clo = ir_phi(mh, IR_TYPE_FLOAT)

  let step_ok = ir_folt(mh, phi_step, c_max_steps)
  let not_hit = ir_foeq(mh, phi_hit, c0f)
  let m_cond = ir_land(mh, step_ok, not_hit)
  ir_term_cond_branch(mh, m_cond, mb, mm)

  // Ray position = eye + t * dir
  let rpx = ir_fadd(mb, pc_ex, ir_fmul(mb, phi_t, dx))
  let rpy = ir_fadd(mb, pc_ey, ir_fmul(mb, phi_t, dy))
  let rpz = ir_fadd(mb, pc_ez, ir_fmul(mb, phi_t, dz))

  // ── SDF Eval Loop (nested) ─────────────────────────────
  let sh = ir_block("sh")
  let sb = ir_block("sb")
  let sc = ir_block("sc")
  let sm = ir_block("sm")

  ir_term_branch(mb, sh)
  ir_loop_merge(sh, sm, sc)

  let s_idx = ir_phi(sh, IR_TYPE_FLOAT)
  let s_min = ir_phi(sh, IR_TYPE_FLOAT)
  let s_clo = ir_phi(sh, IR_TYPE_FLOAT)

  let s_cond = ir_folt(sh, s_idx, pc_obj_n)
  ir_term_cond_branch(sh, s_cond, sb, sm)

  // Read object from register buffer (binding 0)
  let iu = ir_ftou(sb, s_idx)
  let base = ir_imul(sb, iu, c16u)
  let obj_t = ir_load_input_at(sb, 0.0, base)
  let ox = ir_load_input_at(sb, 0.0, ir_iadd(sb, base, c1u))
  let oy = ir_load_input_at(sb, 0.0, ir_iadd(sb, base, c2u))
  let oz = ir_load_input_at(sb, 0.0, ir_iadd(sb, base, c3u))
  let p1 = ir_load_input_at(sb, 0.0, ir_iadd(sb, base, c4u))
  let p2 = ir_load_input_at(sb, 0.0, ir_iadd(sb, base, c5u))
  let p3 = ir_load_input_at(sb, 0.0, ir_iadd(sb, base, c6u))
  let p4 = ir_load_input_at(sb, 0.0, ir_iadd(sb, base, c7u))

  // dx, dy, dz from ray point to object center
  let odx = ir_fsub(sb, rpx, ox)
  let ody = ir_fsub(sb, rpy, oy)
  let odz = ir_fsub(sb, rpz, oz)

  // Type 1: Sphere SDF = sqrt(dx²+dy²+dz²) - radius
  let s_dsq = ir_fadd(sb, ir_fmul(sb, odx, odx), ir_fadd(sb, ir_fmul(sb, ody, ody), ir_fmul(sb, odz, odz)))
  let s_dist = ir_fsub(sb, ir_sqrt(sb, s_dsq), p1)

  // Type 2: Box SDF = max(max(|dx|-hx, |dy|-hy), |dz|-hz)
  let bx = ir_fsub(sb, ir_fabs(sb, odx), p1)
  let by = ir_fsub(sb, ir_fabs(sb, ody), p2)
  let bz = ir_fsub(sb, ir_fabs(sb, odz), p3)
  let b_dist = ir_fmax(sb, ir_fmax(sb, bx, by), bz)

  // Type 3: Plane SDF = dot(point - origin, normal)
  let p_dist = ir_fadd(sb, ir_fmul(sb, odx, p1), ir_fadd(sb, ir_fmul(sb, ody, p2), ir_fmul(sb, odz, p3)))

  // Type 4: Cylinder SDF = max(sqrt(dx²+dz²) - radius, |dy| - height/2)
  // p1=radius, p2=height
  let cyl_xz = ir_sqrt(sb, ir_fadd(sb, ir_fmul(sb, odx, odx), ir_fmul(sb, odz, odz)))
  let cyl_rad = ir_fsub(sb, cyl_xz, p1)
  let cyl_vert = ir_fsub(sb, ir_fabs(sb, ody), ir_fmul(sb, p2, c_half))
  let cyl_dist = ir_fmax(sb, cyl_rad, cyl_vert)

  // Type 5: Torus SDF = sqrt((sqrt(dx²+dz²) - R)² + dy²) - r
  // p1=major R, p2=minor r
  let tor_q = ir_fsub(sb, cyl_xz, p1)
  let tor_dsq = ir_fadd(sb, ir_fmul(sb, tor_q, tor_q), ir_fmul(sb, ody, ody))
  let tor_dist = ir_fsub(sb, ir_sqrt(sb, tor_dsq), p2)

  // Type 6: Capsule SDF — project point onto line segment a→b, dist - radius
  // a=(ox,oy,oz), b=(p1,p2,p3), radius=p4
  // ba = b - a, pa = point - a
  let cap_bax = ir_fsub(sb, p1, ox)
  let cap_bay = ir_fsub(sb, p2, oy)
  let cap_baz = ir_fsub(sb, p3, oz)
  let cap_pax = ir_fsub(sb, rpx, ox)
  let cap_pay = ir_fsub(sb, rpy, oy)
  let cap_paz = ir_fsub(sb, rpz, oz)
  // t = clamp(dot(pa,ba)/dot(ba,ba), 0, 1)
  let cap_dot_pb = ir_fadd(sb, ir_fmul(sb, cap_pax, cap_bax), ir_fadd(sb, ir_fmul(sb, cap_pay, cap_bay), ir_fmul(sb, cap_paz, cap_baz)))
  let cap_dot_bb = ir_fadd(sb, ir_fmul(sb, cap_bax, cap_bax), ir_fadd(sb, ir_fmul(sb, cap_bay, cap_bay), ir_fmul(sb, cap_baz, cap_baz)))
  let cap_t_raw = ir_fdiv(sb, cap_dot_pb, ir_fmax(sb, cap_dot_bb, c_eps))
  let cap_t = ir_fmin(sb, ir_fmax(sb, cap_t_raw, c0f), c1f)
  // closest point on segment = a + t * ba
  let cap_cx = ir_fadd(sb, ox, ir_fmul(sb, cap_t, cap_bax))
  let cap_cy = ir_fadd(sb, oy, ir_fmul(sb, cap_t, cap_bay))
  let cap_cz = ir_fadd(sb, oz, ir_fmul(sb, cap_t, cap_baz))
  let cap_dx = ir_fsub(sb, rpx, cap_cx)
  let cap_dy = ir_fsub(sb, rpy, cap_cy)
  let cap_dz = ir_fsub(sb, rpz, cap_cz)
  let cap_dsq = ir_fadd(sb, ir_fmul(sb, cap_dx, cap_dx), ir_fadd(sb, ir_fmul(sb, cap_dy, cap_dy), ir_fmul(sb, cap_dz, cap_dz)))
  let cap_dist = ir_fsub(sb, ir_sqrt(sb, cap_dsq), p4)

  // Select distance by type: chain of selects (innermost = default/capsule)
  let is_t1 = ir_foeq(sb, obj_t, c1f)
  let is_t2 = ir_foeq(sb, obj_t, c2f)
  let is_t3 = ir_foeq(sb, obj_t, c_3f)
  let is_t4 = ir_foeq(sb, obj_t, c_4f)
  let is_t5 = ir_foeq(sb, obj_t, c_5f)
  let d_5_6 = ir_select(sb, IR_TYPE_FLOAT, is_t5, tor_dist, cap_dist)
  let d_4_6 = ir_select(sb, IR_TYPE_FLOAT, is_t4, cyl_dist, d_5_6)
  let d_3_6 = ir_select(sb, IR_TYPE_FLOAT, is_t3, p_dist, d_4_6)
  let d_2_6 = ir_select(sb, IR_TYPE_FLOAT, is_t2, b_dist, d_3_6)
  let obj_d = ir_select(sb, IR_TYPE_FLOAT, is_t1, s_dist, d_2_6)

  // Update min distance & closest
  let new_min = ir_fmin(sb, s_min, obj_d)
  let closer = ir_folt(sb, obj_d, s_min)
  let new_clo = ir_select(sb, IR_TYPE_FLOAT, closer, s_idx, s_clo)

  ir_term_branch(sb, sc)

  // SDF continue: increment
  let s_next = ir_fadd(sc, s_idx, c1f)
  ir_term_branch(sc, sh)

  // Wire SDF phi nodes
  ir_phi_add(s_idx, c0f, mb)
  ir_phi_add(s_idx, s_next, sc)
  ir_phi_add(s_min, c_big, mb)
  ir_phi_add(s_min, new_min, sc)
  ir_phi_add(s_clo, c0f, mb)
  ir_phi_add(s_clo, new_clo, sc)

  // ── After SDF eval: check hit ──────────────────────────
  // s_min is the min distance, s_clo is the closest object
  let is_h = ir_folt(sm, s_min, c_eps)
  let new_hit = ir_select(sm, IR_TYPE_FLOAT, is_h, c1f, c0f)
  let new_t = ir_fadd(sm, phi_t, s_min)
  let too_far = ir_fogt(sm, new_t, c_max_t)
  let exit_f = ir_select(sm, IR_TYPE_FLOAT, too_far, c1f, new_hit)

  ir_term_branch(sm, mc)

  // March continue
  let nxt_step = ir_fadd(mc, phi_step, c1f)
  ir_term_branch(mc, mh)

  // Wire march phi nodes
  ir_phi_add(phi_step, c0f, work)
  ir_phi_add(phi_step, nxt_step, mc)
  ir_phi_add(phi_t, c0f, work)
  ir_phi_add(phi_t, new_t, mc)
  ir_phi_add(phi_hit, c0f, work)
  ir_phi_add(phi_hit, exit_f, mc)
  ir_phi_add(phi_clo, c0f, work)
  ir_phi_add(phi_clo, s_clo, mc)

  // ── March Merge: Shade or Sky ──────────────────────────
  let did_hit = ir_fogt(mm, phi_hit, c_half)

  let shade_b = ir_block("shade")
  let sky_b = ir_block("sky")
  let final_m = ir_block("final_m")
  ir_selection_merge(mm, final_m)
  ir_term_cond_branch(mm, did_hit, shade_b, sky_b)

  // ── Shade Block ────────────────────────────────────────
  // Hit point
  let hx = ir_fadd(shade_b, pc_ex, ir_fmul(shade_b, phi_t, dx))
  let hy = ir_fadd(shade_b, pc_ey, ir_fmul(shade_b, phi_t, dy))
  let hz = ir_fadd(shade_b, pc_ez, ir_fmul(shade_b, phi_t, dz))

  // Read closest object data
  let cu = ir_ftou(shade_b, phi_clo)
  let cb_off = ir_imul(shade_b, cu, c16u)
  let ctype = ir_load_input_at(shade_b, 0.0, cb_off)
  let ccx = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c1u))
  let ccy = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c2u))
  let ccz = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c3u))
  let cp1 = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c4u))
  let cp2 = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c5u))
  let cp3 = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c6u))
  let cp4 = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c7u))
  let mr = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c8u))
  let mg = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c9u))
  let mbb = ir_load_input_at(shade_b, 0.0, ir_iadd(shade_b, cb_off, c10u))

  // ── Analytic Normals ──────────────────────────────────
  // Hit offset from object center
  let hdx = ir_fsub(shade_b, hx, ccx)
  let hdy = ir_fsub(shade_b, hy, ccy)
  let hdz = ir_fsub(shade_b, hz, ccz)

  // Type 1: Sphere normal = normalize(hit - center)
  let snl = ir_sqrt(shade_b, ir_fadd(shade_b, ir_fmul(shade_b, hdx, hdx), ir_fadd(shade_b, ir_fmul(shade_b, hdy, hdy), ir_fmul(shade_b, hdz, hdz))))
  let snli = ir_fdiv(shade_b, c1f, ir_fmax(shade_b, snl, c_eps))
  let snnx = ir_fmul(shade_b, hdx, snli)
  let snny = ir_fmul(shade_b, hdy, snli)
  let snnz = ir_fmul(shade_b, hdz, snli)

  // Type 2: Box normal = direction of largest |offset|/half component
  let adx = ir_fabs(shade_b, ir_fdiv(shade_b, hdx, ir_fmax(shade_b, cp1, c_eps)))
  let ady = ir_fabs(shade_b, ir_fdiv(shade_b, hdy, ir_fmax(shade_b, cp2, c_eps)))
  let adz = ir_fabs(shade_b, ir_fdiv(shade_b, hdz, ir_fmax(shade_b, cp3, c_eps)))
  let xdom = ir_land(shade_b, ir_foge(shade_b, adx, ady), ir_foge(shade_b, adx, adz))
  let ydom = ir_land(shade_b, ir_fogt(shade_b, ady, adx), ir_foge(shade_b, ady, adz))
  let bsgnx = ir_select(shade_b, IR_TYPE_FLOAT, ir_fogt(shade_b, hdx, c0f), c1f, c_n1f)
  let bsgny = ir_select(shade_b, IR_TYPE_FLOAT, ir_fogt(shade_b, hdy, c0f), c1f, c_n1f)
  let bsgnz = ir_select(shade_b, IR_TYPE_FLOAT, ir_fogt(shade_b, hdz, c0f), c1f, c_n1f)
  let bnx = ir_select(shade_b, IR_TYPE_FLOAT, xdom, bsgnx, c0f)
  let bny = ir_select(shade_b, IR_TYPE_FLOAT, ydom, bsgny, ir_select(shade_b, IR_TYPE_FLOAT, xdom, c0f, c0f))
  let bnz_cond = ir_land(shade_b, ir_foeq(shade_b, bnx, c0f), ir_foeq(shade_b, bny, c0f))
  let bnz = ir_select(shade_b, IR_TYPE_FLOAT, bnz_cond, bsgnz, c0f)

  // Type 3: Plane normal = (cp1, cp2, cp3) — already available

  // Type 4: Cylinder normal — radial or cap
  let cyl_rdx = hdx
  let cyl_rdz = hdz
  let cyl_rl = ir_sqrt(shade_b, ir_fadd(shade_b, ir_fmul(shade_b, cyl_rdx, cyl_rdx), ir_fmul(shade_b, cyl_rdz, cyl_rdz)))
  let cyl_rli = ir_fdiv(shade_b, c1f, ir_fmax(shade_b, cyl_rl, c_eps))
  // Radial normal: (dx/len, 0, dz/len)
  let cyl_rnx = ir_fmul(shade_b, cyl_rdx, cyl_rli)
  let cyl_rnz = ir_fmul(shade_b, cyl_rdz, cyl_rli)
  // Cap test: if |dy| > height/2 - eps, use cap normal
  let cyl_hh = ir_fmul(shade_b, cp2, c_half)
  let cyl_is_cap = ir_fogt(shade_b, ir_fabs(shade_b, hdy), ir_fsub(shade_b, cyl_hh, c_eps))
  let cyl_cap_sgn = ir_select(shade_b, IR_TYPE_FLOAT, ir_fogt(shade_b, hdy, c0f), c1f, c_n1f)
  let cylnx = ir_select(shade_b, IR_TYPE_FLOAT, cyl_is_cap, c0f, cyl_rnx)
  let cylny = ir_select(shade_b, IR_TYPE_FLOAT, cyl_is_cap, cyl_cap_sgn, c0f)
  let cylnz = ir_select(shade_b, IR_TYPE_FLOAT, cyl_is_cap, c0f, cyl_rnz)

  // Type 5: Torus normal = normalize(hit - closest_ring_point)
  // Ring point at angle of hit: (center + R * normalize(dx, 0, dz))
  let tor_rxn = ir_fmul(shade_b, cyl_rdx, cyl_rli)
  let tor_rzn = ir_fmul(shade_b, cyl_rdz, cyl_rli)
  let tor_rpx = ir_fadd(shade_b, ccx, ir_fmul(shade_b, cp1, tor_rxn))
  let tor_rpz = ir_fadd(shade_b, ccz, ir_fmul(shade_b, cp1, tor_rzn))
  let tor_nx_r = ir_fsub(shade_b, hx, tor_rpx)
  let tor_ny_r = hdy
  let tor_nz_r = ir_fsub(shade_b, hz, tor_rpz)
  let tor_nl = ir_sqrt(shade_b, ir_fadd(shade_b, ir_fmul(shade_b, tor_nx_r, tor_nx_r), ir_fadd(shade_b, ir_fmul(shade_b, tor_ny_r, tor_ny_r), ir_fmul(shade_b, tor_nz_r, tor_nz_r))))
  let tor_nli = ir_fdiv(shade_b, c1f, ir_fmax(shade_b, tor_nl, c_eps))
  let tornx = ir_fmul(shade_b, tor_nx_r, tor_nli)
  let torny = ir_fmul(shade_b, tor_ny_r, tor_nli)
  let tornz = ir_fmul(shade_b, tor_nz_r, tor_nli)

  // Type 6: Capsule normal = normalize(hit - closest_point_on_segment)
  // a=(ccx,ccy,ccz), b=(cp1,cp2,cp3), project hit onto segment
  let cap_bax2 = ir_fsub(shade_b, cp1, ccx)
  let cap_bay2 = ir_fsub(shade_b, cp2, ccy)
  let cap_baz2 = ir_fsub(shade_b, cp3, ccz)
  let cap_pax2 = ir_fsub(shade_b, hx, ccx)
  let cap_pay2 = ir_fsub(shade_b, hy, ccy)
  let cap_paz2 = ir_fsub(shade_b, hz, ccz)
  let cap_dp2 = ir_fadd(shade_b, ir_fmul(shade_b, cap_pax2, cap_bax2), ir_fadd(shade_b, ir_fmul(shade_b, cap_pay2, cap_bay2), ir_fmul(shade_b, cap_paz2, cap_baz2)))
  let cap_db2 = ir_fadd(shade_b, ir_fmul(shade_b, cap_bax2, cap_bax2), ir_fadd(shade_b, ir_fmul(shade_b, cap_bay2, cap_bay2), ir_fmul(shade_b, cap_baz2, cap_baz2)))
  let cap_t2 = ir_fmin(shade_b, ir_fmax(shade_b, ir_fdiv(shade_b, cap_dp2, ir_fmax(shade_b, cap_db2, c_eps)), c0f), c1f)
  let cap_qx = ir_fsub(shade_b, hx, ir_fadd(shade_b, ccx, ir_fmul(shade_b, cap_t2, cap_bax2)))
  let cap_qy = ir_fsub(shade_b, hy, ir_fadd(shade_b, ccy, ir_fmul(shade_b, cap_t2, cap_bay2)))
  let cap_qz = ir_fsub(shade_b, hz, ir_fadd(shade_b, ccz, ir_fmul(shade_b, cap_t2, cap_baz2)))
  let cap_ql = ir_sqrt(shade_b, ir_fadd(shade_b, ir_fmul(shade_b, cap_qx, cap_qx), ir_fadd(shade_b, ir_fmul(shade_b, cap_qy, cap_qy), ir_fmul(shade_b, cap_qz, cap_qz))))
  let cap_qli = ir_fdiv(shade_b, c1f, ir_fmax(shade_b, cap_ql, c_eps))
  let capnx = ir_fmul(shade_b, cap_qx, cap_qli)
  let capny = ir_fmul(shade_b, cap_qy, cap_qli)
  let capnz = ir_fmul(shade_b, cap_qz, cap_qli)

  // Select normal by type (chain: 1=sphere, 2=box, 3=plane, 4=cyl, 5=torus, 6=capsule)
  let iss = ir_foeq(shade_b, ctype, c1f)
  let isb = ir_foeq(shade_b, ctype, c2f)
  let isp = ir_foeq(shade_b, ctype, c_3f)
  let isc = ir_foeq(shade_b, ctype, c_4f)
  let ist = ir_foeq(shade_b, ctype, c_5f)
  // Default (type 6) = capsule
  let nx_56 = ir_select(shade_b, IR_TYPE_FLOAT, ist, tornx, capnx)
  let nx_46 = ir_select(shade_b, IR_TYPE_FLOAT, isc, cylnx, nx_56)
  let nx_36 = ir_select(shade_b, IR_TYPE_FLOAT, isp, cp1, nx_46)
  let nx_26 = ir_select(shade_b, IR_TYPE_FLOAT, isb, bnx, nx_36)
  let nx = ir_select(shade_b, IR_TYPE_FLOAT, iss, snnx, nx_26)
  let ny_56 = ir_select(shade_b, IR_TYPE_FLOAT, ist, torny, capny)
  let ny_46 = ir_select(shade_b, IR_TYPE_FLOAT, isc, cylny, ny_56)
  let ny_36 = ir_select(shade_b, IR_TYPE_FLOAT, isp, cp2, ny_46)
  let ny_26 = ir_select(shade_b, IR_TYPE_FLOAT, isb, bny, ny_36)
  let ny = ir_select(shade_b, IR_TYPE_FLOAT, iss, snny, ny_26)
  let nz_56 = ir_select(shade_b, IR_TYPE_FLOAT, ist, tornz, capnz)
  let nz_46 = ir_select(shade_b, IR_TYPE_FLOAT, isc, cylnz, nz_56)
  let nz_36 = ir_select(shade_b, IR_TYPE_FLOAT, isp, cp3, nz_46)
  let nz_26 = ir_select(shade_b, IR_TYPE_FLOAT, isb, bnz, nz_36)
  let nz = ir_select(shade_b, IR_TYPE_FLOAT, iss, snnz, nz_26)

  // Diffuse lighting from main light (push constants)
  let ldx = ir_fsub(shade_b, pc_lx, hx)
  let ldy = ir_fsub(shade_b, pc_ly, hy)
  let ldz = ir_fsub(shade_b, pc_lz, hz)
  let ll2 = ir_fadd(shade_b, ir_fmul(shade_b, ldx, ldx), ir_fadd(shade_b, ir_fmul(shade_b, ldy, ldy), ir_fmul(shade_b, ldz, ldz)))
  let lli = ir_fdiv(shade_b, c1f, ir_sqrt(shade_b, ll2))
  let lnx = ir_fmul(shade_b, ldx, lli)
  let lny = ir_fmul(shade_b, ldy, lli)
  let lnz = ir_fmul(shade_b, ldz, lli)

  let ndotl = ir_fadd(shade_b, ir_fmul(shade_b, nx, lnx), ir_fadd(shade_b, ir_fmul(shade_b, ny, lny), ir_fmul(shade_b, nz, lnz)))
  let diff = ir_fmax(shade_b, ndotl, c0f)

  // Final color = (ambient + diff * light) * material * 255
  let cr = ir_fmul(shade_b, ir_fadd(shade_b, ir_fmul(shade_b, pc_ar, mr), ir_fmul(shade_b, diff, ir_fmul(shade_b, pc_lr, mr))), c255)
  let cg = ir_fmul(shade_b, ir_fadd(shade_b, ir_fmul(shade_b, pc_ag, mg), ir_fmul(shade_b, diff, ir_fmul(shade_b, pc_lg, mg))), c255)
  let cbb = ir_fmul(shade_b, ir_fadd(shade_b, ir_fmul(shade_b, pc_ab, mbb), ir_fmul(shade_b, diff, ir_fmul(shade_b, pc_lb, mbb))), c255)

  // Clamp 0-255
  let fr = ir_fmin(shade_b, ir_fmax(shade_b, cr, c0f), c255)
  let fg = ir_fmin(shade_b, ir_fmax(shade_b, cg, c0f), c255)
  let fb = ir_fmin(shade_b, ir_fmax(shade_b, cbb, c0f), c255)

  // Write planar RGB
  let totu = ir_ftou(shade_b, pc_total)
  ir_store_output_at(shade_b, gid, fr)
  let goff = ir_iadd(shade_b, gid, totu)
  ir_store_output_at(shade_b, goff, fg)
  let boff = ir_iadd(shade_b, goff, totu)
  ir_store_output_at(shade_b, boff, fb)

  ir_term_branch(shade_b, final_m)

  // ── Sky Block ──────────────────────────────────────────
  let sky_t = ir_fdiv(sky_b, pyf, pc_h)
  let inv_st = ir_fsub(sky_b, c1f, sky_t)
  let c60 = ir_const_f(sky_b, 60.0)
  let c80 = ir_const_f(sky_b, 80.0)
  let c140 = ir_const_f(sky_b, 140.0)
  let c20 = ir_const_f(sky_b, 20.0)
  let c30 = ir_const_f(sky_b, 30.0)
  let c50 = ir_const_f(sky_b, 50.0)
  let sr = ir_fadd(sky_b, ir_fmul(sky_b, inv_st, c60), ir_fmul(sky_b, sky_t, c20))
  let sg = ir_fadd(sky_b, ir_fmul(sky_b, inv_st, c80), ir_fmul(sky_b, sky_t, c30))
  let sbb = ir_fadd(sky_b, ir_fmul(sky_b, inv_st, c140), ir_fmul(sky_b, sky_t, c50))

  let totu2 = ir_ftou(sky_b, pc_total)
  ir_store_output_at(sky_b, gid, sr)
  let goff2 = ir_iadd(sky_b, gid, totu2)
  ir_store_output_at(sky_b, goff2, sg)
  let boff2 = ir_iadd(sky_b, goff2, totu2)
  ir_store_output_at(sky_b, boff2, sbb)

  ir_term_branch(sky_b, final_m)

  // ── Final merge + return ───────────────────────────────
  ir_term_branch(final_m, main_m)
  ir_term_return(main_m)

  ir_emit_spirv(out_path)
  return 0.0
end
