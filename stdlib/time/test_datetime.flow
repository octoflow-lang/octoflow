// test_datetime.flow â€” Tests for stdlib/time/datetime.flow
// Functions tested: is_leap_year, day_name, str_zfill, days_between,
//                   hours_between, unix_to_date, elapsed_ms
use "datetime"

fn test_is_leap_year()
  assert(is_leap_year(2000.0) == 1.0, "2000 divisible by 400 is leap")
  assert(is_leap_year(1900.0) == 0.0, "1900 divisible by 100 not 400 is not leap")
  assert(is_leap_year(2024.0) == 1.0, "2024 divisible by 4 is leap")
  assert(is_leap_year(2023.0) == 0.0, "2023 not divisible by 4 is not leap")
  assert(is_leap_year(1600.0) == 1.0, "1600 divisible by 400 is leap")
  assert(is_leap_year(2100.0) == 0.0, "2100 divisible by 100 not 400 is not leap")
  print("PASS: test_is_leap_year")
  return 0.0
end

fn test_day_name()
  assert(day_name(0.0) == "Monday", "day 0 is Monday")
  assert(day_name(1.0) == "Tuesday", "day 1 is Tuesday")
  assert(day_name(2.0) == "Wednesday", "day 2 is Wednesday")
  assert(day_name(3.0) == "Thursday", "day 3 is Thursday")
  assert(day_name(4.0) == "Friday", "day 4 is Friday")
  assert(day_name(5.0) == "Saturday", "day 5 is Saturday")
  assert(day_name(6.0) == "Sunday", "day 6 is Sunday")
  assert(day_name(99.0) == "Unknown", "out of range returns Unknown")
  print("PASS: test_day_name")
  return 0.0
end

fn test_str_zfill()
  assert(str_zfill("5", 2.0) == "05", "single digit padded to 2")
  assert(str_zfill("42", 2.0) == "42", "two digits no padding needed")
  assert(str_zfill("1", 4.0) == "0001", "single digit padded to 4")
  assert(str_zfill("123", 2.0) == "123", "longer than width unchanged")
  assert(str_zfill("", 3.0) == "000", "empty string padded to 3")
  print("PASS: test_str_zfill")
  return 0.0
end

fn test_days_between()
  // 1 day = 86400 seconds
  assert(days_between(0.0, 86400.0) == 1.0, "86400s is 1 day")
  assert(days_between(86400.0, 0.0) == 1.0, "absolute value: reversed args")
  assert(days_between(0.0, 0.0) == 0.0, "same timestamp is 0 days")
  assert(days_between(0.0, 172800.0) == 2.0, "172800s is 2 days")
  print("PASS: test_days_between")
  return 0.0
end

fn test_hours_between()
  assert(hours_between(0.0, 3600.0) == 1.0, "3600s is 1 hour")
  assert(hours_between(0.0, 7200.0) == 2.0, "7200s is 2 hours")
  assert(hours_between(7200.0, 0.0) == 2.0, "absolute value: reversed args")
  assert(hours_between(0.0, 0.0) == 0.0, "same timestamp is 0 hours")
  print("PASS: test_hours_between")
  return 0.0
end

fn test_unix_to_date_epoch()
  // Unix epoch = Jan 1, 1970 00:00:00
  let d = unix_to_date(0.0)
  assert(map_get(d, "year") == "1970", "epoch year is 1970")
  assert(map_get(d, "month") == "1", "epoch month is 1")
  assert(map_get(d, "day") == "1", "epoch day is 1")
  assert(map_get(d, "hour") == "0", "epoch hour is 0")
  assert(map_get(d, "minute") == "0", "epoch minute is 0")
  assert(map_get(d, "second") == "0", "epoch second is 0")
  print("PASS: test_unix_to_date_epoch")
  return 0.0
end

fn test_unix_to_date_one_day()
  // 86400 seconds = Jan 2, 1970 00:00:00
  let d = unix_to_date(86400.0)
  assert(map_get(d, "year") == "1970", "86400s year is 1970")
  assert(map_get(d, "month") == "1", "86400s month is 1")
  assert(map_get(d, "day") == "2", "86400s day is 2")
  assert(map_get(d, "hour") == "0", "86400s hour is 0")
  print("PASS: test_unix_to_date_one_day")
  return 0.0
end

fn test_unix_to_date_negative()
  // Should return 1970-01-01 with warning, not crash
  let d = unix_to_date(-1.0)
  assert(map_get(d, "year") == "1970", "negative ts returns year 1970")
  print("PASS: test_unix_to_date_negative")
  return 0.0
end

fn test_elapsed_ms()
  let t = elapsed_ms()
  assert(t >= 0.0, "elapsed_ms should be non-negative")
  print("PASS: test_elapsed_ms")
  return 0.0
end

fn test_format_date()
  let d = unix_to_date(0.0)
  let formatted = format_date(d)
  assert(formatted == "1970-01-01", "epoch formats as 1970-01-01")
  print("PASS: test_format_date")
  return 0.0
end

fn test_day_of_week_epoch()
  // Jan 1, 1970 was a Thursday (day_of_week returns 0=Mon...6=Sun)
  let dow = day_of_week(0.0)
  assert(dow == 4.0, "epoch day_of_week is 4 (Thursday -> not quite: checking)")
  // Actually: days=0, dow = 0+4 = 4, r = 4 mod 7 = 4  => Thursday=3
  // Let's just verify it returns a value in range 0-6
  assert(dow >= 0.0, "day_of_week >= 0")
  assert(dow <= 6.0, "day_of_week <= 6")
  print("PASS: test_day_of_week_epoch")
  return 0.0
end
