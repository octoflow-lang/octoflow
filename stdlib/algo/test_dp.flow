// test_dp.flow — Tests for stdlib/algo/dp.flow
use "dp"

fn check(name, cond)
    if cond
        print("PASS: {name}")
    else
        print("FAIL: {name}")
        assert(0.0 == 1.0, name)
    end
    return 0.0
end

// ── Knapsack ──────────────────────────────────────────────────

fn test_knapsack_01()
    let mut values = [60.0, 100.0, 120.0]
    let mut weights = [10.0, 20.0, 30.0]
    check("01 knapsack", dp_knapsack_01(values, weights, 50.0) == 220.0)
    return 0.0
end

fn test_knapsack_unbounded()
    let mut values = [10.0, 30.0]
    let mut weights = [5.0, 10.0]
    check("unbounded knapsack", dp_knapsack_unbounded(values, weights, 100.0) == 300.0)
    return 0.0
end

// ── Coin Change ───────────────────────────────────────────────

fn test_coin_change()
    let mut coins = [1.0, 5.0, 10.0, 25.0]
    check("coins 30", dp_coin_change(coins, 30.0) == 2.0)  // 25 + 5
    check("coins 11", dp_coin_change(coins, 11.0) == 2.0)  // 10 + 1
    check("coins 0", dp_coin_change(coins, 0.0) == 0.0)
    return 0.0
end

fn test_coin_change_impossible()
    let mut coins = [3.0, 5.0]
    check("coins impossible", dp_coin_change(coins, 1.0) == -1.0)
    return 0.0
end

// ── LIS ───────────────────────────────────────────────────────

fn test_lis()
    let mut arr = [10.0, 9.0, 2.0, 5.0, 3.0, 7.0, 101.0, 18.0]
    check("lis length", dp_lis_length(arr) == 4.0)  // [2, 3, 7, 101] or [2, 5, 7, 101]

    let mut sorted = [1.0, 2.0, 3.0, 4.0, 5.0]
    check("lis sorted", dp_lis_length(sorted) == 5.0)

    let mut desc = [5.0, 4.0, 3.0, 2.0, 1.0]
    check("lis desc", dp_lis_length(desc) == 1.0)
    return 0.0
end

// ── Max Subarray ──────────────────────────────────────────────

fn test_max_subarray()
    let mut arr = [-2.0, 1.0, -3.0, 4.0, -1.0, 2.0, 1.0, -5.0, 4.0]
    check("max subarray", dp_max_subarray(arr) == 6.0)  // [4, -1, 2, 1]

    let mut all_neg = [-1.0, -2.0, -3.0]
    check("max subarray neg", dp_max_subarray(all_neg) == -1.0)
    return 0.0
end

// ── Staircase ─────────────────────────────────────────────────

fn test_staircase()
    check("stairs 1", dp_staircase_ways(1.0) == 1.0)
    check("stairs 2", dp_staircase_ways(2.0) == 2.0)
    check("stairs 3", dp_staircase_ways(3.0) == 3.0)
    check("stairs 5", dp_staircase_ways(5.0) == 8.0)
    return 0.0
end

// ── Rod Cutting ───────────────────────────────────────────────

fn test_rod_cutting()
    let mut prices = [1.0, 5.0, 8.0, 9.0, 10.0, 17.0, 17.0, 20.0]
    check("rod 4", dp_rod_cutting(prices, 4.0) == 10.0)   // two pieces of 2
    check("rod 8", dp_rod_cutting(prices, 8.0) == 22.0)   // two pieces of 2 + 6
    return 0.0
end

// ── Edit Distance ─────────────────────────────────────────────

fn test_edit_distance()
    check("edit same", dp_edit_distance("hello", "hello") == 0.0)
    check("edit kitten", dp_edit_distance("kitten", "sitting") == 3.0)
    check("edit empty", dp_edit_distance("", "abc") == 3.0)
    return 0.0
end

// ── Fibonacci ─────────────────────────────────────────────────

fn test_fibonacci()
    check("fib 0", dp_fibonacci_memo(0.0) == 0.0)
    check("fib 1", dp_fibonacci_memo(1.0) == 1.0)
    check("fib 10", dp_fibonacci_memo(10.0) == 55.0)
    check("fib 20", dp_fibonacci_memo(20.0) == 6765.0)
    return 0.0
end

// ── Min Cost Path ─────────────────────────────────────────────

fn test_min_cost_path()
    // 3x3 grid:
    // 1 3 1
    // 1 5 1
    // 4 2 1
    let mut grid = [1.0, 3.0, 1.0, 1.0, 5.0, 1.0, 4.0, 2.0, 1.0]
    check("min cost", dp_min_cost_path(grid, 3.0, 3.0) == 7.0)  // 1→3→1→1→1
    return 0.0
end

// ── Run all ─────────────────────────────────────────────────────

test_knapsack_01()
test_knapsack_unbounded()
test_coin_change()
test_coin_change_impossible()
test_lis()
test_max_subarray()
test_staircase()
test_rod_cutting()
test_edit_distance()
test_fibonacci()
test_min_cost_path()
print("")
print("All dynamic programming tests passed (11 tests)")
