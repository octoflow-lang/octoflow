// stdlib/compiler/eval.flow
// OctoFlow Self-Hosting Evaluator (Phase 50)
//
// Lexes + interprets a simple OctoFlow source file.
// Handles: let-decl (float/string), print with string values, if (skip-else).
//
// Implementation note: FlowGPU user functions receive snapshots of scalars,
// so mutable position tracking (cur) must be done at top level (inline).
//
// Usage:
//   FLOW_INPUT=program.flow octoflow run stdlib/compiler/eval.flow --allow-read

// ---- FFI EXTERN DECLARATIONS ────────────────────────────────────
// Must be at top so fopen is available for use-resolver file existence checks.
// Also used by the FFI dispatch engine when interpreting programs.

extern "msvcrt" {
    fn fopen(path: ptr, mode: ptr) -> ptr
    fn fclose(fp: ptr) -> u32
    fn fread(buf: ptr, sz: u32, cnt: u32, fp: ptr) -> u32
    fn fwrite(buf: ptr, sz: u32, cnt: u32, fp: ptr) -> u32
    fn fseek(fp: ptr, off: u32, orig: u32) -> u32
    fn ftell(fp: ptr) -> u32
    fn puts(s: ptr) -> u32
    fn remove(p: ptr) -> u32
}

extern "vulkan-1" {
    fn vkCreateInstance(pInfo: ptr, pAlloc: ptr, pInst: ptr) -> u32
    fn vkDestroyInstance(inst: handle, pAlloc: ptr)
    fn vkEnumeratePhysicalDevices(inst: handle, pCount: ptr, pDevs: ptr) -> u32
    fn vkGetPhysicalDeviceQueueFamilyProperties(dev: handle, pCount: ptr, pProps: ptr)
    fn vkGetPhysicalDeviceMemoryProperties(dev: handle, pProps: ptr)
    fn vkCreateDevice(phys: handle, pInfo: ptr, pAlloc: ptr, pDev: ptr) -> u32
    fn vkDestroyDevice(dev: handle, pAlloc: ptr)
    fn vkGetDeviceQueue(dev: handle, qfi: u32, qi: u32, pQueue: ptr)
    fn vkCreateBuffer(dev: handle, pInfo: ptr, pAlloc: ptr, pBuf: ptr) -> u32
    fn vkDestroyBuffer(dev: handle, buf: handle, pAlloc: ptr)
    fn vkGetBufferMemoryRequirements(dev: handle, buf: handle, pReqs: ptr)
    fn vkAllocateMemory(dev: handle, pInfo: ptr, pAlloc: ptr, pMem: ptr) -> u32
    fn vkFreeMemory(dev: handle, mem: handle, pAlloc: ptr)
    fn vkBindBufferMemory(dev: handle, buf: handle, mem: handle, off: u64) -> u32
    fn vkMapMemory(dev: handle, mem: handle, off: u64, sz: u64, flags: u32, ppData: ptr) -> u32
    fn vkUnmapMemory(dev: handle, mem: handle)
    fn vkCreateShaderModule(dev: handle, pInfo: ptr, pAlloc: ptr, pMod: ptr) -> u32
    fn vkDestroyShaderModule(dev: handle, smod: handle, pAlloc: ptr)
    fn vkCreateDescriptorSetLayout(dev: handle, pInfo: ptr, pAlloc: ptr, pLay: ptr) -> u32
    fn vkDestroyDescriptorSetLayout(dev: handle, lay: handle, pAlloc: ptr)
    fn vkCreatePipelineLayout(dev: handle, pInfo: ptr, pAlloc: ptr, pLay: ptr) -> u32
    fn vkDestroyPipelineLayout(dev: handle, lay: handle, pAlloc: ptr)
    fn vkCreateComputePipelines(dev: handle, pcache: handle, cnt: u32, pInfos: ptr, pAlloc: ptr, pPipes: ptr) -> u32
    fn vkDestroyPipeline(dev: handle, pipe: handle, pAlloc: ptr)
    fn vkCreateDescriptorPool(dev: handle, pInfo: ptr, pAlloc: ptr, pPool: ptr) -> u32
    fn vkDestroyDescriptorPool(dev: handle, pool: handle, pAlloc: ptr)
    fn vkAllocateDescriptorSets(dev: handle, pInfo: ptr, pSets: ptr) -> u32
    fn vkUpdateDescriptorSets(dev: handle, wCnt: u32, pWrites: ptr, cCnt: u32, pCopies: ptr)
    fn vkCreateCommandPool(dev: handle, pInfo: ptr, pAlloc: ptr, pPool: ptr) -> u32
    fn vkDestroyCommandPool(dev: handle, pool: handle, pAlloc: ptr)
    fn vkAllocateCommandBuffers(dev: handle, pInfo: ptr, pBufs: ptr) -> u32
    fn vkFreeCommandBuffers(dev: handle, pool: handle, cnt: u32, pBufs: ptr)
    fn vkBeginCommandBuffer(cmd: handle, pInfo: ptr) -> u32
    fn vkEndCommandBuffer(cmd: handle) -> u32
    fn vkCmdBindPipeline(cmd: handle, bp: u32, pipe: handle)
    fn vkCmdBindDescriptorSets(cmd: handle, bp: u32, lay: handle, fs: u32, cnt: u32, pSets: ptr, dc: u32, pOff: ptr)
    fn vkCmdDispatch(cmd: handle, gx: u32, gy: u32, gz: u32)
    fn vkCreateFence(dev: handle, pInfo: ptr, pAlloc: ptr, pFence: ptr) -> u32
    fn vkDestroyFence(dev: handle, fence: handle, pAlloc: ptr)
    fn vkQueueSubmit(queue: handle, cnt: u32, pSubmits: ptr, fence: handle) -> u32
    fn vkWaitForFences(dev: handle, cnt: u32, pFences: ptr, waitAll: u32, timeout: u64) -> u32
}

// ---- LEXER (inline) -----------------------------------------------
// EVAL_PROG_PATH overrides FLOW_INPUT so the interpreted program can use FLOW_INPUT itself
let ep_path = env("EVAL_PROG_PATH")
let fi_path = env("FLOW_INPUT")
let mut input_path = ep_path
if len(ep_path) == 0.0
  input_path = fi_path
end
// Read source and resolve 'use' imports by prepending module source
let raw_lines = read_lines(input_path)
let raw_count = len(raw_lines)

// Extract script directory for relative use resolution
let mut script_dir = ""
let mut sdi = len(input_path) - 1.0
while sdi >= 0.0
  let sdc = char_at(input_path, sdi)
  if sdc == "/" || sdc == "\"
    script_dir = char_at(input_path, 0.0)
    let mut sdj = 1.0
    while sdj <= sdi
      script_dir = script_dir + char_at(input_path, sdj)
      sdj = sdj + 1.0
    end
    sdi = 0.0 - 1.0
  end
  sdi = sdi - 1.0
end

// Build src_lines: module sources first, then main source (use lines blanked)
let mut src_lines = []
// Pass 1: find and load modules
let mut ux = 0.0
while ux < raw_count
  let uline = raw_lines[ux]
  let utrim = trim(uline)
  if starts_with(utrim, "use ")
    let uparts = split(utrim, " ")
    let umod_clean = uparts[1]
    // Try script-relative first, then stdlib/
    let upath_local = script_dir + umod_clean + ".flow"
    let upath_stdlib = "stdlib/" + umod_clean + ".flow"
    // Check which path exists using fopen
    let mut use_path = upath_stdlib
    let ck_p = mem_from_str(upath_local)
    let ck_m = mem_from_str("rb")
    let ck_fp = fopen(ck_p, ck_m)
    mem_free(ck_p)
    mem_free(ck_m)
    if ck_fp != 0.0
      let _ck_c = fclose(ck_fp)
      use_path = upath_local
    end
    let mlines = read_lines(use_path)
    let mc = len(mlines)
    let mut mx = 0.0
    while mx < mc
      push(src_lines, mlines[mx])
      mx = mx + 1.0
    end
  end
  ux = ux + 1.0
end
// Pass 2: add main source lines (replace 'use' with blank)
ux = 0.0
while ux < raw_count
  let uline2 = raw_lines[ux]
  let utrim2 = trim(uline2)
  if starts_with(utrim2, "use ")
    push(src_lines, "")
  else
    push(src_lines, uline2)
  end
  ux = ux + 1.0
end

let lines_count = len(src_lines)
let mut lpos = 0.0
let mut tok_types = []
let mut tok_values = []

let mut kw_set = map()
map_set(kw_set, "let", 1.0)
map_set(kw_set, "mut", 1.0)
map_set(kw_set, "fn", 1.0)
map_set(kw_set, "end", 1.0)
map_set(kw_set, "if", 1.0)
map_set(kw_set, "elif", 1.0)
map_set(kw_set, "else", 1.0)
map_set(kw_set, "while", 1.0)
map_set(kw_set, "for", 1.0)
map_set(kw_set, "in", 1.0)
map_set(kw_set, "return", 1.0)
map_set(kw_set, "break", 1.0)
map_set(kw_set, "continue", 1.0)
map_set(kw_set, "stream", 1.0)
map_set(kw_set, "emit", 1.0)
map_set(kw_set, "print", 1.0)
map_set(kw_set, "use", 1.0)
map_set(kw_set, "struct", 1.0)
map_set(kw_set, "extern", 1.0)
map_set(kw_set, "then", 1.0)
map_set(kw_set, "push", 1.0)
map_set(kw_set, "map_set", 1.0)

let TAB = 9.0
let QT = 34.0
let SP = 32.0

let mut li = 0.0
while li < lines_count
  let line = src_lines[li]
  let line_len = len(line)
  lpos = 0.0
  while lpos < line_len
    let lc = char_at(line, lpos)
    let lco = ord(lc)
    if lco == SP || lco == TAB
      lpos = lpos + 1.0
    elif lc == "/" && lpos + 1.0 < line_len && char_at(line, lpos + 1.0) == "/"
      lpos = line_len
    elif lco >= 48.0 && lco <= 57.0
      let mut lnum = ""
      while lpos < line_len && contains("0123456789.", char_at(line, lpos))
        lnum = lnum + char_at(line, lpos)
        lpos = lpos + 1.0
      end
      push(tok_types, "float")
      push(tok_values, lnum)
    elif lco == QT
      lpos = lpos + 1.0
      let mut lstr = ""
      while lpos < line_len && ord(char_at(line, lpos)) != QT
        lstr = lstr + char_at(line, lpos)
        lpos = lpos + 1.0
      end
      if lpos < line_len
        lpos = lpos + 1.0
      end
      push(tok_types, "str")
      push(tok_values, lstr)
    elif contains("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", lc)
      let mut lword = ""
      while lpos < line_len && contains("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789", char_at(line, lpos))
        lword = lword + char_at(line, lpos)
        lpos = lpos + 1.0
      end
      if map_has(kw_set, lword)
        push(tok_types, "kw")
      else
        push(tok_types, "ident")
      end
      push(tok_values, lword)
    elif lpos + 1.0 < line_len
      let lc2 = char_at(line, lpos + 1.0)
      if lc == "=" && lc2 == "="
        push(tok_types, "op")
        push(tok_values, "==")
        lpos = lpos + 2.0
      elif lc == "!" && lc2 == "="
        push(tok_types, "op")
        push(tok_values, "!=")
        lpos = lpos + 2.0
      elif lc == "<" && lc2 == "="
        push(tok_types, "op")
        push(tok_values, "<=")
        lpos = lpos + 2.0
      elif lc == ">" && lc2 == "="
        push(tok_types, "op")
        push(tok_values, ">=")
        lpos = lpos + 2.0
      elif lc == "|" && lc2 == ">"
        push(tok_types, "op")
        push(tok_values, "|>")
        lpos = lpos + 2.0
      elif lc == "&" && lc2 == "&"
        push(tok_types, "op")
        push(tok_values, "&&")
        lpos = lpos + 2.0
      elif lc == "|" && lc2 == "|"
        push(tok_types, "op")
        push(tok_values, "||")
        lpos = lpos + 2.0
      else
        push(tok_types, "op")
        push(tok_values, lc)
        lpos = lpos + 1.0
      end
    else
      push(tok_types, "op")
      push(tok_values, lc)
      lpos = lpos + 1.0
    end
  end
  push(tok_types, "nl")
  push(tok_values, "NL")
  li = li + 1.0
end
push(tok_types, "eof")
push(tok_values, "EOF")

let tok_count = len(tok_types)

// (FFI extern declarations moved to top of file for use resolver access)

// Set of known extern function names for dispatch
let mut ffi_fns = map()
map_set(ffi_fns, "fopen", 2.0)
map_set(ffi_fns, "fclose", 1.0)
map_set(ffi_fns, "fread", 4.0)
map_set(ffi_fns, "fwrite", 4.0)
map_set(ffi_fns, "fseek", 3.0)
map_set(ffi_fns, "ftell", 1.0)
map_set(ffi_fns, "puts", 1.0)
map_set(ffi_fns, "remove", 1.0)
map_set(ffi_fns, "vkCreateInstance", 3.0)
map_set(ffi_fns, "vkDestroyInstance", 2.0)
map_set(ffi_fns, "vkEnumeratePhysicalDevices", 3.0)
map_set(ffi_fns, "vkGetPhysicalDeviceQueueFamilyProperties", 3.0)
map_set(ffi_fns, "vkGetPhysicalDeviceMemoryProperties", 2.0)
map_set(ffi_fns, "vkCreateDevice", 4.0)
map_set(ffi_fns, "vkDestroyDevice", 2.0)
map_set(ffi_fns, "vkGetDeviceQueue", 4.0)
map_set(ffi_fns, "vkCreateBuffer", 4.0)
map_set(ffi_fns, "vkDestroyBuffer", 3.0)
map_set(ffi_fns, "vkGetBufferMemoryRequirements", 3.0)
map_set(ffi_fns, "vkAllocateMemory", 4.0)
map_set(ffi_fns, "vkFreeMemory", 3.0)
map_set(ffi_fns, "vkBindBufferMemory", 4.0)
map_set(ffi_fns, "vkMapMemory", 6.0)
map_set(ffi_fns, "vkUnmapMemory", 2.0)
map_set(ffi_fns, "vkCreateShaderModule", 4.0)
map_set(ffi_fns, "vkDestroyShaderModule", 3.0)
map_set(ffi_fns, "vkCreateDescriptorSetLayout", 4.0)
map_set(ffi_fns, "vkDestroyDescriptorSetLayout", 3.0)
map_set(ffi_fns, "vkCreatePipelineLayout", 4.0)
map_set(ffi_fns, "vkDestroyPipelineLayout", 3.0)
map_set(ffi_fns, "vkCreateComputePipelines", 6.0)
map_set(ffi_fns, "vkDestroyPipeline", 3.0)
map_set(ffi_fns, "vkCreateDescriptorPool", 4.0)
map_set(ffi_fns, "vkDestroyDescriptorPool", 3.0)
map_set(ffi_fns, "vkAllocateDescriptorSets", 3.0)
map_set(ffi_fns, "vkUpdateDescriptorSets", 5.0)
map_set(ffi_fns, "vkCreateCommandPool", 4.0)
map_set(ffi_fns, "vkDestroyCommandPool", 3.0)
map_set(ffi_fns, "vkAllocateCommandBuffers", 3.0)
map_set(ffi_fns, "vkBeginCommandBuffer", 2.0)
map_set(ffi_fns, "vkEndCommandBuffer", 1.0)
map_set(ffi_fns, "vkCmdBindPipeline", 3.0)
map_set(ffi_fns, "vkCmdBindDescriptorSets", 8.0)
map_set(ffi_fns, "vkCmdDispatch", 4.0)
map_set(ffi_fns, "vkCreateFence", 4.0)
map_set(ffi_fns, "vkDestroyFence", 3.0)
map_set(ffi_fns, "vkQueueSubmit", 4.0)
map_set(ffi_fns, "vkWaitForFences", 5.0)

// ---- EVALUATOR (inline) ----------------------------------------
// Variable environment: scalars in env_num (map), strings in env_s (map)
let mut env_num = map()
let mut env_s   = map()
// Arrays: SEP-delimited content in env_s["__arr_name"], length in env_num["__len_name"]
// SEP = chr(1) avoids collision with token values containing "|" (e.g. "||", "|>")
// Maps:   flat compound keys env_num["__map_m.k"] / env_s["__map_m.k"]
let SEP = chr(1)
// Stage 6: shadow EVAL_PROG_PATH so inner interpreters fall back to FLOW_INPUT
// When outer eval.flow interprets inner eval.flow, the inner's env("EVAL_PROG_PATH")
// call is intercepted and returns "" (from the shadow), preventing infinite recursion.
let evpp_shadow = env("EVAL_PROG_PATH")
if len(evpp_shadow) > 0.0
  map_set(env_s, "__env_EVAL_PROG_PATH", "")
end

// Token cursor
let mut cur = 0.0

// Control stack for while/if nesting (needed for while jump-back)
let mut cstack_type = []
let mut cstack_pos  = []

// Function registry: name → token index of first body token (after newline post-fn-header)
// fn_params[name] stores space-separated param names
// fn_locals[name] stores space-separated local variable names (for scope save/restore)
let mut fn_start = map()
let mut fn_params = map()
let mut fn_locals = map()

// Pre-scan: register all fn definitions before executing
let mut fscan = 0.0
while fscan < tok_count
  // skip extern blocks — fn declarations inside them are FFI, not user-defined
  if tok_types[fscan] == "kw" && tok_values[fscan] == "extern"
    while fscan < tok_count && tok_values[fscan] != "}"
      fscan = fscan + 1.0
    end
    fscan = fscan + 1.0
  elif tok_types[fscan] == "kw" && tok_values[fscan] == "fn"
    fscan = fscan + 1.0
    let fname = tok_values[fscan]
    fscan = fscan + 1.0
    // skip ( params )
    let mut fparams = ""
    if tok_types[fscan] == "op" && tok_values[fscan] == "("
      fscan = fscan + 1.0
      while fscan < tok_count && tok_values[fscan] != ")"
        if tok_types[fscan] == "ident"
          if len(fparams) > 0.0
            fparams = fparams + " "
          end
          fparams = fparams + tok_values[fscan]
        end
        fscan = fscan + 1.0
      end
      // skip )
      if fscan < tok_count
        fscan = fscan + 1.0
      end
    end
    // skip newline(s) to reach body start
    while fscan < tok_count && tok_types[fscan] == "nl"
      fscan = fscan + 1.0
    end
    map_set(fn_start, fname, fscan)
    map_set(fn_params, fname, fparams)
    // scan body to collect local variable names (for recursive save/restore)
    let mut flocals = ""
    let mut fdepth = 1.0
    let mut flscan = fscan
    while flscan < tok_count && fdepth > 0.0
      if tok_types[flscan] == "kw" && tok_values[flscan] == "end"
        fdepth = fdepth - 1.0
      elif tok_types[flscan] == "kw" && (tok_values[flscan] == "if" || tok_values[flscan] == "while" || tok_values[flscan] == "for" || tok_values[flscan] == "fn")
        fdepth = fdepth + 1.0
      elif tok_types[flscan] == "kw" && tok_values[flscan] == "let"
        let mut flnxt = flscan + 1.0
        if flnxt < tok_count && tok_types[flnxt] == "kw" && tok_values[flnxt] == "mut"
          flnxt = flnxt + 1.0
        end
        if flnxt < tok_count && tok_types[flnxt] == "ident"
          let flname = tok_values[flnxt]
          if len(flocals) > 0.0
            flocals = flocals + " "
          end
          flocals = flocals + flname
        end
      end
      flscan = flscan + 1.0
    end
    map_set(fn_locals, fname, flocals)
  else
    fscan = fscan + 1.0
  end
end

// call_dest: destination variable names for fn return values
let mut call_dest = []

// Save stack for function call scope isolation (recursive calls)
// Before calling a function, save caller's values for param names.
// After return, restore them so recursive calls don't clobber outer scope.
let mut save_stack_names = []
let mut save_stack_nums  = []
let mut save_stack_strs  = []
let mut save_stack_count = []

// Skip newlines
while cur < tok_count && tok_types[cur] == "nl"
  cur = cur + 1.0
end

while cur < tok_count
  let tt = tok_types[cur]
  let tv = tok_values[cur]

  // Skip newlines and whitespace-like tokens
  if tt == "nl"
    cur = cur + 1.0

  elif tt == "eof"
    cur = tok_count

  // fn name(params) ... end  — skip body during normal execution
  elif tt == "kw" && tv == "fn"
    let mut fdepth = 1.0
    cur = cur + 1.0  // skip fn name
    cur = cur + 1.0  // skip fn name token
    // skip to matching end
    while cur < tok_count && fdepth > 0.0
      let fst = tok_types[cur]
      let fsv = tok_values[cur]
      cur = cur + 1.0
      if fst == "kw" && (fsv == "if" || fsv == "while" || fsv == "for" || fsv == "fn")
        fdepth = fdepth + 1.0
      end
      if fst == "kw" && fsv == "end"
        fdepth = fdepth - 1.0
      end
    end

  // return val — store __ret and jump back via fn frame in cstack
  elif tt == "kw" && tv == "return"
    cur = cur + 1.0
    let rret_t = tok_types[cur]
    let rret_v = tok_values[cur]
    cur = cur + 1.0
    // resolve first value
    let mut rret_num = 0.0
    let mut rret_str = ""
    let mut rret_is_str = 0.0
    if rret_t == "float"
      rret_num = float(rret_v)
      rret_str = rret_v
    elif rret_t == "str"
      rret_str = rret_v
      rret_is_str = 1.0
    elif rret_t == "ident"
      if map_has(env_num, rret_v)
        rret_num = map_get(env_num, rret_v)
      end
      if map_has(env_s, rret_v)
        rret_str = map_get(env_s, rret_v)
      end
      if map_has(env_s, rret_v) && map_has(env_num, rret_v) == 0.0
        rret_is_str = 1.0
      end
    end
    // check for expression: return val OP val [OP val ...]
    if cur < tok_count && (tok_values[cur] == "+" || tok_values[cur] == "-" || tok_values[cur] == "*" || tok_values[cur] == "/")
      if rret_is_str == 1.0 && tok_values[cur] == "+"
        // string concatenation in return
        while cur < tok_count && tok_values[cur] == "+"
          cur = cur + 1.0
          let rsc_v = tok_values[cur]
          let rsc_t = tok_types[cur]
          cur = cur + 1.0
          let mut rsc_s = rsc_v
          if rsc_t == "ident" && map_has(env_s, rsc_v)
            rsc_s = map_get(env_s, rsc_v)
          end
          rret_str = rret_str + rsc_s
        end
      else
        // numeric expression with operator precedence
        let mut rx_v = []
        let mut rx_o = []
        push(rx_v, str(rret_num))
        while cur < tok_count && (tok_values[cur] == "+" || tok_values[cur] == "-" || tok_values[cur] == "*" || tok_values[cur] == "/")
          push(rx_o, tok_values[cur])
          cur = cur + 1.0
          let rxv = tok_values[cur]
          let rxt = tok_types[cur]
          cur = cur + 1.0
          let mut rxf = 0.0
          if rxt == "float"
            rxf = float(rxv)
          elif rxt == "ident" && map_has(env_num, rxv)
            rxf = map_get(env_num, rxv)
          end
          push(rx_v, str(rxf))
        end
        // Pass 1: * and /
        let mut rp1_v = []
        let mut rp1_o = []
        push(rp1_v, rx_v[0])
        let mut rxi = 0.0
        while rxi < len(rx_o)
          let rxop = rx_o[rxi]
          let rxni = rxi + 1.0
          if rxop == "*" || rxop == "/"
            let rp1_last = float(rp1_v[len(rp1_v) - 1.0])
            let rp1_right = float(rx_v[rxni])
            let mut rp1_res = 0.0
            if rxop == "*"
              rp1_res = rp1_last * rp1_right
            else
              rp1_res = rp1_last / rp1_right
            end
            pop(rp1_v)
            push(rp1_v, str(rp1_res))
          else
            push(rp1_o, rxop)
            push(rp1_v, rx_v[rxni])
          end
          rxi = rxi + 1.0
        end
        // Pass 2: + and -
        rret_num = float(rp1_v[0])
        let mut rxi2 = 0.0
        while rxi2 < len(rp1_o)
          let rp2_op = rp1_o[rxi2]
          let rp2_ni = rxi2 + 1.0
          let rp2_rv = float(rp1_v[rp2_ni])
          if rp2_op == "+"
            rret_num = rret_num + rp2_rv
          elif rp2_op == "-"
            rret_num = rret_num - rp2_rv
          end
          rxi2 = rxi2 + 1.0
        end
        rret_str = str(rret_num)
        rret_is_str = 0.0
      end
    end
    // store return value in env
    if rret_is_str == 1.0
      map_set(env_s, "__ret", rret_str)
    else
      map_set(env_num, "__ret", rret_num)
      map_set(env_s, "__ret", rret_str)
    end
    // pop frames from cstack until we find the "fn" frame
    let mut ret_found = 0.0
    while len(cstack_type) > 0.0 && ret_found == 0.0
      let ret_frame = pop(cstack_type)
      let ret_p = pop(cstack_pos)
      if ret_frame == "fn"
        let mut ret_vname = ""
        if len(call_dest) > 0.0
          ret_vname = pop(call_dest)
          if map_has(env_num, "__ret")
            map_set(env_num, ret_vname, map_get(env_num, "__ret"))
          end
          if map_has(env_s, "__ret")
            map_set(env_s, ret_vname, map_get(env_s, "__ret"))
          end
        end
        // restore caller's saved values (scope isolation for recursion)
        // Skip ret_vname — it just received the return value, don't overwrite it
        if len(save_stack_count) > 0.0
          let mut rc = float(pop(save_stack_count))
          while rc > 0.0
            let rn = pop(save_stack_names)
            let rv = pop(save_stack_nums)
            let rs = pop(save_stack_strs)
            if rn != ret_vname
              map_set(env_num, rn, float(rv))
              map_set(env_s, rn, rs)
            end
            rc = rc - 1.0
          end
        end
        cur = ret_p
        ret_found = 1.0
      end
    end
    if ret_found == 0.0
      cur = tok_count
    end

  // let [mut] name = value
  elif tt == "kw" && tv == "let"
    cur = cur + 1.0
    // skip optional mut
    if tok_types[cur] == "kw" && tok_values[cur] == "mut"
      cur = cur + 1.0
    end
    let vname = tok_values[cur]
    cur = cur + 1.0
    // skip =
    cur = cur + 1.0
    // read rhs token
    let rtt = tok_types[cur]
    let rtv = tok_values[cur]
    cur = cur + 1.0
    // check for user-defined function call: let x = fname(args)
    if rtt == "ident" && map_has(fn_start, rtv) && cur < tok_count && tok_values[cur] == "("
      let call_fname = rtv
      cur = cur + 1.0  // skip (
      // collect args with inline expression evaluation
      let mut call_args = []
      let mut call_argt = []
      while cur < tok_count && tok_values[cur] != ")"
        let cct = tok_types[cur]
        let ccv = tok_values[cur]
        if cct == "ident" || cct == "float" || cct == "str"
          let cnxt = cur + 1.0
          if cnxt < tok_count && (tok_values[cnxt] == "+" || tok_values[cnxt] == "-" || tok_values[cnxt] == "*" || tok_values[cnxt] == "/")
            let cop = tok_values[cnxt]
            let cnxt2 = cnxt + 1.0
            if cnxt2 < tok_count && (tok_types[cnxt2] == "ident" || tok_types[cnxt2] == "float")
              let mut clhs = 0.0
              if cct == "float"
                clhs = float(ccv)
              elif map_has(env_num, ccv)
                clhs = map_get(env_num, ccv)
              end
              let crv = tok_values[cnxt2]
              let mut crhs = 0.0
              if tok_types[cnxt2] == "float"
                crhs = float(crv)
              elif map_has(env_num, crv)
                crhs = map_get(env_num, crv)
              end
              let mut cexpr = 0.0
              if cop == "+"
                cexpr = clhs + crhs
              elif cop == "-"
                cexpr = clhs - crhs
              elif cop == "*"
                cexpr = clhs * crhs
              elif cop == "/"
                cexpr = clhs / crhs
              end
              push(call_args, str(cexpr))
              push(call_argt, "float")
              cur = cnxt2 + 1.0
            else
              push(call_args, ccv)
              push(call_argt, cct)
              cur = cur + 1.0
            end
          else
            push(call_args, ccv)
            push(call_argt, cct)
            cur = cur + 1.0
          end
        else
          cur = cur + 1.0
        end
      end
      if cur < tok_count
        cur = cur + 1.0  // skip )
      end
      // bind args to params
      let raw_params = map_get(fn_params, call_fname)
      let pnames = split(raw_params, " ")
      let nparams = len(pnames)
      let nargs = len(call_args)
      // save caller's values for params AND callee locals (scope isolation)
      let mut save_cnt = 0.0
      let mut si = 0.0
      while si < nparams
        let sp = pnames[si]
        if map_has(env_num, sp)
          push(save_stack_names, sp)
          push(save_stack_nums, str(map_get(env_num, sp)))
          if map_has(env_s, sp)
            push(save_stack_strs, map_get(env_s, sp))
          else
            push(save_stack_strs, "")
          end
          save_cnt = save_cnt + 1.0
        end
        si = si + 1.0
      end
      // also save callee's local var names (they clobber caller's same-named vars)
      if map_has(fn_locals, call_fname)
        let callee_locals = split(map_get(fn_locals, call_fname), " ")
        let mut cli = 0.0
        while cli < len(callee_locals)
          let cl = callee_locals[cli]
          if map_has(env_num, cl)
            push(save_stack_names, cl)
            push(save_stack_nums, str(map_get(env_num, cl)))
            if map_has(env_s, cl)
              push(save_stack_strs, map_get(env_s, cl))
            else
              push(save_stack_strs, "")
            end
            save_cnt = save_cnt + 1.0
          end
          cli = cli + 1.0
        end
      end
      push(save_stack_count, str(save_cnt))
      let mut pi = 0.0
      while pi < nparams && pi < nargs
        let pn = pnames[pi]
        let av = call_args[pi]
        let at = call_argt[pi]
        if at == "str"
          map_set(env_s, pn, av)
        elif is_match(av, "^[0-9]") || is_match(av, "^-[0-9]")
          let af = float(av)
          map_set(env_num, pn, af)
          map_set(env_s, pn, av)
        else
          if map_has(env_num, av)
            map_set(env_num, pn, map_get(env_num, av))
          end
          if map_has(env_s, av)
            map_set(env_s, pn, map_get(env_s, av))
          end
          // forward arrays: alias param to original array (pass-by-reference)
          let av_akey = "__arr_" + av
          if map_has(env_s, av_akey)
            let pn_alias = "__arr_alias_" + pn
            map_set(env_s, pn_alias, av)
            let pn_akey = "__arr_" + pn
            let pn_lkey = "__len_" + pn
            let av_lkey = "__len_" + av
            map_set(env_s, pn_akey, map_get(env_s, av_akey))
            if map_has(env_num, av_lkey)
              map_set(env_num, pn_lkey, map_get(env_num, av_lkey))
            end
          end
          // forward maps: alias param to original map
          let av_mmark = "__map_" + av
          if map_has(env_s, av_mmark)
            let pn_malias = "__map_alias_" + pn
            map_set(env_s, pn_malias, av)
            let pn_mmark = "__map_" + pn
            map_set(env_s, pn_mmark, "exists")
          end
        end
        pi = pi + 1.0
      end
      // push fn frame: return address (cur) and dest variable name
      push(cstack_type, "fn")
      push(cstack_pos, cur)
      push(call_dest, vname)
      // jump to function body
      cur = map_get(fn_start, call_fname)
    // array literal: let arr = [] or let arr = [1.0, 2.0, ...]
    elif rtt == "op" && rtv == "["
      let mut al_elems = []
      while cur < tok_count && tok_values[cur] != "]"
        let al_t = tok_types[cur]
        let al_v = tok_values[cur]
        if al_t == "float" || al_t == "str"
          push(al_elems, al_v)
        elif al_t == "ident"
          if map_has(env_s, al_v)
            push(al_elems, map_get(env_s, al_v))
          elif map_has(env_num, al_v)
            push(al_elems, str(map_get(env_num, al_v)))
          else
            push(al_elems, al_v)
          end
        end
        cur = cur + 1.0
      end
      if cur < tok_count && tok_values[cur] == "]"
        cur = cur + 1.0
      end
      let arr_key = "__arr_" + vname
      let len_key = "__len_" + vname
      if len(al_elems) > 0.0
        map_set(env_s, arr_key, join(al_elems, SEP))
      else
        map_set(env_s, arr_key, "")
      end
      map_set(env_num, len_key, len(al_elems))
    // map constructor: let m = map()
    elif rtt == "ident" && rtv == "map" && cur < tok_count && tok_values[cur] == "("
      cur = cur + 1.0  // skip (
      if cur < tok_count && tok_values[cur] == ")"
        cur = cur + 1.0
      end
      let map_mark = "__map_" + vname
      map_set(env_s, map_mark, "exists")
    // array indexing: let x = arr[idx]
    elif rtt == "ident" && cur < tok_count && tok_values[cur] == "["
      cur = cur + 1.0  // skip [
      let aidx_t = tok_types[cur]
      let aidx_v = tok_values[cur]
      cur = cur + 1.0
      if cur < tok_count && tok_values[cur] == "]"
        cur = cur + 1.0
      end
      let mut aidx_f = 0.0
      if aidx_t == "float"
        aidx_f = float(aidx_v)
      end
      if aidx_t == "ident" && map_has(env_num, aidx_v)
        aidx_f = map_get(env_num, aidx_v)
      end
      let arr_akey = "__arr_" + rtv
      if map_has(env_s, arr_akey)
        let arr_str = map_get(env_s, arr_akey)
        let arr_elems = split(arr_str, SEP)
        let ai = aidx_f
        if ai < len(arr_elems)
          let arr_elem = arr_elems[ai]
          map_set(env_s, vname, arr_elem)
          if is_match(arr_elem, "^[0-9]")
            map_set(env_num, vname, float(arr_elem))
          end
          if is_match(arr_elem, "^-[0-9]")
            map_set(env_num, vname, float(arr_elem))
          end
        end
      end
    // builtin or unknown function call: let x = fn(args)
    // ── Includes higher-order functions with lambdas (Phase 65) ──
    elif rtt == "ident" && cur < tok_count && tok_values[cur] == "("
      let bfname = rtv
      cur = cur + 1.0  // skip (
      let mut hof_handled = 0.0
      if bfname == "filter" || bfname == "map_each" || bfname == "sort_by" || bfname == "reduce"
      let hof_fn = bfname
      // First arg: array name
      let hof_arr_raw = tok_values[cur]
      cur = cur + 1.0
      if cur < tok_count && tok_values[cur] == ","
        cur = cur + 1.0
      end
      // For reduce: second arg is initial value
      let mut hof_init_num = 0.0
      let mut hof_init_str = ""
      let mut hof_init_is_str = 0.0
      if hof_fn == "reduce"
        let hi_t = tok_types[cur]
        let hi_v = tok_values[cur]
        cur = cur + 1.0
        if hi_t == "float"
          hof_init_num = float(hi_v)
          hof_init_str = hi_v
        elif hi_t == "str"
          hof_init_str = hi_v
          hof_init_is_str = 1.0
        elif hi_t == "ident"
          if map_has(env_num, hi_v)
            hof_init_num = map_get(env_num, hi_v)
            hof_init_str = str(hof_init_num)
          end
          if map_has(env_s, hi_v)
            hof_init_str = map_get(env_s, hi_v)
          end
          if map_has(env_s, hi_v) && map_has(env_num, hi_v) == 0.0
            hof_init_is_str = 1.0
          end
        end
        if cur < tok_count && tok_values[cur] == ","
          cur = cur + 1.0
        end
      end
      // Parse lambda: fn(params) body end
      if cur < tok_count && tok_types[cur] == "kw" && tok_values[cur] == "fn"
        cur = cur + 1.0
      end
      if cur < tok_count && tok_values[cur] == "("
        cur = cur + 1.0
      end
      let mut hof_params = []
      while cur < tok_count && tok_values[cur] != ")"
        if tok_types[cur] == "ident"
          push(hof_params, tok_values[cur])
        end
        cur = cur + 1.0
      end
      if cur < tok_count
        cur = cur + 1.0
      end
      let hof_body_start = cur
      // Skip to matching end
      let mut hof_depth = 1.0
      while cur < tok_count && hof_depth > 0.0
        if tok_types[cur] == "kw" && tok_values[cur] == "end"
          hof_depth = hof_depth - 1.0
        elif tok_types[cur] == "kw" && (tok_values[cur] == "if" || tok_values[cur] == "while" || tok_values[cur] == "for")
          hof_depth = hof_depth + 1.0
        end
        if hof_depth > 0.0
          cur = cur + 1.0
        end
      end
      let hof_body_end = cur
      cur = cur + 1.0
      if cur < tok_count && tok_values[cur] == ")"
        cur = cur + 1.0
      end
      // Resolve source array
      let mut hof_real_arr = hof_arr_raw
      let hof_alias_key = "__arr_alias_" + hof_arr_raw
      if map_has(env_s, hof_alias_key)
        hof_real_arr = map_get(env_s, hof_alias_key)
      end
      let hof_akey = "__arr_" + hof_real_arr
      let mut hof_count = 0.0
      let mut hof_enc_raw = ""
      if map_has(env_s, hof_akey)
        hof_enc_raw = map_get(env_s, hof_akey)
      end
      let hof_elems = split(hof_enc_raw, SEP)
      if len(hof_enc_raw) > 0.0
        hof_count = len(hof_elems)
      end
      // Execute HOF
      let mut hof_result = []
      let mut hof_acc_num = hof_init_num
      let mut hof_acc_str = hof_init_str
      let mut hof_acc_is_str = hof_init_is_str
      let mut sb_elems_arr = []
      let mut sb_keys_arr = []
      let mut hof_i = 0.0
      while hof_i < hof_count
        let hof_elem = hof_elems[hof_i]
        let mut hof_elem_num = 0.0
        if is_match(hof_elem, "^[0-9]") || is_match(hof_elem, "^-[0-9]")
          hof_elem_num = float(hof_elem)
        end
        // Bind lambda params
        if hof_fn == "reduce"
          if len(hof_params) > 0.0
            map_set(env_num, hof_params[0], hof_acc_num)
            map_set(env_s, hof_params[0], hof_acc_str)
          end
          if len(hof_params) > 1.0
            map_set(env_num, hof_params[1], hof_elem_num)
            map_set(env_s, hof_params[1], hof_elem)
          end
        else
          if len(hof_params) > 0.0
            map_set(env_num, hof_params[0], hof_elem_num)
            map_set(env_s, hof_params[0], hof_elem)
          end
        end
        // ── Inline lambda expression evaluator ──
        let mut le_cur = hof_body_start
        let le_t1 = tok_types[le_cur]
        let le_v1 = tok_values[le_cur]
        le_cur = le_cur + 1.0
        let mut le_num = 0.0
        let mut le_str = ""
        let mut le_is_str = 0.0
        let mut le_is_fncall = 0.0
        // Function call: ident(arg)
        if le_t1 == "ident" && le_cur < hof_body_end && tok_values[le_cur] == "("
          le_is_fncall = 1.0
          let le_fn = le_v1
          le_cur = le_cur + 1.0
          let le_fa_t = tok_types[le_cur]
          let le_fa_v = tok_values[le_cur]
          le_cur = le_cur + 1.0
          if le_cur <= hof_body_end && tok_values[le_cur] == ")"
            le_cur = le_cur + 1.0
          end
          let mut le_fa_num = 0.0
          let mut le_fa_str = le_fa_v
          if le_fa_t == "float"
            le_fa_num = float(le_fa_v)
          elif le_fa_t == "ident" && map_has(env_num, le_fa_v)
            le_fa_num = map_get(env_num, le_fa_v)
          end
          if le_fa_t == "ident" && map_has(env_s, le_fa_v)
            le_fa_str = map_get(env_s, le_fa_v)
          end
          if le_fn == "len"
            let le_lk = "__len_" + le_fa_v
            if map_has(env_num, le_lk)
              le_num = map_get(env_num, le_lk)
            else
              le_num = len(le_fa_str)
            end
            le_str = str(le_num)
          elif le_fn == "abs"
            le_num = abs(le_fa_num)
            le_str = str(le_num)
          elif le_fn == "sqrt"
            le_num = sqrt(le_fa_num)
            le_str = str(le_num)
          elif le_fn == "floor"
            le_num = floor(le_fa_num)
            le_str = str(le_num)
          elif le_fn == "ceil"
            le_num = ceil(le_fa_num)
            le_str = str(le_num)
          elif le_fn == "round"
            le_num = round(le_fa_num)
            le_str = str(le_num)
          elif le_fn == "float"
            le_num = float(le_fa_str)
            le_str = str(le_num)
          elif le_fn == "str"
            le_str = le_fa_str
            le_is_str = 1.0
          elif le_fn == "ord"
            le_num = ord(le_fa_str)
            le_str = str(le_num)
          elif le_fn == "chr"
            le_str = chr(le_fa_num)
            le_is_str = 1.0
          elif le_fn == "trim"
            le_str = trim(le_fa_str)
            le_is_str = 1.0
          elif le_fn == "to_upper"
            le_str = to_upper(le_fa_str)
            le_is_str = 1.0
          elif le_fn == "to_lower"
            le_str = to_lower(le_fa_str)
            le_is_str = 1.0
          else
            le_num = 0.0
          end
        end
        if le_is_fncall == 0.0
          if le_t1 == "float"
            le_num = float(le_v1)
            le_str = le_v1
          elif le_t1 == "str"
            le_str = le_v1
            le_is_str = 1.0
          elif le_t1 == "ident"
            if map_has(env_num, le_v1)
              le_num = map_get(env_num, le_v1)
            end
            if map_has(env_s, le_v1)
              le_str = map_get(env_s, le_v1)
            end
            if map_has(env_s, le_v1) && map_has(env_num, le_v1) == 0.0
              le_is_str = 1.0
            end
          end
        end
        // Check for binary operator
        if le_cur < hof_body_end
          let le_op = tok_values[le_cur]
          if le_op == "+" || le_op == "-" || le_op == "*" || le_op == "/" || le_op == ">" || le_op == ">=" || le_op == "<" || le_op == "<=" || le_op == "==" || le_op == "!="
            le_cur = le_cur + 1.0
            let mut le_t2 = tok_types[le_cur]
            let mut le_v2 = tok_values[le_cur]
            le_cur = le_cur + 1.0
            // Handle unary minus before operand
            let mut le_neg = 1.0
            if le_t2 == "op" && le_v2 == "-"
              le_neg = -1.0
              le_t2 = tok_types[le_cur]
              le_v2 = tok_values[le_cur]
              le_cur = le_cur + 1.0
            end
            let mut le_rnum = 0.0
            let mut le_rstr = ""
            if le_t2 == "float"
              le_rnum = float(le_v2) * le_neg
              le_rstr = le_v2
            elif le_t2 == "str"
              le_rstr = le_v2
            elif le_t2 == "ident"
              if map_has(env_num, le_v2)
                le_rnum = map_get(env_num, le_v2) * le_neg
              end
              if map_has(env_s, le_v2)
                le_rstr = map_get(env_s, le_v2)
              end
            end
            if le_op == "+"
              if le_is_str == 1.0
                le_str = le_str + le_rstr
              else
                le_num = le_num + le_rnum
                le_str = str(le_num)
              end
            elif le_op == "-"
              le_num = le_num - le_rnum
              le_str = str(le_num)
              le_is_str = 0.0
            elif le_op == "*"
              le_num = le_num * le_rnum
              le_str = str(le_num)
              le_is_str = 0.0
            elif le_op == "/"
              if le_rnum != 0.0
                le_num = le_num / le_rnum
              end
              le_str = str(le_num)
              le_is_str = 0.0
            elif le_op == ">"
              if le_num > le_rnum
                le_num = 1.0
              else
                le_num = 0.0
              end
              le_str = str(le_num)
              le_is_str = 0.0
            elif le_op == ">="
              if le_num >= le_rnum
                le_num = 1.0
              else
                le_num = 0.0
              end
              le_str = str(le_num)
              le_is_str = 0.0
            elif le_op == "<"
              if le_num < le_rnum
                le_num = 1.0
              else
                le_num = 0.0
              end
              le_str = str(le_num)
              le_is_str = 0.0
            elif le_op == "<="
              if le_num <= le_rnum
                le_num = 1.0
              else
                le_num = 0.0
              end
              le_str = str(le_num)
              le_is_str = 0.0
            elif le_op == "=="
              if le_is_str == 1.0
                if le_str == le_rstr
                  le_num = 1.0
                else
                  le_num = 0.0
                end
              else
                if le_num == le_rnum
                  le_num = 1.0
                else
                  le_num = 0.0
                end
              end
              le_str = str(le_num)
              le_is_str = 0.0
            elif le_op == "!="
              if le_is_str == 1.0
                if le_str != le_rstr
                  le_num = 1.0
                else
                  le_num = 0.0
                end
              else
                if le_num != le_rnum
                  le_num = 1.0
                else
                  le_num = 0.0
                end
              end
              le_str = str(le_num)
              le_is_str = 0.0
            end
            // Chained: val OP val OP val
            if le_cur < hof_body_end
              let le_op2 = tok_values[le_cur]
              if le_op2 == "+" || le_op2 == "-" || le_op2 == "*" || le_op2 == "/"
                le_cur = le_cur + 1.0
                let le_t3 = tok_types[le_cur]
                let le_v3 = tok_values[le_cur]
                le_cur = le_cur + 1.0
                let mut le_r2num = 0.0
                let mut le_r2str = ""
                if le_t3 == "float"
                  le_r2num = float(le_v3)
                  le_r2str = le_v3
                elif le_t3 == "str"
                  le_r2str = le_v3
                elif le_t3 == "ident"
                  if map_has(env_num, le_v3)
                    le_r2num = map_get(env_num, le_v3)
                  end
                  if map_has(env_s, le_v3)
                    le_r2str = map_get(env_s, le_v3)
                  end
                end
                if le_op2 == "+"
                  if le_is_str == 1.0
                    le_str = le_str + le_r2str
                  else
                    le_num = le_num + le_r2num
                    le_str = str(le_num)
                  end
                elif le_op2 == "-"
                  le_num = le_num - le_r2num
                  le_str = str(le_num)
                elif le_op2 == "*"
                  le_num = le_num * le_r2num
                  le_str = str(le_num)
                elif le_op2 == "/"
                  if le_r2num != 0.0
                    le_num = le_num / le_r2num
                  end
                  le_str = str(le_num)
                end
              end
            end
          end
        end
        // Apply HOF logic
        if hof_fn == "filter"
          if le_num != 0.0
            push(hof_result, hof_elem)
          end
        elif hof_fn == "map_each"
          if le_is_str == 1.0
            push(hof_result, le_str)
          else
            push(hof_result, str(le_num))
          end
        elif hof_fn == "sort_by"
          push(sb_elems_arr, hof_elem)
          push(sb_keys_arr, le_num)
        elif hof_fn == "reduce"
          hof_acc_num = le_num
          hof_acc_str = le_str
          hof_acc_is_str = le_is_str
        end
        hof_i = hof_i + 1.0
      end
      // Store result
      if hof_fn == "reduce"
        map_set(env_num, vname, hof_acc_num)
        map_set(env_s, vname, hof_acc_str)
      elif hof_fn == "sort_by"
        let sb_n = len(sb_elems_arr)
        let mut sb_k = 1.0
        while sb_k < sb_n
          let sb_key = sb_keys_arr[sb_k]
          let sb_val = sb_elems_arr[sb_k]
          let mut sb_l = sb_k - 1.0
          while sb_l >= 0.0 && sb_keys_arr[sb_l] > sb_key
            sb_keys_arr[sb_l + 1.0] = sb_keys_arr[sb_l]
            sb_elems_arr[sb_l + 1.0] = sb_elems_arr[sb_l]
            sb_l = sb_l - 1.0
          end
          sb_keys_arr[sb_l + 1.0] = sb_key
          sb_elems_arr[sb_l + 1.0] = sb_val
          sb_k = sb_k + 1.0
        end
        let sb_rkey = "__arr_" + vname
        let mut sb_enc = []
        let mut sb_j = 0.0
        while sb_j < sb_n
          push(sb_enc, sb_elems_arr[sb_j])
          sb_j = sb_j + 1.0
        end
        if sb_n > 0.0
          map_set(env_s, sb_rkey, join(sb_enc, SEP))
        else
          map_set(env_s, sb_rkey, "")
        end
        map_set(env_num, "__len_" + vname, sb_n)
      else
        let hof_rkey = "__arr_" + vname
        if len(hof_result) > 0.0
          map_set(env_s, hof_rkey, join(hof_result, SEP))
        else
          map_set(env_s, hof_rkey, "")
        end
        map_set(env_num, "__len_" + vname, len(hof_result))
      end
      hof_handled = 1.0
      end
      if hof_handled == 0.0
      // collect args with inline expression evaluation (a*b, a+b, etc.)
      let mut barg_names = []
      let mut barg_types = []
      while cur < tok_count && tok_values[cur] != ")"
        let bct = tok_types[cur]
        let bcv = tok_values[cur]
        // ── Nested function call as argument: fn(...) ──
        let bnc = cur + 1.0
        if bct == "ident" && bnc < tok_count && tok_values[bnc] == "("
          let ncall_fn = bcv
          cur = cur + 2.0
          // Collect inner args (idents, floats, strings, binary exprs, array indexing)
          let mut nc_args = []
          let mut nc_argt = []
          while cur < tok_count && tok_values[cur] != ")"
            let nct = tok_types[cur]
            let ncvi = tok_values[cur]
            if nct == "ident"
              let nc_n = cur + 1.0
              if nc_n < tok_count && tok_values[nc_n] == "["
                // Array indexing: ident[idx]
                let nca_arr = ncvi
                cur = cur + 2.0
                let nca_it = tok_types[cur]
                let nca_iv = tok_values[cur]
                cur = cur + 1.0
                if cur < tok_count && tok_values[cur] == "]"
                  cur = cur + 1.0
                end
                let mut nca_idx = 0.0
                if nca_it == "float"
                  nca_idx = float(nca_iv)
                elif map_has(env_num, nca_iv)
                  nca_idx = map_get(env_num, nca_iv)
                end
                let mut nca_real = nca_arr
                let nca_alias = "__arr_alias_" + nca_arr
                if map_has(env_s, nca_alias)
                  nca_real = map_get(env_s, nca_alias)
                end
                let nca_akey = "__arr_" + nca_real
                if map_has(env_s, nca_akey)
                  let nca_enc = map_get(env_s, nca_akey)
                  let nca_parts = split(nca_enc, SEP)
                  if nca_idx < len(nca_parts)
                    push(nc_args, nca_parts[nca_idx])
                    push(nc_argt, "str")
                  else
                    push(nc_args, "")
                    push(nc_argt, "str")
                  end
                else
                  push(nc_args, "")
                  push(nc_argt, "str")
                end
              elif nc_n < tok_count && (tok_values[nc_n] == "+" || tok_values[nc_n] == "-" || tok_values[nc_n] == "*" || tok_values[nc_n] == "/")
                let nc_bop = tok_values[nc_n]
                let nc_n2 = nc_n + 1.0
                if nc_n2 < tok_count && (tok_types[nc_n2] == "ident" || tok_types[nc_n2] == "float")
                  let mut nc_lhs = 0.0
                  if map_has(env_num, ncvi)
                    nc_lhs = map_get(env_num, ncvi)
                  end
                  let nc_rv = tok_values[nc_n2]
                  let mut nc_rhs = 0.0
                  if tok_types[nc_n2] == "float"
                    nc_rhs = float(nc_rv)
                  elif map_has(env_num, nc_rv)
                    nc_rhs = map_get(env_num, nc_rv)
                  end
                  let mut nc_expr = 0.0
                  if nc_bop == "+"
                    nc_expr = nc_lhs + nc_rhs
                  elif nc_bop == "-"
                    nc_expr = nc_lhs - nc_rhs
                  elif nc_bop == "*"
                    nc_expr = nc_lhs * nc_rhs
                  elif nc_bop == "/"
                    nc_expr = nc_lhs / nc_rhs
                  end
                  push(nc_args, str(nc_expr))
                  push(nc_argt, "float")
                  cur = nc_n2 + 1.0
                else
                  push(nc_args, ncvi)
                  push(nc_argt, nct)
                  cur = cur + 1.0
                end
              else
                push(nc_args, ncvi)
                push(nc_argt, nct)
                cur = cur + 1.0
              end
            elif nct == "float" || nct == "str"
              push(nc_args, ncvi)
              push(nc_argt, nct)
              cur = cur + 1.0
            else
              cur = cur + 1.0
            end
          end
          if cur < tok_count
            cur = cur + 1.0
          end
          // Resolve inner arg 0
          let mut na0 = ""
          let mut na0f = 0.0
          if len(nc_args) > 0.0
            let na0r = nc_args[0]
            let na0t = nc_argt[0]
            if na0t == "str"
              na0 = na0r
            elif na0t == "float"
              na0 = na0r
              na0f = float(na0r)
            else
              if map_has(env_s, na0r)
                na0 = map_get(env_s, na0r)
              end
              if map_has(env_num, na0r)
                na0f = map_get(env_num, na0r)
              end
            end
          end
          // Resolve inner arg 1
          let mut na1 = ""
          let mut na1f = 0.0
          if len(nc_args) > 1.0
            let na1r = nc_args[1]
            let na1t = nc_argt[1]
            if na1t == "str"
              na1 = na1r
            elif na1t == "float"
              na1 = na1r
              na1f = float(na1r)
            else
              if map_has(env_s, na1r)
                na1 = map_get(env_s, na1r)
              end
              if map_has(env_num, na1r)
                na1f = map_get(env_num, na1r)
              end
            end
          end
          // Resolve inner arg 2
          let mut na2 = ""
          let mut na2f = 0.0
          if len(nc_args) > 2.0
            let na2r = nc_args[2]
            let na2t = nc_argt[2]
            if na2t == "str"
              na2 = na2r
            elif na2t == "float"
              na2 = na2r
              na2f = float(na2r)
            else
              if map_has(env_s, na2r)
                na2 = map_get(env_s, na2r)
              end
              if map_has(env_num, na2r)
                na2f = map_get(env_num, na2r)
              end
            end
          end
          // Evaluate nested call
          let mut ncr_s = ""
          let mut ncr_f = 0.0
          let mut ncr_is_str = 0.0
          if ncall_fn == "char_at"
            ncr_s = char_at(na0, na1f)
            ncr_is_str = 1.0
          elif ncall_fn == "ord"
            ncr_f = ord(na0)
            ncr_s = str(ncr_f)
          elif ncall_fn == "chr"
            ncr_s = chr(na0f)
            ncr_is_str = 1.0
          elif ncall_fn == "len"
            ncr_f = len(na0)
            ncr_s = str(ncr_f)
          elif ncall_fn == "floor"
            ncr_f = floor(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "ceil"
            ncr_f = ceil(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "abs"
            ncr_f = abs(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "round"
            ncr_f = round(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "sqrt"
            ncr_f = sqrt(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "str"
            ncr_s = str(na0f)
            ncr_is_str = 1.0
          elif ncall_fn == "float"
            ncr_f = float(na0)
            ncr_s = str(ncr_f)
          elif ncall_fn == "trim"
            ncr_s = trim(na0)
            ncr_is_str = 1.0
          elif ncall_fn == "contains"
            ncr_f = contains(na0, na1)
            ncr_s = str(ncr_f)
          elif ncall_fn == "starts_with"
            ncr_f = starts_with(na0, na1)
            ncr_s = str(ncr_f)
          elif ncall_fn == "ends_with"
            ncr_f = ends_with(na0, na1)
            ncr_s = str(ncr_f)
          elif ncall_fn == "is_match"
            ncr_f = is_match(na0, na1)
            ncr_s = str(ncr_f)
          elif ncall_fn == "replace"
            ncr_s = replace(na0, na1, na2)
            ncr_is_str = 1.0
          elif ncall_fn == "min"
            if na0f < na1f
              ncr_f = na0f
            else
              ncr_f = na1f
            end
            ncr_s = str(ncr_f)
          elif ncall_fn == "max"
            if na0f > na1f
              ncr_f = na0f
            else
              ncr_f = na1f
            end
            ncr_s = str(ncr_f)
          elif ncall_fn == "pow"
            ncr_f = pow(na0f, na1f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "index_of"
            ncr_f = index_of(na0, na1)
            ncr_s = str(ncr_f)
          elif ncall_fn == "substr"
            ncr_s = substr(na0, na1f, na2f)
            ncr_is_str = 1.0
          elif ncall_fn == "repeat"
            ncr_s = repeat(na0, na1f)
            ncr_is_str = 1.0
          elif ncall_fn == "int"
            ncr_f = floor(float(na0))
            ncr_s = str(ncr_f)
          elif ncall_fn == "exp"
            ncr_f = exp(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "log"
            ncr_f = log(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "sin"
            ncr_f = sin(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "cos"
            ncr_f = cos(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "to_upper"
            ncr_s = to_upper(na0)
            ncr_is_str = 1.0
          elif ncall_fn == "to_lower"
            ncr_s = to_lower(na0)
            ncr_is_str = 1.0
          elif ncall_fn == "map_get"
            let mut nc_mg_map = ""
            if len(nc_args) > 0.0
              nc_mg_map = nc_args[0]
              let nc_mg_alias = "__map_alias_" + nc_mg_map
              if map_has(env_s, nc_mg_alias)
                nc_mg_map = map_get(env_s, nc_mg_alias)
              end
            end
            let nc_mg_ck = "__map_" + nc_mg_map + "." + na1
            if map_has(env_num, nc_mg_ck)
              ncr_f = map_get(env_num, nc_mg_ck)
              ncr_s = str(ncr_f)
            elif map_has(env_s, nc_mg_ck)
              ncr_s = map_get(env_s, nc_mg_ck)
              ncr_is_str = 1.0
            end
          elif ncall_fn == "map_has"
            let mut nc_mh_map = ""
            if len(nc_args) > 0.0
              nc_mh_map = nc_args[0]
              let nc_mh_alias = "__map_alias_" + nc_mh_map
              if map_has(env_s, nc_mh_alias)
                nc_mh_map = map_get(env_s, nc_mh_alias)
              end
            end
            let nc_mh_ck = "__map_" + nc_mh_map + "." + na1
            if map_has(env_s, nc_mh_ck) || map_has(env_num, nc_mh_ck)
              ncr_f = 1.0
            end
            ncr_s = str(ncr_f)
          elif ncall_fn == "type_of"
            if map_has(env_num, na0)
              ncr_s = "float"
            elif map_has(env_s, na0)
              ncr_s = "string"
            else
              ncr_s = "unknown"
            end
            ncr_is_str = 1.0
          elif ncall_fn == "file_ext"
            let nc_fe_dot = index_of(na0, ".")
            if nc_fe_dot >= 0.0
              ncr_s = substr(na0, nc_fe_dot + 1.0, len(na0))
            end
            ncr_is_str = 1.0
          elif ncall_fn == "file_name"
            let nc_fn_n = len(na0)
            let mut nc_fn_last = -1.0
            let mut nc_fn_i = 0.0
            while nc_fn_i < nc_fn_n
              let nc_fn_c = char_at(na0, nc_fn_i)
              if nc_fn_c == "/" || nc_fn_c == chr(92.0)
                nc_fn_last = nc_fn_i
              end
              nc_fn_i = nc_fn_i + 1.0
            end
            if nc_fn_last >= 0.0
              ncr_s = substr(na0, nc_fn_last + 1.0, nc_fn_n)
            else
              ncr_s = na0
            end
            ncr_is_str = 1.0
          elif ncall_fn == "dirname"
            let nc_dn_n = len(na0)
            let mut nc_dn_last = -1.0
            let mut nc_dn_i = 0.0
            while nc_dn_i < nc_dn_n
              let nc_dn_c = char_at(na0, nc_dn_i)
              if nc_dn_c == "/" || nc_dn_c == chr(92.0)
                nc_dn_last = nc_dn_i
              end
              nc_dn_i = nc_dn_i + 1.0
            end
            if nc_dn_last >= 0.0
              ncr_s = substr(na0, 0.0, nc_dn_last)
            else
              ncr_s = "."
            end
            ncr_is_str = 1.0
          elif ncall_fn == "basename"
            let nc_bn_n = len(na0)
            let mut nc_bn_last = -1.0
            let mut nc_bn_i = 0.0
            while nc_bn_i < nc_bn_n
              let nc_bn_c = char_at(na0, nc_bn_i)
              if nc_bn_c == "/" || nc_bn_c == chr(92.0)
                nc_bn_last = nc_bn_i
              end
              nc_bn_i = nc_bn_i + 1.0
            end
            if nc_bn_last >= 0.0
              ncr_s = substr(na0, nc_bn_last + 1.0, nc_bn_n)
            else
              ncr_s = na0
            end
            let nc_bn_dot = index_of(ncr_s, ".")
            if nc_bn_dot >= 0.0
              ncr_s = substr(ncr_s, 0.0, nc_bn_dot)
            end
            ncr_is_str = 1.0
          elif ncall_fn == "path_join"
            let mut nc_pj_r = na0
            if len(nc_pj_r) > 0.0
              let nc_pj_last = char_at(nc_pj_r, len(nc_pj_r) - 1.0)
              if nc_pj_last != "/" && nc_pj_last != chr(92.0)
                nc_pj_r = nc_pj_r + "/"
              end
            end
            ncr_s = nc_pj_r + na1
            ncr_is_str = 1.0
          elif ncall_fn == "hex_encode"
            let nc_he_n = len(na0)
            let nc_he_hex = "0123456789abcdef"
            let mut nc_he_r = ""
            let mut nc_he_i = 0.0
            while nc_he_i < nc_he_n
              let nc_he_o = ord(char_at(na0, nc_he_i))
              let nc_he_hi = floor(nc_he_o / 16.0)
              let nc_he_lo = nc_he_o - nc_he_hi * 16.0
              nc_he_r = nc_he_r + char_at(nc_he_hex, nc_he_hi) + char_at(nc_he_hex, nc_he_lo)
              nc_he_i = nc_he_i + 1.0
            end
            ncr_s = nc_he_r
            ncr_is_str = 1.0
          elif ncall_fn == "hex_decode"
            let nc_hd_n = len(na0)
            let nc_hd_hex = "0123456789abcdef"
            let mut nc_hd_r = ""
            let mut nc_hd_i = 0.0
            while nc_hd_i < nc_hd_n - 1.0
              let nc_hd_hi = index_of(nc_hd_hex, to_lower(char_at(na0, nc_hd_i)))
              let nc_hd_lo = index_of(nc_hd_hex, to_lower(char_at(na0, nc_hd_i + 1.0)))
              if nc_hd_hi >= 0.0 && nc_hd_lo >= 0.0
                nc_hd_r = nc_hd_r + chr(nc_hd_hi * 16.0 + nc_hd_lo)
              end
              nc_hd_i = nc_hd_i + 2.0
            end
            ncr_s = nc_hd_r
            ncr_is_str = 1.0
          elif ncall_fn == "add_seconds"
            ncr_f = na0f + na1f
            ncr_s = str(ncr_f)
          elif ncall_fn == "add_minutes"
            ncr_f = na0f + na1f * 60.0
            ncr_s = str(ncr_f)
          elif ncall_fn == "add_hours"
            ncr_f = na0f + na1f * 3600.0
            ncr_s = str(ncr_f)
          elif ncall_fn == "add_days"
            ncr_f = na0f + na1f * 86400.0
            ncr_s = str(ncr_f)
          elif ncall_fn == "diff_seconds"
            ncr_f = na0f - na1f
            ncr_s = str(ncr_f)
          elif ncall_fn == "diff_hours"
            ncr_f = (na0f - na1f) / 3600.0
            ncr_s = str(ncr_f)
          elif ncall_fn == "diff_days"
            ncr_f = (na0f - na1f) / 86400.0
            ncr_s = str(ncr_f)
          elif ncall_fn == "file_exists"
            ncr_f = file_exists(na0)
            ncr_s = str(ncr_f)
          elif ncall_fn == "file_size"
            ncr_f = file_size(na0)
            ncr_s = str(ncr_f)
          elif ncall_fn == "is_directory"
            ncr_f = is_directory(na0)
            ncr_s = str(ncr_f)
          elif ncall_fn == "time"
            ncr_f = time()
            ncr_s = str(ncr_f)
          elif ncall_fn == "random"
            ncr_f = random()
            ncr_s = str(ncr_f)
          elif ncall_fn == "env"
            ncr_s = env(na0)
            ncr_is_str = 1.0
          elif ncall_fn == "read_file"
            ncr_s = read_file(na0)
            ncr_is_str = 1.0
          elif ncall_fn == "regex_match"
            ncr_s = regex_match(na0, na1)
            ncr_is_str = 1.0
          elif ncall_fn == "os_name"
            ncr_s = os_name()
            ncr_is_str = 1.0
          elif ncall_fn == "now"
            ncr_f = now()
            ncr_s = str(ncr_f)
          elif ncall_fn == "now_ms"
            ncr_f = now_ms()
            ncr_s = str(ncr_f)
          elif ncall_fn == "read_line"
            ncr_s = read_line()
            ncr_is_str = 1.0
          elif ncall_fn == "float_to_bits"
            ncr_f = float_to_bits(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "bits_to_float"
            ncr_f = bits_to_float(na0f)
            ncr_s = str(ncr_f)
          elif ncall_fn == "float_byte"
            ncr_f = float_byte(na0f, na1f)
            ncr_s = str(ncr_f)
          end
          // Store nested call result as arg
          if ncr_is_str == 1.0
            push(barg_names, ncr_s)
            push(barg_types, "str")
          else
            push(barg_names, ncr_s)
            push(barg_types, "float")
          end
          // Post-call arithmetic: fn(x) + y
          if cur < tok_count && (tok_values[cur] == "+" || tok_values[cur] == "-" || tok_values[cur] == "*" || tok_values[cur] == "/")
            let nca_op = tok_values[cur]
            cur = cur + 1.0
            let nca_rt = tok_types[cur]
            let nca_rv = tok_values[cur]
            cur = cur + 1.0
            let mut nca_rhs = 0.0
            if nca_rt == "float"
              nca_rhs = float(nca_rv)
            elif nca_rt == "ident" && map_has(env_num, nca_rv)
              nca_rhs = map_get(env_num, nca_rv)
            end
            let mut nca_res = 0.0
            if nca_op == "+"
              nca_res = ncr_f + nca_rhs
            elif nca_op == "-"
              nca_res = ncr_f - nca_rhs
            elif nca_op == "*"
              nca_res = ncr_f * nca_rhs
            elif nca_op == "/"
              nca_res = ncr_f / nca_rhs
            end
            pop(barg_names)
            pop(barg_types)
            push(barg_names, str(nca_res))
            push(barg_types, "float")
          end
        elif bct == "ident" || bct == "float" || bct == "str"
          let bnxt = cur + 1.0
          // Check for binary expression: val OP val
          if bnxt < tok_count && (tok_values[bnxt] == "+" || tok_values[bnxt] == "-" || tok_values[bnxt] == "*" || tok_values[bnxt] == "/")
            let bop = tok_values[bnxt]
            let bnxt2 = bnxt + 1.0
            if bnxt2 < tok_count && (tok_types[bnxt2] == "ident" || tok_types[bnxt2] == "float")
              // Evaluate expression with operator precedence (* / before + -)
              // Collect all terms and operators into parallel arrays
              let mut ex_v = []
              let mut ex_o = []
              // First value
              let mut ex_v0 = 0.0
              if bct == "float"
                ex_v0 = float(bcv)
              elif map_has(env_num, bcv)
                ex_v0 = map_get(env_num, bcv)
              end
              push(ex_v, str(ex_v0))
              // First operator and second value
              push(ex_o, bop)
              let brv = tok_values[bnxt2]
              let mut ex_v1 = 0.0
              if tok_types[bnxt2] == "float"
                ex_v1 = float(brv)
              elif map_has(env_num, brv)
                ex_v1 = map_get(env_num, brv)
              end
              push(ex_v, str(ex_v1))
              cur = bnxt2 + 1.0
              // Collect additional operator-value pairs
              while cur < tok_count && (tok_values[cur] == "+" || tok_values[cur] == "-" || tok_values[cur] == "*" || tok_values[cur] == "/")
                let exn = cur + 1.0
                if exn < tok_count && (tok_types[exn] == "ident" || tok_types[exn] == "float")
                  push(ex_o, tok_values[cur])
                  let exnv = tok_values[exn]
                  let mut exnf = 0.0
                  if tok_types[exn] == "float"
                    exnf = float(exnv)
                  elif map_has(env_num, exnv)
                    exnf = map_get(env_num, exnv)
                  end
                  push(ex_v, str(exnf))
                  cur = exn + 1.0
                else
                  cur = cur + 1.0
                end
              end
              // Pass 1: evaluate * and / (high precedence)
              let mut p1_v = []
              let mut p1_o = []
              push(p1_v, ex_v[0])
              let mut exi = 0.0
              while exi < len(ex_o)
                let exop = ex_o[exi]
                let exni = exi + 1.0
                if exop == "*" || exop == "/"
                  let p1_last = float(p1_v[len(p1_v) - 1.0])
                  let p1_right = float(ex_v[exni])
                  let mut p1_res = 0.0
                  if exop == "*"
                    p1_res = p1_last * p1_right
                  else
                    p1_res = p1_last / p1_right
                  end
                  // Replace last value in p1_v
                  pop(p1_v)
                  push(p1_v, str(p1_res))
                else
                  push(p1_o, exop)
                  push(p1_v, ex_v[exni])
                end
                exi = exi + 1.0
              end
              // Pass 2: evaluate + and - (low precedence) left-to-right
              let mut bexpr = float(p1_v[0])
              let mut exi2 = 0.0
              while exi2 < len(p1_o)
                let p2_op = p1_o[exi2]
                let p2_ni = exi2 + 1.0
                let p2_rv = float(p1_v[p2_ni])
                if p2_op == "+"
                  bexpr = bexpr + p2_rv
                elif p2_op == "-"
                  bexpr = bexpr - p2_rv
                end
                exi2 = exi2 + 1.0
              end
              push(barg_names, str(bexpr))
              push(barg_types, "float")
            else
              push(barg_names, bcv)
              push(barg_types, bct)
              cur = cur + 1.0
            end
          else
            push(barg_names, bcv)
            push(barg_types, bct)
            cur = cur + 1.0
          end
        else
          cur = cur + 1.0
        end
      end
      if cur < tok_count
        cur = cur + 1.0  // skip )
      end
      // resolve an arg to its string value
      // arg 0
      let mut ba0 = ""
      let mut ba0f = 0.0
      if len(barg_names) > 0.0
        let ba0raw = barg_names[0]
        let ba0t   = barg_types[0]
        if ba0t == "str"
          ba0 = ba0raw
        elif ba0t == "float"
          ba0 = ba0raw
          ba0f = float(ba0raw)
        else
          if map_has(env_s, ba0raw)
            ba0 = map_get(env_s, ba0raw)
          end
          if map_has(env_num, ba0raw)
            ba0f = map_get(env_num, ba0raw)
          end
        end
      end
      // arg 1
      let mut ba1 = ""
      let mut ba1f = 0.0
      let mut ba1raw = ""
      if len(barg_names) > 1.0
        ba1raw = barg_names[1]
        let ba1t = barg_types[1]
        if ba1t == "str"
          ba1 = ba1raw
        elif ba1t == "float"
          ba1 = ba1raw
          ba1f = float(ba1raw)
        else
          if map_has(env_s, ba1raw)
            ba1 = map_get(env_s, ba1raw)
          end
          if map_has(env_num, ba1raw)
            ba1f = map_get(env_num, ba1raw)
          end
        end
      end
      // arg 2
      let mut ba2 = ""
      let mut ba2f = 0.0
      if len(barg_names) > 2.0
        let ba2raw = barg_names[2]
        let ba2t   = barg_types[2]
        if ba2t == "str"
          ba2 = ba2raw
        elif ba2t == "float"
          ba2 = ba2raw
          ba2f = float(ba2raw)
        else
          if map_has(env_s, ba2raw)
            ba2 = map_get(env_s, ba2raw)
          end
          if map_has(env_num, ba2raw)
            ba2f = map_get(env_num, ba2raw)
          end
        end
      end
      // args 3-7 (for FFI functions with up to 8 params)
      let mut ba3f = 0.0
      if len(barg_names) > 3.0
        let ba3raw = barg_names[3]
        let ba3t = barg_types[3]
        if ba3t == "float"
          ba3f = float(ba3raw)
        elif ba3t == "ident" && map_has(env_num, ba3raw)
          ba3f = map_get(env_num, ba3raw)
        end
      end
      let mut ba4f = 0.0
      if len(barg_names) > 4.0
        let ba4raw = barg_names[4]
        let ba4t = barg_types[4]
        if ba4t == "float"
          ba4f = float(ba4raw)
        elif ba4t == "ident" && map_has(env_num, ba4raw)
          ba4f = map_get(env_num, ba4raw)
        end
      end
      let mut ba5f = 0.0
      if len(barg_names) > 5.0
        let ba5raw = barg_names[5]
        let ba5t = barg_types[5]
        if ba5t == "float"
          ba5f = float(ba5raw)
        elif ba5t == "ident" && map_has(env_num, ba5raw)
          ba5f = map_get(env_num, ba5raw)
        end
      end
      let mut ba6f = 0.0
      if len(barg_names) > 6.0
        let ba6raw = barg_names[6]
        let ba6t = barg_types[6]
        if ba6t == "float"
          ba6f = float(ba6raw)
        elif ba6t == "ident" && map_has(env_num, ba6raw)
          ba6f = map_get(env_num, ba6raw)
        end
      end
      let mut ba7f = 0.0
      if len(barg_names) > 7.0
        let ba7raw = barg_names[7]
        let ba7t = barg_types[7]
        if ba7t == "float"
          ba7f = float(ba7raw)
        elif ba7t == "ident" && map_has(env_num, ba7raw)
          ba7f = map_get(env_num, ba7raw)
        end
      end
      // dispatch
      if bfname == "len"
        if len(barg_names) > 0.0
          let ba0raw2 = barg_names[0]
          let len_key2 = "__len_" + ba0raw2
          if map_has(env_num, len_key2)
            let lenv = map_get(env_num, len_key2)
            map_set(env_num, vname, lenv)
            map_set(env_s, vname, str(lenv))
          else
            let slen = len(ba0)
            map_set(env_num, vname, slen)
            map_set(env_s, vname, str(slen))
          end
        end
      elif bfname == "char_at"
        // Handle char_at(str, idx) and char_at(str, idx + offset) — 3 bargs means arithmetic
        let mut ca_idx = ba1f
        if len(barg_names) > 2.0
          ca_idx = ca_idx + ba2f
        end
        let ca_res = char_at(ba0, ca_idx)
        map_set(env_s, vname, ca_res)
      elif bfname == "ord"
        // handle nested: ord(char_at(src, pos))
        let mut ord_in = ba0
        if len(barg_names) > 0.0
          let ord_bn0 = barg_names[0]
          if ord_bn0 == "char_at" && len(barg_names) > 2.0
            let ord_src_v = map_get(env_s, barg_names[1])
            let mut ord_pos_v = 0.0
            if map_has(env_num, barg_names[2])
              ord_pos_v = map_get(env_num, barg_names[2])
            end
            ord_in = char_at(ord_src_v, ord_pos_v)
          end
        end
        let ord_res = ord(ord_in)
        map_set(env_num, vname, ord_res)
        map_set(env_s, vname, str(ord_res))
      elif bfname == "chr"
        let chr_res = chr(ba0f)
        map_set(env_s, vname, chr_res)
      elif bfname == "contains"
        let con_res = contains(ba0, ba1)
        map_set(env_num, vname, con_res)
        map_set(env_s, vname, str(con_res))
      elif bfname == "is_match"
        // handle nested: is_match(char_at(src, pos), pattern)
        let mut ism_in = ba0
        let mut ism_pat = ba1
        if len(barg_names) > 0.0 && barg_names[0] == "char_at" && len(barg_names) > 3.0
          let ism_ca_src = map_get(env_s, barg_names[1])
          let mut ism_ca_pos = 0.0
          if map_has(env_num, barg_names[2])
            ism_ca_pos = map_get(env_num, barg_names[2])
          end
          ism_in = char_at(ism_ca_src, ism_ca_pos)
          ism_pat = barg_names[3]
        end
        let imr = is_match(ism_in, ism_pat)
        map_set(env_num, vname, imr)
        map_set(env_s, vname, str(imr))
      elif bfname == "float"
        // handle float(arr[idx]): ba0 empty means arg is an array element
        let mut flt_arg = ba0
        if len(flt_arg) == 0.0 && len(barg_names) > 1.0
          let fa_akey = "__arr_" + barg_names[0]
          if map_has(env_s, fa_akey)
            let fa_enc = map_get(env_s, fa_akey)
            let fa_parts = split(fa_enc, SEP)
            let mut fa_idx = 0.0
            let fa_idx_t = barg_types[1]
            let fa_idx_v = barg_names[1]
            if fa_idx_t == "ident" && map_has(env_num, fa_idx_v)
              fa_idx = map_get(env_num, fa_idx_v)
            end
            if fa_idx_t == "float"
              fa_idx = float(fa_idx_v)
            end
            if fa_idx < len(fa_parts)
              flt_arg = fa_parts[fa_idx]
            end
          end
        end
        let flt_res = float(flt_arg)
        map_set(env_num, vname, flt_res)
        map_set(env_s, vname, flt_arg)
      elif bfname == "str"
        let str_res = str(ba0f)
        map_set(env_s, vname, str_res)
      elif bfname == "env"
        // Check env_s shadow first (used by Stage 6 to block EVAL_PROG_PATH recursion)
        let env_shadow_key = "__env_" + ba0
        let mut env_res = ""
        if map_has(env_s, env_shadow_key)
          env_res = map_get(env_s, env_shadow_key)
        else
          env_res = env(ba0)
        end
        map_set(env_s, vname, env_res)
      elif bfname == "read_file"
        let rf_res = read_file(ba0)
        map_set(env_s, vname, rf_res)
        map_set(env_num, "__len_" + vname, len(rf_res))
      elif bfname == "read_lines"
        let rl_lines = read_lines(ba0)
        let rl_key = "__arr_" + vname
        let rl_content = join(rl_lines, SEP)
        map_set(env_s, rl_key, rl_content)
        map_set(env_num, "__len_" + vname, len(rl_lines))
      elif bfname == "read_bytes"
        let rb_bytes = read_bytes(ba0)
        let rb_n = len(rb_bytes)
        let mut rb_enc = ""
        let mut rb_i = 0.0
        while rb_i < rb_n
          if rb_i > 0.0
            rb_enc = rb_enc + SEP
          end
          rb_enc = rb_enc + str(rb_bytes[rb_i])
          rb_i = rb_i + 1.0
        end
        let rb_key = "__arr_" + vname
        map_set(env_s, rb_key, rb_enc)
        map_set(env_num, "__len_" + vname, rb_n)
      elif bfname == "read_csv"
        // read_csv(path) — returns array of rows, each row is a map
        // Store as indexed sub-maps: __map_<name>_0, __map_<name>_1, etc.
        let rc_lines = read_lines(ba0)
        let rc_n = len(rc_lines)
        if rc_n > 1.0
          let rc_headers = split(trim(rc_lines[0]), ",")
          let rc_nh = len(rc_headers)
          let mut rc_count = 0.0
          let mut rc_idx = 1.0
          while rc_idx < rc_n
            let rc_line = trim(rc_lines[rc_idx])
            if len(rc_line) > 0.0
              let rc_vals = split(rc_line, ",")
              let mut rc_j = 0.0
              while rc_j < rc_nh && rc_j < len(rc_vals)
                let rc_hdr = trim(rc_headers[rc_j])
                let rc_val = trim(rc_vals[rc_j])
                let rc_mkey = "__map_" + vname + "_" + str(rc_count) + "." + rc_hdr
                map_set(env_s, rc_mkey, rc_val)
                map_set(env_num, rc_mkey, float(rc_val))
                rc_j = rc_j + 1.0
              end
              rc_count = rc_count + 1.0
            end
            rc_idx = rc_idx + 1.0
          end
          map_set(env_num, "__len_" + vname, rc_count)
          // Store row indices as array
          let mut rc_enc = ""
          let mut rc_ri = 0.0
          while rc_ri < rc_count
            if rc_ri > 0.0
              rc_enc = rc_enc + SEP
            end
            rc_enc = rc_enc + str(rc_ri)
            rc_ri = rc_ri + 1.0
          end
          map_set(env_s, "__arr_" + vname, rc_enc)
        else
          map_set(env_num, "__len_" + vname, 0.0)
        end
      elif bfname == "map_get"
        // arg0 is the map NAME (identifier), not its resolved value
        let mg_mapname = barg_names[0]
        let mg_mkey = "__map_" + mg_mapname + "." + ba1
        if map_has(env_num, mg_mkey)
          map_set(env_num, vname, map_get(env_num, mg_mkey))
        end
        if map_has(env_s, mg_mkey)
          map_set(env_s, vname, map_get(env_s, mg_mkey))
        end
      elif bfname == "split"
        let sp_arr = split(ba0, ba1)
        let sp_key = "__arr_" + vname
        let sp_content = join(sp_arr, SEP)
        map_set(env_s, sp_key, sp_content)
        map_set(env_num, "__len_" + vname, len(sp_arr))
      elif bfname == "join"
        // join(arr_name, sep) — ba0raw is the array name
        let jn_arrname = barg_names[0]
        let jn_key = "__arr_" + jn_arrname
        if map_has(env_s, jn_key)
          let jn_enc = map_get(env_s, jn_key)
          let jn_parts = split(jn_enc, SEP)
          let jn_result = join(jn_parts, ba1)
          map_set(env_s, vname, jn_result)
        end
      elif bfname == "abs"
        let mut abs_v = ba0f
        if abs_v < 0.0
          abs_v = abs_v - abs_v - abs_v
        end
        map_set(env_num, vname, abs_v)
        map_set(env_s, vname, str(abs_v))
      elif bfname == "floor"
        let fl_v = floor(ba0f)
        map_set(env_num, vname, fl_v)
        map_set(env_s, vname, str(fl_v))
      elif bfname == "ceil"
        let cl_v = ceil(ba0f)
        map_set(env_num, vname, cl_v)
        map_set(env_s, vname, str(cl_v))
      elif bfname == "sqrt"
        let sq_v = sqrt(ba0f)
        map_set(env_num, vname, sq_v)
        map_set(env_s, vname, str(sq_v))
      elif bfname == "min"
        // 1-arg: min(array) — reduce; 2-arg: min(a,b) — scalar
        let mn_aname = barg_names[0]
        let mut mn_areal = mn_aname
        let mn_aa2 = "__arr_alias_" + mn_aname
        if map_has(env_s, mn_aa2)
          mn_areal = map_get(env_s, mn_aa2)
        end
        let mn_ak2 = "__arr_" + mn_areal
        if len(barg_names) == 1.0 && map_has(env_s, mn_ak2)
          let mn_enc2 = map_get(env_s, mn_ak2)
          let mn_pts2 = split(mn_enc2, SEP)
          let mut mn_rv = float(mn_pts2[0])
          let mut mn_ri = 1.0
          while mn_ri < len(mn_pts2)
            let mn_cv = float(mn_pts2[mn_ri])
            if mn_cv < mn_rv
              mn_rv = mn_cv
            end
            mn_ri = mn_ri + 1.0
          end
          map_set(env_num, vname, mn_rv)
          map_set(env_s, vname, str(mn_rv))
        else
          let mut mn_v = ba0f
          if ba1f < mn_v
            mn_v = ba1f
          end
          map_set(env_num, vname, mn_v)
          map_set(env_s, vname, str(mn_v))
        end
      elif bfname == "max"
        // 1-arg: max(array) — reduce; 2-arg: max(a,b) — scalar
        let mx_aname = barg_names[0]
        let mut mx_areal = mx_aname
        let mx_aa2 = "__arr_alias_" + mx_aname
        if map_has(env_s, mx_aa2)
          mx_areal = map_get(env_s, mx_aa2)
        end
        let mx_ak2 = "__arr_" + mx_areal
        if len(barg_names) == 1.0 && map_has(env_s, mx_ak2)
          let mx_enc2 = map_get(env_s, mx_ak2)
          let mx_pts2 = split(mx_enc2, SEP)
          let mut mx_rv = float(mx_pts2[0])
          let mut mx_ri = 1.0
          while mx_ri < len(mx_pts2)
            let mx_cv = float(mx_pts2[mx_ri])
            if mx_cv > mx_rv
              mx_rv = mx_cv
            end
            mx_ri = mx_ri + 1.0
          end
          map_set(env_num, vname, mx_rv)
          map_set(env_s, vname, str(mx_rv))
        else
          let mut mx_v = ba0f
          if ba1f > mx_v
            mx_v = ba1f
          end
          map_set(env_num, vname, mx_v)
          map_set(env_s, vname, str(mx_v))
        end
      elif bfname == "trim"
        let tr_v = trim(ba0)
        map_set(env_s, vname, tr_v)
      elif bfname == "replace"
        let rp_v = replace(ba0, ba1, ba2)
        map_set(env_s, vname, rp_v)
      elif bfname == "starts_with"
        let sw_v = starts_with(ba0, ba1)
        map_set(env_num, vname, sw_v)
        map_set(env_s, vname, str(sw_v))
      elif bfname == "ends_with"
        let ew_v = ends_with(ba0, ba1)
        map_set(env_num, vname, ew_v)
        map_set(env_s, vname, str(ew_v))
      elif bfname == "round"
        let ro_v = round(ba0f)
        map_set(env_num, vname, ro_v)
        map_set(env_s, vname, str(ro_v))
      elif bfname == "pow"
        let pw_v = pow(ba0f, ba1f)
        map_set(env_num, vname, pw_v)
        map_set(env_s, vname, str(pw_v))
      elif bfname == "to_upper"
        let tu_v = to_upper(ba0)
        map_set(env_s, vname, tu_v)
      elif bfname == "to_lower"
        let tl_v = to_lower(ba0)
        map_set(env_s, vname, tl_v)
      elif bfname == "index_of"
        let io_v = index_of(ba0, ba1)
        map_set(env_num, vname, io_v)
        map_set(env_s, vname, str(io_v))
      elif bfname == "substr"
        let su_v = substr(ba0, ba1f, ba2f)
        map_set(env_s, vname, su_v)
      elif bfname == "repeat"
        let re_v = repeat(ba0, ba1f)
        map_set(env_s, vname, re_v)
      elif bfname == "int"
        let in_v = floor(float(ba0))
        map_set(env_num, vname, in_v)
        map_set(env_s, vname, str(in_v))
      elif bfname == "type_of"
        let mut to_res = "nil"
        let to_aname = barg_names[0]
        if map_has(env_s, "__arr_" + to_aname)
          to_res = "array"
        elif map_has(env_s, "__map_keys_" + to_aname)
          to_res = "map"
        elif map_has(env_num, to_aname)
          to_res = "float"
        elif map_has(env_s, to_aname)
          to_res = "string"
        end
        map_set(env_s, vname, to_res)
      elif bfname == "regex_match"
        let rm_v = is_match(ba0, ba1)
        map_set(env_num, vname, rm_v)
        map_set(env_s, vname, str(rm_v))
      elif bfname == "clamp"
        let mut cl3_v = ba0f
        if cl3_v < ba1f
          cl3_v = ba1f
        end
        if cl3_v > ba2f
          cl3_v = ba2f
        end
        map_set(env_num, vname, cl3_v)
        map_set(env_s, vname, str(cl3_v))
      elif bfname == "exp"
        let ex_v = exp(ba0f)
        map_set(env_num, vname, ex_v)
        map_set(env_s, vname, str(ex_v))
      elif bfname == "log"
        let lg_v = log(ba0f)
        map_set(env_num, vname, lg_v)
        map_set(env_s, vname, str(lg_v))
      elif bfname == "sin"
        let sn_v = sin(ba0f)
        map_set(env_num, vname, sn_v)
        map_set(env_s, vname, str(sn_v))
      elif bfname == "cos"
        let cs_v = cos(ba0f)
        map_set(env_num, vname, cs_v)
        map_set(env_s, vname, str(cs_v))
      elif bfname == "map_has"
        // map_has(m, k) in let context
        let mhb_mapname = barg_names[0]
        let mhb_compound = "__map_" + mhb_mapname + "." + ba1
        if map_has(env_s, mhb_compound) || map_has(env_num, mhb_compound)
          map_set(env_num, vname, 1.0)
          map_set(env_s, vname, "1")
        else
          map_set(env_num, vname, 0.0)
          map_set(env_s, vname, "0")
        end
      elif bfname == "pop"
        // pop(arr) — remove and return last element of interpreted array
        let pop_aname = barg_names[0]
        let pop_key = "__arr_" + pop_aname
        let pop_len_key = "__len_" + pop_aname
        let mut pop_enc = ""
        if map_has(env_s, pop_key)
          pop_enc = map_get(env_s, pop_key)
        end
        let mut pop_result = ""
        if len(pop_enc) > 0.0
          let pop_parts = split(pop_enc, SEP)
          let pop_n = len(pop_parts)
          pop_result = pop_parts[pop_n - 1.0]
          // rebuild without last element
          let mut pop_new_enc = ""
          let mut pop_ri = 0.0
          while pop_ri < pop_n - 1.0
            if pop_ri > 0.0
              pop_new_enc = pop_new_enc + SEP
            end
            pop_new_enc = pop_new_enc + pop_parts[pop_ri]
            pop_ri = pop_ri + 1.0
          end
          map_set(env_s, pop_key, pop_new_enc)
          let pop_new_len = pop_n - 1.0
          map_set(env_num, pop_len_key, pop_new_len)
        end
        map_set(env_s, vname, pop_result)
        if is_match(pop_result, "^[0-9]")
          let pop_rf = float(pop_result)
          map_set(env_num, vname, pop_rf)
        end
        if is_match(pop_result, "^-[0-9]")
          let pop_rf2 = float(pop_result)
          map_set(env_num, vname, pop_rf2)
        end
      // ── mem_* builtins (Phase 73 — FFI memory management) ──────────
      elif bfname == "mem_alloc"
        let mar = mem_alloc(ba0f)
        map_set(env_num, vname, mar)
        map_set(env_s, vname, str(mar))
      elif bfname == "mem_free"
        let mfr = mem_free(ba0f)
        map_set(env_num, vname, mfr)
      elif bfname == "mem_size"
        let msr = mem_size(ba0f)
        map_set(env_num, vname, msr)
        map_set(env_s, vname, str(msr))
      elif bfname == "mem_from_str"
        let mfs = mem_from_str(ba0)
        map_set(env_num, vname, mfs)
        map_set(env_s, vname, str(mfs))
      elif bfname == "mem_to_str"
        let mts = mem_to_str(ba0f, ba1f)
        map_set(env_s, vname, mts)
      elif bfname == "mem_set_u32"
        let msu = mem_set_u32(ba0f, ba1f, ba2f)
        map_set(env_num, vname, msu)
      elif bfname == "mem_set_f32"
        let msf = mem_set_f32(ba0f, ba1f, ba2f)
        map_set(env_num, vname, msf)
      elif bfname == "mem_set_ptr"
        let msp = mem_set_ptr(ba0f, ba1f, ba2f)
        map_set(env_num, vname, msp)
      elif bfname == "mem_set_u8"
        let ms8 = mem_set_u8(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ms8)
      elif bfname == "mem_set_u64"
        let ms64 = mem_set_u64(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ms64)
      elif bfname == "mem_get_u32"
        let mgu = mem_get_u32(ba0f, ba1f)
        map_set(env_num, vname, mgu)
        map_set(env_s, vname, str(mgu))
      elif bfname == "mem_get_f32"
        let mgf = mem_get_f32(ba0f, ba1f)
        map_set(env_num, vname, mgf)
        map_set(env_s, vname, str(mgf))
      elif bfname == "mem_get_ptr"
        let mgp = mem_get_ptr(ba0f, ba1f)
        map_set(env_num, vname, mgp)
        map_set(env_s, vname, str(mgp))
      elif bfname == "mem_get_u8"
        let mg8 = mem_get_u8(ba0f, ba1f)
        map_set(env_num, vname, mg8)
        map_set(env_s, vname, str(mg8))
      elif bfname == "mem_get_u64"
        let mg64 = mem_get_u64(ba0f, ba1f)
        map_set(env_num, vname, mg64)
        map_set(env_s, vname, str(mg64))
      elif bfname == "mem_copy"
        let mcr = mem_copy(ba0f, ba1f, ba2f, ba3f, ba4f)
        map_set(env_num, vname, mcr)
      elif bfname == "bit_and"
        let bar = bit_and(ba0f, ba1f)
        map_set(env_num, vname, bar)
        map_set(env_s, vname, str(bar))
      elif bfname == "bit_or"
        let bor = bit_or(ba0f, ba1f)
        map_set(env_num, vname, bor)
        map_set(env_s, vname, str(bor))
      elif bfname == "bit_test"
        let btr = bit_test(ba0f, ba1f)
        map_set(env_num, vname, btr)
        map_set(env_s, vname, str(btr))
      // ── System builtins ───────────────────────────────────────────
      elif bfname == "time"
        let tm_v = time()
        map_set(env_num, vname, tm_v)
        map_set(env_s, vname, str(tm_v))
      elif bfname == "random"
        let rn_v = random()
        map_set(env_num, vname, rn_v)
        map_set(env_s, vname, str(rn_v))
      elif bfname == "os_name"
        let on_v = os_name()
        map_set(env_s, vname, on_v)
      elif bfname == "now"
        let now_v = now()
        map_set(env_num, vname, now_v)
        map_set(env_s, vname, str(now_v))
      elif bfname == "now_ms"
        let nms_v = now_ms()
        map_set(env_num, vname, nms_v)
        map_set(env_s, vname, str(nms_v))
      elif bfname == "read_line"
        let rl_v = read_line()
        map_set(env_s, vname, rl_v)
        map_set(env_num, vname, float(rl_v))
      // ── I/O builtins ──────────────────────────────────────────────
      elif bfname == "write_file"
        write_file(ba0, ba1)
        map_set(env_num, vname, 1.0)
        map_set(env_s, vname, "1")
      elif bfname == "list_dir"
        let ld_arr = list_dir(ba0)
        let ld_key = "__arr_" + vname
        let ld_content = join(ld_arr, SEP)
        map_set(env_s, ld_key, ld_content)
        map_set(env_num, "__len_" + vname, len(ld_arr))
      elif bfname == "exec"
        // exec returns decomposed: .status, .output, .ok, .error
        let ex_r = exec(ba0)
        map_set(env_num, vname + ".status", ex_r.status)
        map_set(env_s, vname + ".status", str(ex_r.status))
        map_set(env_s, vname + ".output", ex_r.output)
        map_set(env_num, vname + ".ok", ex_r.ok)
        map_set(env_s, vname + ".ok", str(ex_r.ok))
        map_set(env_s, vname + ".error", ex_r.error)
        // Also set base name to output for convenience
        map_set(env_s, vname, ex_r.output)
        map_set(env_num, vname, ex_r.status)
      // ── HTTP builtins ──────────────────────────────────────────────
      elif bfname == "http_get"
        let hg_r = http_get(ba0)
        map_set(env_num, vname + ".status", hg_r.status)
        map_set(env_s, vname + ".status", str(hg_r.status))
        map_set(env_s, vname + ".body", hg_r.body)
        map_set(env_num, vname + ".ok", hg_r.ok)
        map_set(env_s, vname + ".ok", str(hg_r.ok))
        map_set(env_s, vname + ".error", hg_r.error)
        map_set(env_s, vname, hg_r.body)
      elif bfname == "http_post"
        let hp_r = http_post(ba0, ba1)
        map_set(env_num, vname + ".status", hp_r.status)
        map_set(env_s, vname + ".status", str(hp_r.status))
        map_set(env_s, vname + ".body", hp_r.body)
        map_set(env_num, vname + ".ok", hp_r.ok)
        map_set(env_s, vname + ".ok", str(hp_r.ok))
        map_set(env_s, vname + ".error", hp_r.error)
        map_set(env_s, vname, hp_r.body)
      // ── try() error handling ────────────────────────────────────────
      elif bfname == "try"
        // try(expr) → .value, .ok, .error decomposition
        // In the interpreter we evaluate the arg; since we can't catch
        // eval errors directly, we treat it as always-ok for now
        // (full error catching needs native support)
        map_set(env_num, vname + ".ok", 1.0)
        map_set(env_s, vname + ".ok", "1")
        map_set(env_s, vname + ".error", "")
        map_set(env_num, vname + ".value", ba0f)
        map_set(env_s, vname + ".value", ba0)
        map_set(env_num, vname, ba0f)
        map_set(env_s, vname, ba0)
      // ── Bitwise / binary builtins ─────────────────────────────────
      elif bfname == "float_to_bits"
        let ftb = float_to_bits(ba0f)
        map_set(env_num, vname, ftb)
        map_set(env_s, vname, str(ftb))
      elif bfname == "bits_to_float"
        let btf = bits_to_float(ba0f)
        map_set(env_num, vname, btf)
        map_set(env_s, vname, str(btf))
      elif bfname == "float_byte"
        let fb_v = float_byte(ba0f, ba1f)
        map_set(env_num, vname, fb_v)
        map_set(env_s, vname, str(fb_v))
      // ── Collection builtins ───────────────────────────────────────
      elif bfname == "sort_array"
        // sort_array(arr) — returns sorted copy as new array
        let sa_aname = barg_names[0]
        let mut sa_areal = sa_aname
        let sa_aa = "__arr_alias_" + sa_aname
        if map_has(env_s, sa_aa)
          sa_areal = map_get(env_s, sa_aa)
        end
        let sa_key = "__arr_" + sa_areal
        if map_has(env_s, sa_key)
          let sa_enc = map_get(env_s, sa_key)
          let sa_arr = split(sa_enc, SEP)
          let sa_sorted = sort_array(sa_arr)
          let sa_new = join(sa_sorted, SEP)
          let sa_dst = "__arr_" + vname
          map_set(env_s, sa_dst, sa_new)
          map_set(env_num, "__len_" + vname, len(sa_sorted))
        end
      elif bfname == "reverse"
        // reverse(arr) — returns reversed copy as new array
        let rv_aname = barg_names[0]
        let mut rv_areal = rv_aname
        let rv_aa = "__arr_alias_" + rv_aname
        if map_has(env_s, rv_aa)
          rv_areal = map_get(env_s, rv_aa)
        end
        let rv_key = "__arr_" + rv_areal
        if map_has(env_s, rv_key)
          let rv_enc = map_get(env_s, rv_key)
          let rv_arr = split(rv_enc, SEP)
          let rv_rev = reverse(rv_arr)
          let rv_new = join(rv_rev, SEP)
          let rv_dst = "__arr_" + vname
          map_set(env_s, rv_dst, rv_new)
          map_set(env_num, "__len_" + vname, len(rv_rev))
        end
      elif bfname == "unique"
        // unique(arr) — returns deduplicated copy as new array
        let uq_aname = barg_names[0]
        let mut uq_areal = uq_aname
        let uq_aa = "__arr_alias_" + uq_aname
        if map_has(env_s, uq_aa)
          uq_areal = map_get(env_s, uq_aa)
        end
        let uq_key = "__arr_" + uq_areal
        if map_has(env_s, uq_key)
          let uq_enc = map_get(env_s, uq_key)
          let uq_arr = split(uq_enc, SEP)
          let uq_uniq = unique(uq_arr)
          let uq_new = join(uq_uniq, SEP)
          let uq_dst = "__arr_" + vname
          map_set(env_s, uq_dst, uq_new)
          map_set(env_num, "__len_" + vname, len(uq_uniq))
        end
      elif bfname == "map_remove"
        // map_remove(m, key)
        let mr_mapname = barg_names[0]
        let mr_ck = "__map_" + mr_mapname + "." + ba1
        if map_has(env_num, mr_ck)
          map_set(env_num, mr_ck, 0.0)
        end
        if map_has(env_s, mr_ck)
          map_set(env_s, mr_ck, "")
        end
        map_set(env_num, vname, 0.0)
      elif bfname == "map_keys"
        // map_keys(m) — collect all keys for this map
        let mk_mapname = barg_names[0]
        let mk_prefix = "__map_" + mk_mapname + "."
        let mk_keys_key = "__map_keys_" + mk_mapname
        if map_has(env_s, mk_keys_key)
          let mk_enc = map_get(env_s, mk_keys_key)
          let mk_arr_key = "__arr_" + vname
          map_set(env_s, mk_arr_key, mk_enc)
          let mk_parts = split(mk_enc, SEP)
          map_set(env_num, "__len_" + vname, len(mk_parts))
        end
      // ── JSON builtins ─────────────────────────────────────────────
      elif bfname == "json_stringify"
        // json_stringify(map) — reconstruct native map from compound keys
        let js_mname = barg_names[0]
        let js_kk = "__map_keys_" + js_mname
        let mut js_out = "{"
        if map_has(env_s, js_kk)
          let js_keys = split(map_get(env_s, js_kk), SEP)
          let mut js_i = 0.0
          while js_i < len(js_keys)
            if js_i > 0.0
              js_out = js_out + ","
            end
            let js_k = js_keys[js_i]
            let js_ck = "__map_" + js_mname + "." + js_k
            let mut js_v = ""
            if map_has(env_s, js_ck)
              js_v = map_get(env_s, js_ck)
            end
            js_out = js_out + chr(34.0) + js_k + chr(34.0) + ":" + chr(34.0) + js_v + chr(34.0)
            js_i = js_i + 1.0
          end
        end
        js_out = js_out + "}"
        map_set(env_s, vname, js_out)
      // ── FFI extern dispatch (Phase 73) ─────────────────────────────
      // msvcrt functions
      elif bfname == "fopen"
        let ffi_r = fopen(ba0f, ba1f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "fclose"
        let ffi_r = fclose(ba0f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "fread"
        let ffi_r = fread(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "fwrite"
        let ffi_r = fwrite(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "fseek"
        let ffi_r = fseek(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "ftell"
        let ffi_r = ftell(ba0f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "puts"
        let ffi_r = puts(ba0f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "remove"
        let ffi_r = remove(ba0f)
        map_set(env_num, vname, ffi_r)
      // ── Statistics builtins (Phase 76) ──────────────────────────────
      elif bfname == "mean"
        let mn_aname = barg_names[0]
        let mut mn_areal = mn_aname
        let mn_aa = "__arr_alias_" + mn_aname
        if map_has(env_s, mn_aa)
          mn_areal = map_get(env_s, mn_aa)
        end
        let mn_key = "__arr_" + mn_areal
        let mn_enc = map_get(env_s, mn_key)
        let mn_parts = split(mn_enc, SEP)
        let mn_n = len(mn_parts)
        let mut mn_sum = 0.0
        let mut mn_i = 0.0
        while mn_i < mn_n
          mn_sum = mn_sum + float(mn_parts[mn_i])
          mn_i = mn_i + 1.0
        end
        let mn_res = mn_sum / mn_n
        map_set(env_num, vname, mn_res)
        map_set(env_s, vname, str(mn_res))
      elif bfname == "sum"
        let su_aname = barg_names[0]
        let mut su_areal = su_aname
        let su_aa = "__arr_alias_" + su_aname
        if map_has(env_s, su_aa)
          su_areal = map_get(env_s, su_aa)
        end
        let su_key = "__arr_" + su_areal
        let su_enc = map_get(env_s, su_key)
        let su_parts = split(su_enc, SEP)
        let su_n = len(su_parts)
        let mut su_sum = 0.0
        let mut su_i = 0.0
        while su_i < su_n
          su_sum = su_sum + float(su_parts[su_i])
          su_i = su_i + 1.0
        end
        map_set(env_num, vname, su_sum)
        map_set(env_s, vname, str(su_sum))
      elif bfname == "count"
        let ct_aname = barg_names[0]
        let mut ct_areal = ct_aname
        let ct_aa = "__arr_alias_" + ct_aname
        if map_has(env_s, ct_aa)
          ct_areal = map_get(env_s, ct_aa)
        end
        let ct_lk = "__len_" + ct_areal
        let mut ct_res = 0.0
        if map_has(env_num, ct_lk)
          ct_res = map_get(env_num, ct_lk)
        end
        map_set(env_num, vname, ct_res)
        map_set(env_s, vname, str(ct_res))
      elif bfname == "median"
        let md_aname = barg_names[0]
        let mut md_areal = md_aname
        let md_aa = "__arr_alias_" + md_aname
        if map_has(env_s, md_aa)
          md_areal = map_get(env_s, md_aa)
        end
        let md_key = "__arr_" + md_areal
        let md_enc = map_get(env_s, md_key)
        let md_parts = split(md_enc, SEP)
        let mut md_vals = []
        let mut md_i = 0.0
        while md_i < len(md_parts)
          push(md_vals, float(md_parts[md_i]))
          md_i = md_i + 1.0
        end
        let md_sorted = sort_array(md_vals)
        let md_n = len(md_sorted)
        let mut md_res = 0.0
        let md_mid = floor(md_n / 2.0)
        if md_n > 0.0
          md_res = md_sorted[md_mid]
        end
        map_set(env_num, vname, md_res)
        map_set(env_s, vname, str(md_res))
      elif bfname == "variance"
        let vr_aname = barg_names[0]
        let mut vr_areal = vr_aname
        let vr_aa = "__arr_alias_" + vr_aname
        if map_has(env_s, vr_aa)
          vr_areal = map_get(env_s, vr_aa)
        end
        let vr_key = "__arr_" + vr_areal
        let vr_enc = map_get(env_s, vr_key)
        let vr_parts = split(vr_enc, SEP)
        let vr_n = len(vr_parts)
        let mut vr_sum = 0.0
        let mut vr_i = 0.0
        while vr_i < vr_n
          vr_sum = vr_sum + float(vr_parts[vr_i])
          vr_i = vr_i + 1.0
        end
        let vr_mean = vr_sum / vr_n
        let mut vr_ssq = 0.0
        vr_i = 0.0
        while vr_i < vr_n
          let vr_diff = float(vr_parts[vr_i]) - vr_mean
          vr_ssq = vr_ssq + vr_diff * vr_diff
          vr_i = vr_i + 1.0
        end
        let vr_res = vr_ssq / (vr_n - 1.0)
        map_set(env_num, vname, vr_res)
        map_set(env_s, vname, str(vr_res))
      elif bfname == "stddev"
        let sd_aname = barg_names[0]
        let mut sd_areal = sd_aname
        let sd_aa = "__arr_alias_" + sd_aname
        if map_has(env_s, sd_aa)
          sd_areal = map_get(env_s, sd_aa)
        end
        let sd_key = "__arr_" + sd_areal
        let sd_enc = map_get(env_s, sd_key)
        let sd_parts = split(sd_enc, SEP)
        let sd_n = len(sd_parts)
        let mut sd_sum = 0.0
        let mut sd_i = 0.0
        while sd_i < sd_n
          sd_sum = sd_sum + float(sd_parts[sd_i])
          sd_i = sd_i + 1.0
        end
        let sd_mean = sd_sum / sd_n
        let mut sd_ssq = 0.0
        sd_i = 0.0
        while sd_i < sd_n
          let sd_diff = float(sd_parts[sd_i]) - sd_mean
          sd_ssq = sd_ssq + sd_diff * sd_diff
          sd_i = sd_i + 1.0
        end
        let sd_res = sqrt(sd_ssq / (sd_n - 1.0))
        map_set(env_num, vname, sd_res)
        map_set(env_s, vname, str(sd_res))
      elif bfname == "quantile"
        let qt_aname = barg_names[0]
        let mut qt_areal = qt_aname
        let qt_aa = "__arr_alias_" + qt_aname
        if map_has(env_s, qt_aa)
          qt_areal = map_get(env_s, qt_aa)
        end
        let qt_key = "__arr_" + qt_areal
        let qt_enc = map_get(env_s, qt_key)
        let qt_parts = split(qt_enc, SEP)
        let mut qt_vals = []
        let mut qt_i = 0.0
        while qt_i < len(qt_parts)
          push(qt_vals, float(qt_parts[qt_i]))
          qt_i = qt_i + 1.0
        end
        let qt_sorted = sort_array(qt_vals)
        let qt_n = len(qt_sorted)
        let qt_idx = floor(ba1f * (qt_n - 1.0))
        let mut qt_res = 0.0
        if qt_n > 0.0
          qt_res = qt_sorted[qt_idx]
        end
        map_set(env_num, vname, qt_res)
        map_set(env_s, vname, str(qt_res))
      elif bfname == "correlation"
        let cr_an = barg_names[0]
        let mut cr_ar = cr_an
        let cr_aa = "__arr_alias_" + cr_an
        if map_has(env_s, cr_aa)
          cr_ar = map_get(env_s, cr_aa)
        end
        let cr_bn = barg_names[1]
        let mut cr_br = cr_bn
        let cr_ba = "__arr_alias_" + cr_bn
        if map_has(env_s, cr_ba)
          cr_br = map_get(env_s, cr_ba)
        end
        let cr_aenc = map_get(env_s, "__arr_" + cr_ar)
        let cr_benc = map_get(env_s, "__arr_" + cr_br)
        let cr_ap = split(cr_aenc, SEP)
        let cr_bp = split(cr_benc, SEP)
        let cr_n = len(cr_ap)
        let mut cr_sa = 0.0
        let mut cr_sb = 0.0
        let mut cr_i = 0.0
        while cr_i < cr_n
          cr_sa = cr_sa + float(cr_ap[cr_i])
          cr_sb = cr_sb + float(cr_bp[cr_i])
          cr_i = cr_i + 1.0
        end
        let cr_ma = cr_sa / cr_n
        let cr_mb = cr_sb / cr_n
        let mut cr_sab = 0.0
        let mut cr_sa2 = 0.0
        let mut cr_sb2 = 0.0
        cr_i = 0.0
        while cr_i < cr_n
          let cr_da = float(cr_ap[cr_i]) - cr_ma
          let cr_db = float(cr_bp[cr_i]) - cr_mb
          cr_sab = cr_sab + cr_da * cr_db
          cr_sa2 = cr_sa2 + cr_da * cr_da
          cr_sb2 = cr_sb2 + cr_db * cr_db
          cr_i = cr_i + 1.0
        end
        let mut cr_res = 0.0
        let cr_denom = sqrt(cr_sa2) * sqrt(cr_sb2)
        if cr_denom > 0.0
          cr_res = cr_sab / cr_denom
        end
        map_set(env_num, vname, cr_res)
        map_set(env_s, vname, str(cr_res))
      // ── Array query builtins ────────────────────────────────────────
      elif bfname == "find"
        let fi_aname = barg_names[0]
        let mut fi_areal = fi_aname
        let fi_aa = "__arr_alias_" + fi_aname
        if map_has(env_s, fi_aa)
          fi_areal = map_get(env_s, fi_aa)
        end
        let fi_key = "__arr_" + fi_areal
        let fi_enc = map_get(env_s, fi_key)
        let fi_parts = split(fi_enc, SEP)
        let fi_n = len(fi_parts)
        let mut fi_res = -1.0
        let fi_target = ba1
        let mut fi_i = 0.0
        while fi_i < fi_n
          if fi_parts[fi_i] == fi_target && fi_res < 0.0
            fi_res = fi_i
          end
          fi_i = fi_i + 1.0
        end
        map_set(env_num, vname, fi_res)
        map_set(env_s, vname, str(fi_res))
      elif bfname == "first"
        let fr_aname = barg_names[0]
        let mut fr_areal = fr_aname
        let fr_aa = "__arr_alias_" + fr_aname
        if map_has(env_s, fr_aa)
          fr_areal = map_get(env_s, fr_aa)
        end
        let fr_key = "__arr_" + fr_areal
        let fr_enc = map_get(env_s, fr_key)
        let fr_parts = split(fr_enc, SEP)
        let mut fr_res = 0.0
        if len(fr_parts) > 0.0
          fr_res = float(fr_parts[0])
        end
        map_set(env_num, vname, fr_res)
        map_set(env_s, vname, str(fr_res))
      elif bfname == "last"
        let la_aname = barg_names[0]
        let mut la_areal = la_aname
        let la_aa = "__arr_alias_" + la_aname
        if map_has(env_s, la_aa)
          la_areal = map_get(env_s, la_aa)
        end
        let la_key = "__arr_" + la_areal
        let la_enc = map_get(env_s, la_key)
        let la_parts = split(la_enc, SEP)
        let la_n = len(la_parts)
        let mut la_res = 0.0
        if la_n > 0.0
          la_res = float(la_parts[la_n - 1.0])
        end
        map_set(env_num, vname, la_res)
        map_set(env_s, vname, str(la_res))
      elif bfname == "min_val"
        let mv_aname = barg_names[0]
        let mut mv_areal = mv_aname
        let mv_aa = "__arr_alias_" + mv_aname
        if map_has(env_s, mv_aa)
          mv_areal = map_get(env_s, mv_aa)
        end
        let mv_key = "__arr_" + mv_areal
        let mv_enc = map_get(env_s, mv_key)
        let mv_parts = split(mv_enc, SEP)
        let mv_n = len(mv_parts)
        let mut mv_res = 999999999.0
        let mut mv_i = 0.0
        while mv_i < mv_n
          let mv_v = float(mv_parts[mv_i])
          if mv_v < mv_res
            mv_res = mv_v
          end
          mv_i = mv_i + 1.0
        end
        map_set(env_num, vname, mv_res)
        map_set(env_s, vname, str(mv_res))
      elif bfname == "max_val"
        let xv_aname = barg_names[0]
        let mut xv_areal = xv_aname
        let xv_aa = "__arr_alias_" + xv_aname
        if map_has(env_s, xv_aa)
          xv_areal = map_get(env_s, xv_aa)
        end
        let xv_key = "__arr_" + xv_areal
        let xv_enc = map_get(env_s, xv_key)
        let xv_parts = split(xv_enc, SEP)
        let xv_n = len(xv_parts)
        let mut xv_res = -999999999.0
        let mut xv_i = 0.0
        while xv_i < xv_n
          let xv_v = float(xv_parts[xv_i])
          if xv_v > xv_res
            xv_res = xv_v
          end
          xv_i = xv_i + 1.0
        end
        map_set(env_num, vname, xv_res)
        map_set(env_s, vname, str(xv_res))
      elif bfname == "slice"
        let sl_aname = barg_names[0]
        let mut sl_areal = sl_aname
        let sl_aa = "__arr_alias_" + sl_aname
        if map_has(env_s, sl_aa)
          sl_areal = map_get(env_s, sl_aa)
        end
        let sl_key = "__arr_" + sl_areal
        let sl_enc = map_get(env_s, sl_key)
        let sl_parts = split(sl_enc, SEP)
        let sl_start = ba1f
        let sl_end = ba2f
        let mut sl_result = ""
        let mut sl_count = 0.0
        let mut sl_i = sl_start
        while sl_i < sl_end && sl_i < len(sl_parts)
          if sl_count > 0.0
            sl_result = sl_result + SEP
          end
          sl_result = sl_result + sl_parts[sl_i]
          sl_count = sl_count + 1.0
          sl_i = sl_i + 1.0
        end
        let sl_rkey = "__arr_" + vname
        map_set(env_s, sl_rkey, sl_result)
        map_set(env_num, "__len_" + vname, sl_count)
      elif bfname == "range_array"
        let ra_start = ba0f
        let ra_end = ba1f
        let mut ra_result = ""
        let mut ra_count = 0.0
        let mut ra_v = ra_start
        while ra_v < ra_end
          if ra_count > 0.0
            ra_result = ra_result + SEP
          end
          ra_result = ra_result + str(ra_v)
          ra_count = ra_count + 1.0
          ra_v = ra_v + 1.0
        end
        let ra_rkey = "__arr_" + vname
        map_set(env_s, ra_rkey, ra_result)
        map_set(env_num, "__len_" + vname, ra_count)
      // ── Path utility builtins ───────────────────────────────────────
      elif bfname == "file_ext"
        let fe_s = ba0
        let fe_dot = index_of(fe_s, ".")
        let mut fe_res = ""
        if fe_dot >= 0.0
          fe_res = substr(fe_s, fe_dot + 1.0, len(fe_s))
        end
        map_set(env_s, vname, fe_res)
      elif bfname == "file_name"
        let fn_s = ba0
        let fn_n = len(fn_s)
        let mut fn_last = -1.0
        let mut fn_i = 0.0
        while fn_i < fn_n
          let fn_c = char_at(fn_s, fn_i)
          if fn_c == "/" || fn_c == chr(92.0)
            fn_last = fn_i
          end
          fn_i = fn_i + 1.0
        end
        let mut fn_res = fn_s
        if fn_last >= 0.0
          fn_res = substr(fn_s, fn_last + 1.0, fn_n)
        end
        map_set(env_s, vname, fn_res)
      elif bfname == "file_dir"
        let fd_s = ba0
        let fd_n = len(fd_s)
        let mut fd_last = -1.0
        let mut fd_i = 0.0
        while fd_i < fd_n
          let fd_c = char_at(fd_s, fd_i)
          if fd_c == "/" || fd_c == chr(92.0)
            fd_last = fd_i
          end
          fd_i = fd_i + 1.0
        end
        let mut fd_res = "."
        if fd_last >= 0.0
          fd_res = substr(fd_s, 0.0, fd_last)
        end
        map_set(env_s, vname, fd_res)
      elif bfname == "dirname"
        let dn_s = ba0
        let dn_n = len(dn_s)
        let mut dn_last = -1.0
        let mut dn_i = 0.0
        while dn_i < dn_n
          let dn_c = char_at(dn_s, dn_i)
          if dn_c == "/" || dn_c == chr(92.0)
            dn_last = dn_i
          end
          dn_i = dn_i + 1.0
        end
        let mut dn_res = "."
        if dn_last >= 0.0
          dn_res = substr(dn_s, 0.0, dn_last)
        end
        map_set(env_s, vname, dn_res)
      elif bfname == "basename"
        let bn_s = ba0
        let bn_n = len(bn_s)
        let mut bn_last = -1.0
        let mut bn_i = 0.0
        while bn_i < bn_n
          let bn_c = char_at(bn_s, bn_i)
          if bn_c == "/" || bn_c == chr(92.0)
            bn_last = bn_i
          end
          bn_i = bn_i + 1.0
        end
        let mut bn_res = bn_s
        if bn_last >= 0.0
          bn_res = substr(bn_s, bn_last + 1.0, bn_n)
        end
        map_set(env_s, vname, bn_res)
      elif bfname == "path_join"
        let pj_a = ba0
        let pj_b = ba1
        let pj_an = len(pj_a)
        let mut pj_res = pj_a
        if pj_an > 0.0
          let pj_last = char_at(pj_a, pj_an - 1.0)
          if pj_last == "/" || pj_last == chr(92.0)
            pj_res = pj_a + pj_b
          else
            pj_res = pj_a + "/" + pj_b
          end
        else
          pj_res = pj_b
        end
        map_set(env_s, vname, pj_res)
      elif bfname == "file_exists"
        let fe2_res = file_exists(ba0)
        map_set(env_num, vname, fe2_res)
        map_set(env_s, vname, str(fe2_res))
      elif bfname == "file_size"
        let fs_res = file_size(ba0)
        map_set(env_num, vname, fs_res)
        map_set(env_s, vname, str(fs_res))
      elif bfname == "is_directory"
        let id_res = is_directory(ba0)
        map_set(env_num, vname, id_res)
        map_set(env_s, vname, str(id_res))
      // ── Linear algebra builtins ─────────────────────────────────────
      elif bfname == "dot"
        let dt_an = barg_names[0]
        let mut dt_ar = dt_an
        let dt_aa = "__arr_alias_" + dt_an
        if map_has(env_s, dt_aa)
          dt_ar = map_get(env_s, dt_aa)
        end
        let dt_bn = barg_names[1]
        let mut dt_br = dt_bn
        let dt_ba = "__arr_alias_" + dt_bn
        if map_has(env_s, dt_ba)
          dt_br = map_get(env_s, dt_ba)
        end
        let dt_aenc = map_get(env_s, "__arr_" + dt_ar)
        let dt_benc = map_get(env_s, "__arr_" + dt_br)
        let dt_ap = split(dt_aenc, SEP)
        let dt_bp = split(dt_benc, SEP)
        let dt_n = len(dt_ap)
        let mut dt_res = 0.0
        let mut dt_i = 0.0
        while dt_i < dt_n
          dt_res = dt_res + float(dt_ap[dt_i]) * float(dt_bp[dt_i])
          dt_i = dt_i + 1.0
        end
        map_set(env_num, vname, dt_res)
        map_set(env_s, vname, str(dt_res))
      elif bfname == "norm"
        let nm_aname = barg_names[0]
        let mut nm_areal = nm_aname
        let nm_aa = "__arr_alias_" + nm_aname
        if map_has(env_s, nm_aa)
          nm_areal = map_get(env_s, nm_aa)
        end
        let nm_key = "__arr_" + nm_areal
        let nm_enc = map_get(env_s, nm_key)
        let nm_parts = split(nm_enc, SEP)
        let nm_n = len(nm_parts)
        let mut nm_sum = 0.0
        let mut nm_i = 0.0
        while nm_i < nm_n
          let nm_v = float(nm_parts[nm_i])
          nm_sum = nm_sum + nm_v * nm_v
          nm_i = nm_i + 1.0
        end
        let nm_res = sqrt(nm_sum)
        map_set(env_num, vname, nm_res)
        map_set(env_s, vname, str(nm_res))
      elif bfname == "normalize"
        let nz_aname = barg_names[0]
        let mut nz_areal = nz_aname
        let nz_aa = "__arr_alias_" + nz_aname
        if map_has(env_s, nz_aa)
          nz_areal = map_get(env_s, nz_aa)
        end
        let nz_key = "__arr_" + nz_areal
        let nz_enc = map_get(env_s, nz_key)
        let nz_parts = split(nz_enc, SEP)
        let nz_n = len(nz_parts)
        let mut nz_sum = 0.0
        let mut nz_i = 0.0
        while nz_i < nz_n
          let nz_v = float(nz_parts[nz_i])
          nz_sum = nz_sum + nz_v * nz_v
          nz_i = nz_i + 1.0
        end
        let nz_norm = sqrt(nz_sum)
        let mut nz_result = ""
        nz_i = 0.0
        while nz_i < nz_n
          if nz_i > 0.0
            nz_result = nz_result + SEP
          end
          let nz_val = float(nz_parts[nz_i]) / nz_norm
          nz_result = nz_result + str(nz_val)
          nz_i = nz_i + 1.0
        end
        let nz_rkey = "__arr_" + vname
        map_set(env_s, nz_rkey, nz_result)
        map_set(env_num, "__len_" + vname, nz_n)
      elif bfname == "mat_transpose"
        let mt_aname = barg_names[0]
        let mut mt_areal = mt_aname
        let mt_aa = "__arr_alias_" + mt_aname
        if map_has(env_s, mt_aa)
          mt_areal = map_get(env_s, mt_aa)
        end
        let mt_key = "__arr_" + mt_areal
        let mt_enc = map_get(env_s, mt_key)
        let mt_parts = split(mt_enc, SEP)
        let mt_rows = ba1f
        let mt_cols = ba2f
        let mt_total = mt_rows * mt_cols
        let mut mt_result = ""
        let mut mt_i = 0.0
        while mt_i < mt_total
          if mt_i > 0.0
            mt_result = mt_result + SEP
          end
          let mt_r = floor(mt_i / mt_rows)
          let mt_c = mt_i - mt_r * mt_rows
          let mt_src = mt_c * mt_cols + mt_r
          mt_result = mt_result + mt_parts[mt_src]
          mt_i = mt_i + 1.0
        end
        let mt_rkey = "__arr_" + vname
        map_set(env_s, mt_rkey, mt_result)
        map_set(env_num, "__len_" + vname, mt_total)
      // ── Encoding builtins ───────────────────────────────────────────
      elif bfname == "hex_encode"
        let he_s = ba0
        let he_n = len(he_s)
        let mut he_res = ""
        let he_hex = "0123456789abcdef"
        let mut he_i = 0.0
        while he_i < he_n
          let he_byte = ord(char_at(he_s, he_i))
          let he_hi = floor(he_byte / 16.0)
          let he_lo = he_byte - he_hi * 16.0
          he_res = he_res + char_at(he_hex, he_hi) + char_at(he_hex, he_lo)
          he_i = he_i + 1.0
        end
        map_set(env_s, vname, he_res)
      elif bfname == "hex_decode"
        let hd_s = ba0
        let hd_n = len(hd_s)
        let mut hd_res = ""
        let hd_hex = "0123456789abcdef"
        let mut hd_i = 0.0
        while hd_i < hd_n - 1.0
          let hd_hi = index_of(hd_hex, to_lower(char_at(hd_s, hd_i)))
          let hd_lo = index_of(hd_hex, to_lower(char_at(hd_s, hd_i + 1.0)))
          let hd_byte = hd_hi * 16.0 + hd_lo
          hd_res = hd_res + chr(hd_byte)
          hd_i = hd_i + 2.0
        end
        map_set(env_s, vname, hd_res)
      elif bfname == "base64_encode"
        let b6_s = ba0
        let b6_n = len(b6_s)
        let b6_tbl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        let mut b6_res = ""
        let mut b6_i = 0.0
        while b6_i < b6_n
          let b6_a = ord(char_at(b6_s, b6_i))
          let mut b6_b = 0.0
          let mut b6_c = 0.0
          let mut b6_pad = 0.0
          if b6_i + 1.0 < b6_n
            b6_b = ord(char_at(b6_s, b6_i + 1.0))
          else
            b6_pad = b6_pad + 1.0
          end
          if b6_i + 2.0 < b6_n
            b6_c = ord(char_at(b6_s, b6_i + 2.0))
          else
            b6_pad = b6_pad + 1.0
          end
          let b6_n1 = floor(b6_a / 4.0)
          let b6_n2 = (b6_a - b6_n1 * 4.0) * 16.0 + floor(b6_b / 16.0)
          let b6_n3 = (b6_b - floor(b6_b / 16.0) * 16.0) * 4.0 + floor(b6_c / 64.0)
          let b6_n4 = b6_c - floor(b6_c / 64.0) * 64.0
          b6_res = b6_res + char_at(b6_tbl, b6_n1) + char_at(b6_tbl, b6_n2)
          if b6_pad < 2.0
            b6_res = b6_res + char_at(b6_tbl, b6_n3)
          else
            b6_res = b6_res + "="
          end
          if b6_pad < 1.0
            b6_res = b6_res + char_at(b6_tbl, b6_n4)
          else
            b6_res = b6_res + "="
          end
          b6_i = b6_i + 3.0
        end
        map_set(env_s, vname, b6_res)
      elif bfname == "base64_decode"
        let bd_s = ba0
        let bd_n = len(bd_s)
        let bd_tbl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        let mut bd_res = ""
        let mut bd_i = 0.0
        while bd_i < bd_n - 3.0
          let bd_c0 = char_at(bd_s, bd_i)
          let bd_c1 = char_at(bd_s, bd_i + 1.0)
          let bd_c2 = char_at(bd_s, bd_i + 2.0)
          let bd_c3 = char_at(bd_s, bd_i + 3.0)
          let bd_v0 = index_of(bd_tbl, bd_c0)
          let bd_v1 = index_of(bd_tbl, bd_c1)
          let mut bd_v2 = 0.0
          let mut bd_v3 = 0.0
          if bd_c2 != "="
            bd_v2 = index_of(bd_tbl, bd_c2)
          end
          if bd_c3 != "="
            bd_v3 = index_of(bd_tbl, bd_c3)
          end
          let bd_b0 = bd_v0 * 4.0 + floor(bd_v1 / 16.0)
          bd_res = bd_res + chr(bd_b0)
          if bd_c2 != "="
            let bd_b1 = (bd_v1 - floor(bd_v1 / 16.0) * 16.0) * 16.0 + floor(bd_v2 / 4.0)
            bd_res = bd_res + chr(bd_b1)
          end
          if bd_c3 != "="
            let bd_b2 = (bd_v2 - floor(bd_v2 / 4.0) * 4.0) * 64.0 + bd_v3
            bd_res = bd_res + chr(bd_b2)
          end
          bd_i = bd_i + 4.0
        end
        map_set(env_s, vname, bd_res)
      // ── Date arithmetic builtins ────────────────────────────────────
      elif bfname == "add_seconds"
        let as_res = ba0f + ba1f
        map_set(env_num, vname, as_res)
        map_set(env_s, vname, str(as_res))
      elif bfname == "add_minutes"
        let am_res = ba0f + ba1f * 60.0
        map_set(env_num, vname, am_res)
        map_set(env_s, vname, str(am_res))
      elif bfname == "add_hours"
        let ah_res = ba0f + ba1f * 3600.0
        map_set(env_num, vname, ah_res)
        map_set(env_s, vname, str(ah_res))
      elif bfname == "add_days"
        let ad_res = ba0f + ba1f * 86400.0
        map_set(env_num, vname, ad_res)
        map_set(env_s, vname, str(ad_res))
      elif bfname == "diff_seconds"
        let ds_res = ba0f - ba1f
        map_set(env_num, vname, ds_res)
        map_set(env_s, vname, str(ds_res))
      elif bfname == "diff_hours"
        let dh_res = (ba0f - ba1f) / 3600.0
        map_set(env_num, vname, dh_res)
        map_set(env_s, vname, str(dh_res))
      elif bfname == "diff_days"
        let dd_res = (ba0f - ba1f) / 86400.0
        map_set(env_num, vname, dd_res)
        map_set(env_s, vname, str(dd_res))
      // ── I/O builtins ────────────────────────────────────────────────
      elif bfname == "append_file"
        append_file(ba0, ba1)
        map_set(env_num, vname, 1.0)
      elif bfname == "json_parse"
        // Simple key-value JSON parser — store as map entries
        let jp_s = ba0
        let jp_n = len(jp_s)
        let mut jp_i = 0.0
        // skip leading whitespace and opening brace
        while jp_i < jp_n && (char_at(jp_s, jp_i) == " " || char_at(jp_s, jp_i) == "{")
          jp_i = jp_i + 1.0
        end
        let jp_mname = vname
        while jp_i < jp_n
          // skip whitespace, commas
          while jp_i < jp_n && (char_at(jp_s, jp_i) == " " || char_at(jp_s, jp_i) == "," || char_at(jp_s, jp_i) == chr(10.0) || char_at(jp_s, jp_i) == chr(13.0))
            jp_i = jp_i + 1.0
          end
          if jp_i >= jp_n || char_at(jp_s, jp_i) == "}"
            jp_i = jp_n
          else
            // parse key (quoted string)
            if char_at(jp_s, jp_i) == chr(34.0)
              jp_i = jp_i + 1.0
              let mut jp_key = ""
              while jp_i < jp_n && char_at(jp_s, jp_i) != chr(34.0)
                jp_key = jp_key + char_at(jp_s, jp_i)
                jp_i = jp_i + 1.0
              end
              jp_i = jp_i + 1.0
              // skip colon and whitespace
              while jp_i < jp_n && (char_at(jp_s, jp_i) == ":" || char_at(jp_s, jp_i) == " ")
                jp_i = jp_i + 1.0
              end
              // parse value
              let mut jp_val = ""
              if char_at(jp_s, jp_i) == chr(34.0)
                // string value
                jp_i = jp_i + 1.0
                while jp_i < jp_n && char_at(jp_s, jp_i) != chr(34.0)
                  jp_val = jp_val + char_at(jp_s, jp_i)
                  jp_i = jp_i + 1.0
                end
                jp_i = jp_i + 1.0
                let jp_skey = "__map_" + jp_mname + "." + jp_key
                map_set(env_s, jp_skey, jp_val)
              else
                // numeric value
                while jp_i < jp_n && char_at(jp_s, jp_i) != "," && char_at(jp_s, jp_i) != "}" && char_at(jp_s, jp_i) != " "
                  jp_val = jp_val + char_at(jp_s, jp_i)
                  jp_i = jp_i + 1.0
                end
                let jp_trimmed = trim(jp_val)
                if jp_trimmed == "true"
                  let jp_nkey = "__map_" + jp_mname + "." + jp_key
                  map_set(env_num, jp_nkey, 1.0)
                  map_set(env_s, jp_nkey, "1")
                elif jp_trimmed == "false"
                  let jp_nkey = "__map_" + jp_mname + "." + jp_key
                  map_set(env_num, jp_nkey, 0.0)
                  map_set(env_s, jp_nkey, "0")
                elif jp_trimmed == "null"
                  let jp_nkey = "__map_" + jp_mname + "." + jp_key
                  map_set(env_s, jp_nkey, "")
                else
                  let jp_nval = float(jp_trimmed)
                  let jp_nkey = "__map_" + jp_mname + "." + jp_key
                  map_set(env_num, jp_nkey, jp_nval)
                  map_set(env_s, jp_nkey, jp_trimmed)
                end
              end
            end
          end
        end
      elif bfname == "write_bytes"
        let wb_arr_name = barg_names[1]
        let wb_arr_key = "__arr_" + wb_arr_name
        if map_has(env_s, "__arr_alias_" + wb_arr_name)
          let wb_real = map_get(env_s, "__arr_alias_" + wb_arr_name)
          let wb_enc = map_get(env_s, "__arr_" + wb_real)
          let wb_parts = split(wb_enc, SEP)
          let mut wb_data = []
          let mut wb_i = 0.0
          while wb_i < len(wb_parts)
            push(wb_data, float(wb_parts[wb_i]))
            wb_i = wb_i + 1.0
          end
          write_bytes(ba0, wb_data)
        elif map_has(env_s, wb_arr_key)
          let wb_enc = map_get(env_s, wb_arr_key)
          let wb_parts = split(wb_enc, SEP)
          let mut wb_data = []
          let mut wb_i = 0.0
          while wb_i < len(wb_parts)
            push(wb_data, float(wb_parts[wb_i]))
            wb_i = wb_i + 1.0
          end
          write_bytes(ba0, wb_data)
        end
        map_set(env_num, vname, 1.0)
      elif bfname == "json_parse_array"
        // Parse a JSON array string "[1,2,3]" or '["a","b"]' into array
        let jpa_s = ba0
        let jpa_n = len(jpa_s)
        let mut jpa_i = 0.0
        // skip to opening bracket
        while jpa_i < jpa_n && char_at(jpa_s, jpa_i) != "["
          jpa_i = jpa_i + 1.0
        end
        jpa_i = jpa_i + 1.0
        let mut jpa_result = ""
        let mut jpa_count = 0.0
        while jpa_i < jpa_n && char_at(jpa_s, jpa_i) != "]"
          // skip whitespace and commas
          while jpa_i < jpa_n && (char_at(jpa_s, jpa_i) == " " || char_at(jpa_s, jpa_i) == "," || char_at(jpa_s, jpa_i) == chr(10.0))
            jpa_i = jpa_i + 1.0
          end
          if jpa_i < jpa_n && char_at(jpa_s, jpa_i) != "]"
            let mut jpa_val = ""
            if char_at(jpa_s, jpa_i) == chr(34.0)
              // string element
              jpa_i = jpa_i + 1.0
              while jpa_i < jpa_n && char_at(jpa_s, jpa_i) != chr(34.0)
                jpa_val = jpa_val + char_at(jpa_s, jpa_i)
                jpa_i = jpa_i + 1.0
              end
              jpa_i = jpa_i + 1.0
            else
              // numeric element
              while jpa_i < jpa_n && char_at(jpa_s, jpa_i) != "," && char_at(jpa_s, jpa_i) != "]" && char_at(jpa_s, jpa_i) != " "
                jpa_val = jpa_val + char_at(jpa_s, jpa_i)
                jpa_i = jpa_i + 1.0
              end
              jpa_val = trim(jpa_val)
            end
            if jpa_count > 0.0
              jpa_result = jpa_result + SEP
            end
            jpa_result = jpa_result + jpa_val
            jpa_count = jpa_count + 1.0
          end
        end
        let jpa_key = "__arr_" + vname
        map_set(env_s, jpa_key, jpa_result)
        map_set(env_num, "__len_" + vname, jpa_count)
      elif bfname == "regex_split"
        // regex_split(str, pattern) — falls back to split for basic patterns
        let rs_parts = split(ba0, ba1)
        let rs_n = len(rs_parts)
        let mut rs_result = ""
        let mut rs_i = 0.0
        while rs_i < rs_n
          if rs_i > 0.0
            rs_result = rs_result + SEP
          end
          rs_result = rs_result + rs_parts[rs_i]
          rs_i = rs_i + 1.0
        end
        let rs_key = "__arr_" + vname
        map_set(env_s, rs_key, rs_result)
        map_set(env_num, "__len_" + vname, rs_n)
      elif bfname == "capture_groups"
        // capture_groups(str, pattern) — extract regex capture groups
        let cg_parts = capture_groups(ba0, ba1)
        let cg_n = len(cg_parts)
        let mut cg_result = ""
        let mut cg_i = 0.0
        while cg_i < cg_n
          if cg_i > 0.0
            cg_result = cg_result + SEP
          end
          cg_result = cg_result + cg_parts[cg_i]
          cg_i = cg_i + 1.0
        end
        let cg_key = "__arr_" + vname
        map_set(env_s, cg_key, cg_result)
        map_set(env_num, "__len_" + vname, cg_n)
      elif bfname == "regex_find_all"
        // regex_find_all(str, pattern) — return all regex matches
        let rfa_parts = regex_find_all(ba0, ba1)
        let rfa_n = len(rfa_parts)
        let mut rfa_result = ""
        let mut rfa_i = 0.0
        while rfa_i < rfa_n
          if rfa_i > 0.0
            rfa_result = rfa_result + SEP
          end
          rfa_result = rfa_result + rfa_parts[rfa_i]
          rfa_i = rfa_i + 1.0
        end
        let rfa_key = "__arr_" + vname
        map_set(env_s, rfa_key, rfa_result)
        map_set(env_num, "__len_" + vname, rfa_n)
      // Vulkan functions
      elif bfname == "vkCreateInstance"
        let ffi_r = vkCreateInstance(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyInstance"
        let ffi_r = vkDestroyInstance(ba0f, ba1f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkEnumeratePhysicalDevices"
        let ffi_r = vkEnumeratePhysicalDevices(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkGetPhysicalDeviceQueueFamilyProperties"
        let ffi_r = vkGetPhysicalDeviceQueueFamilyProperties(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkGetPhysicalDeviceMemoryProperties"
        let ffi_r = vkGetPhysicalDeviceMemoryProperties(ba0f, ba1f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreateDevice"
        let ffi_r = vkCreateDevice(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyDevice"
        let ffi_r = vkDestroyDevice(ba0f, ba1f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkGetDeviceQueue"
        let ffi_r = vkGetDeviceQueue(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreateBuffer"
        let ffi_r = vkCreateBuffer(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyBuffer"
        let ffi_r = vkDestroyBuffer(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkGetBufferMemoryRequirements"
        let ffi_r = vkGetBufferMemoryRequirements(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkAllocateMemory"
        let ffi_r = vkAllocateMemory(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkFreeMemory"
        let ffi_r = vkFreeMemory(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkBindBufferMemory"
        let ffi_r = vkBindBufferMemory(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkMapMemory"
        let ffi_r = vkMapMemory(ba0f, ba1f, ba2f, ba3f, ba4f, ba5f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkUnmapMemory"
        let ffi_r = vkUnmapMemory(ba0f, ba1f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreateShaderModule"
        let ffi_r = vkCreateShaderModule(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyShaderModule"
        let ffi_r = vkDestroyShaderModule(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreateDescriptorSetLayout"
        let ffi_r = vkCreateDescriptorSetLayout(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyDescriptorSetLayout"
        let ffi_r = vkDestroyDescriptorSetLayout(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreatePipelineLayout"
        let ffi_r = vkCreatePipelineLayout(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyPipelineLayout"
        let ffi_r = vkDestroyPipelineLayout(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreateComputePipelines"
        let ffi_r = vkCreateComputePipelines(ba0f, ba1f, ba2f, ba3f, ba4f, ba5f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyPipeline"
        let ffi_r = vkDestroyPipeline(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreateDescriptorPool"
        let ffi_r = vkCreateDescriptorPool(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyDescriptorPool"
        let ffi_r = vkDestroyDescriptorPool(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkAllocateDescriptorSets"
        let ffi_r = vkAllocateDescriptorSets(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkUpdateDescriptorSets"
        let ffi_r = vkUpdateDescriptorSets(ba0f, ba1f, ba2f, ba3f, ba4f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreateCommandPool"
        let ffi_r = vkCreateCommandPool(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyCommandPool"
        let ffi_r = vkDestroyCommandPool(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkAllocateCommandBuffers"
        let ffi_r = vkAllocateCommandBuffers(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkBeginCommandBuffer"
        let ffi_r = vkBeginCommandBuffer(ba0f, ba1f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkEndCommandBuffer"
        let ffi_r = vkEndCommandBuffer(ba0f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkCmdBindPipeline"
        let ffi_r = vkCmdBindPipeline(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCmdBindDescriptorSets"
        let ffi_r = vkCmdBindDescriptorSets(ba0f, ba1f, ba2f, ba3f, ba4f, ba5f, ba6f, ba7f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCmdDispatch"
        let ffi_r = vkCmdDispatch(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkCreateFence"
        let ffi_r = vkCreateFence(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkDestroyFence"
        let ffi_r = vkDestroyFence(ba0f, ba1f, ba2f)
        map_set(env_num, vname, ffi_r)
      elif bfname == "vkQueueSubmit"
        let ffi_r = vkQueueSubmit(ba0f, ba1f, ba2f, ba3f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      elif bfname == "vkWaitForFences"
        let ffi_r = vkWaitForFences(ba0f, ba1f, ba2f, ba3f, ba4f)
        map_set(env_num, vname, ffi_r)
        map_set(env_s, vname, str(ffi_r))
      end
      // post-call arithmetic: let x = fn(a) * 2.0
      if cur < tok_count && tok_types[cur] == "op"
        let pca_op = tok_values[cur]
        if pca_op == "+" || pca_op == "-" || pca_op == "*" || pca_op == "/"
          cur = cur + 1.0
          let pca_rt = tok_types[cur]
          let pca_rv = tok_values[cur]
          cur = cur + 1.0
          let mut pca_rhs = 0.0
          if pca_rt == "float"
            pca_rhs = float(pca_rv)
          elif pca_rt == "ident" && map_has(env_num, pca_rv)
            pca_rhs = map_get(env_num, pca_rv)
          end
          let mut pca_lhs = 0.0
          if map_has(env_num, vname)
            pca_lhs = map_get(env_num, vname)
          end
          let mut pca_res = 0.0
          if pca_op == "+"
            pca_res = pca_lhs + pca_rhs
          elif pca_op == "-"
            pca_res = pca_lhs - pca_rhs
          elif pca_op == "*"
            pca_res = pca_lhs * pca_rhs
          elif pca_op == "/"
            pca_res = pca_lhs / pca_rhs
          end
          map_set(env_num, vname, pca_res)
          map_set(env_s, vname, str(pca_res))
        end
      end
    // check for binary op: name = a OP b
    elif cur < tok_count && tok_types[cur] == "op"
      let eop = tok_values[cur]
      if eop == "+" || eop == "-" || eop == "*" || eop == "/"
        cur = cur + 1.0
        let rtt2 = tok_types[cur]
        let rtv2 = tok_values[cur]
        cur = cur + 1.0
        let mut lf = 0.0
        if rtt == "float"
          lf = float(rtv)
        end
        if rtt == "ident" && map_has(env_num, rtv)
          lf = map_get(env_num, rtv)
        end
        let mut rf = 0.0
        if rtt2 == "float"
          rf = float(rtv2)
        end
        if rtt2 == "ident" && map_has(env_num, rtv2)
          rf = map_get(env_num, rtv2)
        end
        // detect string concat
        let mut ev_use_str = 0.0
        if eop == "+"
          if rtt == "str"
            ev_use_str = 1.0
          end
          if rtt == "ident" && map_has(env_s, rtv)
            if map_has(env_num, rtv)
            else
              ev_use_str = 1.0
            end
          end
          if rtt2 == "str"
            ev_use_str = 1.0
          end
          if rtt2 == "ident" && map_has(env_s, rtv2)
            if map_has(env_num, rtv2)
            else
              ev_use_str = 1.0
            end
          end
        end
        if eop == "+" && ev_use_str == 1.0
          let mut ev_ls = rtv
          if rtt == "ident" && map_has(env_s, rtv)
            ev_ls = map_get(env_s, rtv)
          end
          let mut ev_rs = rtv2
          if rtt2 == "ident" && map_has(env_s, rtv2)
            ev_rs = map_get(env_s, rtv2)
          end
          let mut ev_concat = ev_ls + ev_rs
          // chained concat — handles idents, str literals, and chr()/str() calls
          while cur < tok_count && tok_values[cur] == "+"
            cur = cur + 1.0
            let evc_t = tok_types[cur]
            let evc_v = tok_values[cur]
            cur = cur + 1.0
            let mut evc_s = evc_v
            if evc_t == "ident" && map_has(env_s, evc_v)
              evc_s = map_get(env_s, evc_v)
            elif evc_t == "ident" && cur < tok_count && tok_values[cur] == "("
              // function call: chr(n) or str(n)
              cur = cur + 1.0  // skip (
              let evc_fn_argt = tok_types[cur]
              let evc_fn_argv = tok_values[cur]
              cur = cur + 1.0
              cur = cur + 1.0  // skip )
              let mut evc_fn_arg = 0.0
              if evc_fn_argt == "float"
                evc_fn_arg = float(evc_fn_argv)
              elif map_has(env_num, evc_fn_argv)
                evc_fn_arg = map_get(env_num, evc_fn_argv)
              end
              if evc_v == "chr"
                evc_s = chr(evc_fn_arg)
              elif evc_v == "str"
                evc_s = str(evc_fn_arg)
              end
            end
            ev_concat = ev_concat + evc_s
          end
          map_set(env_s, vname, ev_concat)
        else
        let mut evres = 0.0
        if eop == "+"
          evres = lf + rf
        end
        if eop == "-"
          evres = lf - rf
        end
        if eop == "*"
          evres = lf * rf
        end
        if eop == "/"
          evres = lf / rf
        end
        map_set(env_num, vname, evres)
        map_set(env_s, vname, str(evres))
        end
      else
        // single value, op is something else (not arithmetic)
        if rtt == "float"
          let fv = float(rtv)
          map_set(env_num, vname, fv)
          map_set(env_s, vname, str(fv))
        end
        if rtt == "str"
          map_set(env_s, vname, rtv)
        end
        if rtt == "ident" && map_has(env_num, rtv)
          let nv = map_get(env_num, rtv)
          map_set(env_num, vname, nv)
          map_set(env_s, vname, str(nv))
        end
        if rtt == "ident" && map_has(env_s, rtv)
          let sv = map_get(env_s, rtv)
          map_set(env_s, vname, sv)
        end
      end
      end  // end if hof_handled == 0.0
    // binary op in let: let x = a OP b [OP c ...]
    elif cur < tok_count && tok_types[cur] == "op" && (tok_values[cur] == "+" || tok_values[cur] == "-" || tok_values[cur] == "*" || tok_values[cur] == "/")
      let let_op = tok_values[cur]
      // detect string concatenation
      let mut let_use_str = 0.0
      if let_op == "+"
        if rtt == "str"
          let_use_str = 1.0
        end
        if rtt == "ident" && map_has(env_s, rtv) && map_has(env_num, rtv) == 0.0
          let_use_str = 1.0
        end
      end
      if let_use_str == 1.0
        // string concatenation: let x = a + b + c ...
        let mut let_str = rtv
        if rtt == "ident" && map_has(env_s, rtv)
          let_str = map_get(env_s, rtv)
        end
        while cur < tok_count && tok_values[cur] == "+"
          cur = cur + 1.0
          let lsc_t = tok_types[cur]
          let lsc_v = tok_values[cur]
          cur = cur + 1.0
          let mut lsc_s = lsc_v
          if lsc_t == "ident" && map_has(env_s, lsc_v)
            lsc_s = map_get(env_s, lsc_v)
          end
          let_str = let_str + lsc_s
        end
        map_set(env_s, vname, let_str)
      else
        // numeric arithmetic with operator precedence
        let mut lx_v = []
        let mut lx_o = []
        let mut lx_first = 0.0
        if rtt == "float"
          lx_first = float(rtv)
        elif rtt == "ident" && map_has(env_num, rtv)
          lx_first = map_get(env_num, rtv)
        end
        push(lx_v, str(lx_first))
        while cur < tok_count && (tok_values[cur] == "+" || tok_values[cur] == "-" || tok_values[cur] == "*" || tok_values[cur] == "/")
          push(lx_o, tok_values[cur])
          cur = cur + 1.0
          let lxv = tok_values[cur]
          let lxt = tok_types[cur]
          cur = cur + 1.0
          let mut lxf = 0.0
          if lxt == "float"
            lxf = float(lxv)
          elif lxt == "ident" && map_has(env_num, lxv)
            lxf = map_get(env_num, lxv)
          end
          push(lx_v, str(lxf))
        end
        // Pass 1: * and /
        let mut lp1_v = []
        let mut lp1_o = []
        push(lp1_v, lx_v[0])
        let mut lxi = 0.0
        while lxi < len(lx_o)
          let lxop = lx_o[lxi]
          let lxni = lxi + 1.0
          if lxop == "*" || lxop == "/"
            let lp1_last = float(lp1_v[len(lp1_v) - 1.0])
            let lp1_right = float(lx_v[lxni])
            let mut lp1_res = 0.0
            if lxop == "*"
              lp1_res = lp1_last * lp1_right
            else
              lp1_res = lp1_last / lp1_right
            end
            pop(lp1_v)
            push(lp1_v, str(lp1_res))
          else
            push(lp1_o, lxop)
            push(lp1_v, lx_v[lxni])
          end
          lxi = lxi + 1.0
        end
        // Pass 2: + and -
        let mut let_result = float(lp1_v[0])
        let mut lxi2 = 0.0
        while lxi2 < len(lp1_o)
          let lp2_op = lp1_o[lxi2]
          let lp2_ni = lxi2 + 1.0
          let lp2_rv = float(lp1_v[lp2_ni])
          if lp2_op == "+"
            let_result = let_result + lp2_rv
          elif lp2_op == "-"
            let_result = let_result - lp2_rv
          end
          lxi2 = lxi2 + 1.0
        end
        map_set(env_num, vname, let_result)
        map_set(env_s, vname, str(let_result))
      end
    // unary minus: let x = -value
    elif rtt == "op" && rtv == "-"
      let um_t = tok_types[cur]
      let um_v = tok_values[cur]
      cur = cur + 1.0
      let mut um_f = 0.0
      if um_t == "float"
        um_f = float(um_v)
      end
      if um_t == "ident" && map_has(env_num, um_v)
        um_f = map_get(env_num, um_v)
      end
      let um_neg = 0.0 - um_f
      map_set(env_num, vname, um_neg)
      map_set(env_s, vname, str(um_neg))
    else
      // Single value rhs
      if rtt == "float"
        let fv = float(rtv)
        map_set(env_num, vname, fv)
        map_set(env_s, vname, str(fv))
      end
      if rtt == "str"
        map_set(env_s, vname, rtv)
      end
      if rtt == "ident" && map_has(env_num, rtv)
        let nv = map_get(env_num, rtv)
        map_set(env_num, vname, nv)
        map_set(env_s, vname, str(nv))
      end
      if rtt == "ident" && map_has(env_s, rtv)
        let sv = map_get(env_s, rtv)
        map_set(env_s, vname, sv)
      end
    end

  // push(arr, val) — append value to interpreted array
  elif tt == "kw" && tv == "push"
    cur = cur + 1.0  // skip push
    cur = cur + 1.0  // skip (
    let parr = tok_values[cur]
    cur = cur + 1.0  // skip arr name
    cur = cur + 1.0  // skip comma
    // resolve push expression: -val, str(val), str(arr[idx]), val+rhs, or simple
    let mut push_s = ""
    let mut push_f = 0.0
    let pnxt_c = cur + 1.0
    if tok_types[cur] == "op" && tok_values[cur] == "-"
      // unary minus: push(arr, -float)
      cur = cur + 1.0  // skip -
      let pm_t = tok_types[cur]
      let pm_v = tok_values[cur]
      cur = cur + 1.0
      if pm_t == "float"
        push_f = 0.0 - float(pm_v)
      end
      if pm_t == "ident" && map_has(env_num, pm_v)
        push_f = 0.0 - map_get(env_num, pm_v)
      end
      push_s = str(push_f)
    elif tok_types[cur] == "ident" && tok_values[cur] == "str" && pnxt_c < tok_count && tok_values[pnxt_c] == "("
      // str(scalar) or str(arr[idx]): push(arr, str(expr))
      cur = cur + 2.0  // skip str and (
      let psc_t = tok_types[cur]
      let psc_v = tok_values[cur]
      cur = cur + 1.0  // skip arg
      if cur < tok_count && tok_values[cur] == "["
        // str(arr[idx]) pattern: push(arr, str(arr2[idx2]))
        cur = cur + 1.0  // skip [
        let psc_idx_t = tok_types[cur]
        let psc_idx_v = tok_values[cur]
        cur = cur + 1.0
        if cur < tok_count && tok_values[cur] == "]"
          cur = cur + 1.0
        end
        let mut psc_ai = 0.0
        if psc_idx_t == "float"
          psc_ai = float(psc_idx_v)
        end
        if psc_idx_t == "ident" && map_has(env_num, psc_idx_v)
          psc_ai = map_get(env_num, psc_idx_v)
        end
        let psc_akey = "__arr_" + psc_v
        let mut psc_elem_f = 0.0
        let mut psc_elem_s = "-1"
        if map_has(env_s, psc_akey)
          let psc_enc = map_get(env_s, psc_akey)
          let psc_elems = split(psc_enc, SEP)
          let psc_ei = psc_ai
          if psc_ei < len(psc_elems)
            psc_elem_s = psc_elems[psc_ei]
            if is_match(psc_elem_s, "^[0-9]")
              psc_elem_f = float(psc_elem_s)
            end
            if is_match(psc_elem_s, "^-[0-9]")
              psc_elem_f = float(psc_elem_s)
            end
          end
        end
        push_s = str(psc_elem_f)
        if psc_elem_s == "-1"
          push_s = "-1"
        end
        push_f = psc_elem_f
      else
        // str(scalar_var): push(arr, str(scalar))
        let mut psc_f = 0.0
        if psc_t == "float"
          psc_f = float(psc_v)
        end
        if psc_t == "ident" && map_has(env_num, psc_v)
          psc_f = map_get(env_num, psc_v)
        end
        push_s = str(psc_f)
        push_f = psc_f
      end
      if cur < tok_count && tok_values[cur] == ")"
        cur = cur + 1.0  // skip inner )
      end
    else
      // simple value, or ident (+|-) rhs arithmetic
      let pval_t = tok_types[cur]
      let pval_v = tok_values[cur]
      cur = cur + 1.0  // skip val
      if pval_t == "float"
        push_f = float(pval_v)
        push_s = pval_v
      end
      if pval_t == "str"
        push_s = pval_v
      end
      if pval_t == "ident" && map_has(env_s, pval_v)
        push_s = map_get(env_s, pval_v)
      end
      if pval_t == "ident" && map_has(env_num, pval_v)
        push_f = map_get(env_num, pval_v)
        push_s = str(push_f)
      end
      // handle arithmetic: push(arr, val + rhs)
      if cur < tok_count && tok_values[cur] == "+"
        cur = cur + 1.0  // skip +
        let pa_t = tok_types[cur]
        let pa_v = tok_values[cur]
        cur = cur + 1.0
        let mut pa_rf = 0.0
        if pa_t == "float"
          pa_rf = float(pa_v)
        end
        if pa_t == "ident" && map_has(env_num, pa_v)
          pa_rf = map_get(env_num, pa_v)
        end
        push_f = push_f + pa_rf
        push_s = str(push_f)
      elif cur < tok_count && tok_values[cur] == "-"
        cur = cur + 1.0  // skip -
        let pa_t = tok_types[cur]
        let pa_v = tok_values[cur]
        cur = cur + 1.0
        let mut pa_rf = 0.0
        if pa_t == "float"
          pa_rf = float(pa_v)
        end
        if pa_t == "ident" && map_has(env_num, pa_v)
          pa_rf = map_get(env_num, pa_v)
        end
        push_f = push_f - pa_rf
        push_s = str(push_f)
      end
    end
    // skip closing )
    if cur < tok_count && tok_values[cur] == ")"
      cur = cur + 1.0
    end
    // resolve array alias (pass-by-reference arrays in functions)
    let mut parr_real = parr
    let parr_alias_key = "__arr_alias_" + parr
    if map_has(env_s, parr_alias_key)
      parr_real = map_get(env_s, parr_alias_key)
    end
    // append to pipe-delimited array
    let parr_key = "__arr_" + parr_real
    let plen_key = "__len_" + parr_real
    if map_has(env_s, parr_key)
      let cur_arr = map_get(env_s, parr_key)
      if len(cur_arr) == 0.0
        map_set(env_s, parr_key, push_s)
      else
        map_set(env_s, parr_key, cur_arr + SEP + push_s)
      end
      let cur_len = map_get(env_num, plen_key)
      map_set(env_num, plen_key, cur_len + 1.0)
      // also update aliased copy if different
      if parr_real != parr
        let parr_key2 = "__arr_" + parr
        let plen_key2 = "__len_" + parr
        map_set(env_s, parr_key2, map_get(env_s, parr_key))
        map_set(env_num, plen_key2, map_get(env_num, plen_key))
      end
    end

  // map_set(m, k, v) — set key in interpreted map
  elif tt == "kw" && tv == "map_set"
    cur = cur + 1.0  // skip map_set
    cur = cur + 1.0  // skip (
    let mut ms_map = tok_values[cur]
    // resolve map alias for pass-by-reference
    let ms_malias = "__map_alias_" + ms_map
    if map_has(env_s, ms_malias)
      ms_map = map_get(env_s, ms_malias)
    end
    cur = cur + 1.0  // skip map name
    cur = cur + 1.0  // skip comma
    let ms_key_t = tok_types[cur]
    let ms_key_v = tok_values[cur]
    cur = cur + 1.0  // skip key
    cur = cur + 1.0  // skip comma
    let ms_val_t = tok_types[cur]
    let ms_val_v = tok_values[cur]
    cur = cur + 1.0  // skip val
    if cur < tok_count && tok_values[cur] == ")"
      cur = cur + 1.0
    end
    // resolve key to string
    let mut ms_key = ms_key_v
    if ms_key_t == "ident" && map_has(env_s, ms_key_v)
      ms_key = map_get(env_s, ms_key_v)
    end
    // resolve value
    let mut ms_val_s = ms_val_v
    let mut ms_val_f = 0.0
    if ms_val_t == "float"
      ms_val_f = float(ms_val_v)
    end
    if ms_val_t == "ident" && map_has(env_s, ms_val_v)
      ms_val_s = map_get(env_s, ms_val_v)
    end
    if ms_val_t == "ident" && map_has(env_num, ms_val_v)
      ms_val_f = map_get(env_num, ms_val_v)
    end
    // store with compound key __map_m.key
    let ms_compound = "__map_" + ms_map + "." + ms_key
    if ms_val_t == "float"
      map_set(env_num, ms_compound, ms_val_f)
      map_set(env_s, ms_compound, str(ms_val_f))
    elif ms_val_t == "str"
      map_set(env_s, ms_compound, ms_val_s)
    elif ms_val_t == "ident"
      if map_has(env_num, ms_val_v)
        map_set(env_num, ms_compound, ms_val_f)
        map_set(env_s, ms_compound, ms_val_s)
      else
        map_set(env_s, ms_compound, ms_val_s)
      end
    end
    // track keys for map_keys()
    let ms_kk = "__map_keys_" + ms_map
    if map_has(env_s, ms_kk)
      let ms_ex = map_get(env_s, ms_kk)
      if contains(ms_ex, ms_key) == 0.0
        map_set(env_s, ms_kk, ms_ex + SEP + ms_key)
      end
    else
      map_set(env_s, ms_kk, ms_key)
    end

  // ExprStmt bare fn calls: handled inside the ident handler below (an1=="(" check)

  // print("text {var}")
  // Simplified: just print the raw template string
  elif tt == "kw" && tv == "print"
    cur = cur + 1.0
    // skip (
    cur = cur + 1.0
    let ptxt = tok_values[cur]
    cur = cur + 1.0
    // skip )
    cur = cur + 1.0
    // String interpolation: scan for {varname} and replace from env_s
    let mut pout = ""
    let mut pi = 0.0
    let plen = len(ptxt)
    while pi < plen
      let pc = char_at(ptxt, pi)
      if pc == "{"
        pi = pi + 1.0
        let mut pvar = ""
        while pi < plen && char_at(ptxt, pi) != "}"
          pvar = pvar + char_at(ptxt, pi)
          pi = pi + 1.0
        end
        if pi < plen
          pi = pi + 1.0
        end
        if map_has(env_s, pvar)
          pout = pout + map_get(env_s, pvar)
        else
          pout = pout + "{" + pvar + "}"
        end
      else
        pout = pout + pc
        pi = pi + 1.0
      end
    end
    print("{pout}")

  // if cond ... end  (evaluate condition, skip body if false)
  elif tt == "kw" && tv == "if"
    cur = cur + 1.0
    let mut icond = 0.0
    // pre-declare condition tokens (used after map_has/lhs-op-rhs branch)
    let mut it1 = ""
    let mut iv1 = ""
    let mut icop = ""
    let mut it2 = ""
    let mut iv2 = ""
    // detect map_has(m, k) boolean condition
    if tok_values[cur] == "map_has"
      cur = cur + 1.0  // skip map_has
      cur = cur + 1.0  // skip (
      let mhm = tok_values[cur]
      cur = cur + 1.0  // skip map name
      cur = cur + 1.0  // skip comma
      let mhk_t = tok_types[cur]
      let mhk_v = tok_values[cur]
      cur = cur + 1.0  // skip key
      if cur < tok_count && tok_values[cur] == ")"
        cur = cur + 1.0
      end
      // resolve key
      let mut mhk = mhk_v
      if mhk_t == "ident" && map_has(env_s, mhk_v)
        mhk = map_get(env_s, mhk_v)
      end
      let mh_compound = "__map_" + mhm + "." + mhk
      if map_has(env_s, mh_compound) || map_has(env_num, mh_compound)
        icond = 1.0
      end
      // optional negation: map_has(...) == 0.0 / != 0.0
      if cur < tok_count && tok_values[cur] == "=="
        cur = cur + 1.0
        let mhcmp_v = tok_values[cur]
        cur = cur + 1.0
        let mhcmp_f = float(mhcmp_v)
        if icond == mhcmp_f
          icond = 1.0
        else
          icond = 0.0
        end
      end
      if cur < tok_count && tok_values[cur] == "!="
        cur = cur + 1.0
        let mhcmp2_v = tok_values[cur]
        cur = cur + 1.0
        let mhcmp2_f = float(mhcmp2_v)
        if icond != mhcmp2_f
          icond = 1.0
        else
          icond = 0.0
        end
      end
    elif tok_values[cur] == "is_match"
      // is_match(ident_or_char_at(src,pos), pattern) as if condition
      cur = cur + 1.0  // skip is_match
      cur = cur + 1.0  // skip (
      let ism_t = tok_types[cur]
      let ism_v = tok_values[cur]
      cur = cur + 1.0
      let mut ism_s = ""
      if ism_v == "char_at"
        // nested: is_match(char_at(src_var, pos_var), pattern)
        cur = cur + 1.0  // skip (
        let ism_ca_sv = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip ,
        let ism_ca_pv = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip inner )
        cur = cur + 1.0  // skip ,
        let ism_ca_src = map_get(env_s, ism_ca_sv)
        let mut ism_ca_pos = 0.0
        if map_has(env_num, ism_ca_pv)
          ism_ca_pos = map_get(env_num, ism_ca_pv)
        end
        ism_s = char_at(ism_ca_src, ism_ca_pos)
      else
        cur = cur + 1.0  // skip ,
        if ism_t == "ident" && map_has(env_s, ism_v)
          ism_s = map_get(env_s, ism_v)
        else
          ism_s = ism_v
        end
      end
      let ism_p = tok_values[cur]
      cur = cur + 1.0
      cur = cur + 1.0  // skip )
      let ism_r = is_match(ism_s, ism_p)
      if ism_r == 1.0
        icond = 1.0
      end
    elif tok_values[cur] == "contains"
      // contains(str, pat) as boolean if condition
      cur = cur + 1.0  // skip "contains"
      cur = cur + 1.0  // skip (
      let ico_at = tok_types[cur]
      let ico_av = tok_values[cur]
      cur = cur + 1.0
      cur = cur + 1.0  // skip ,
      let ico_pt = tok_types[cur]
      let ico_pv = tok_values[cur]
      cur = cur + 1.0
      cur = cur + 1.0  // skip )
      let mut ico_s = ico_av
      if ico_at == "ident" && map_has(env_s, ico_av)
        ico_s = map_get(env_s, ico_av)
      end
      let mut ico_p = ico_pv
      if ico_pt == "ident" && map_has(env_s, ico_pv)
        ico_p = map_get(env_s, ico_pv)
      end
      let ico_r = contains(ico_s, ico_p)
      if ico_r == 1.0
        icond = 1.0
      end
    elif tok_values[cur] == "starts_with"
      // starts_with(str, pat) as boolean if condition
      cur = cur + 1.0  // skip "starts_with"
      cur = cur + 1.0  // skip (
      let isw_at = tok_types[cur]
      let isw_av = tok_values[cur]
      cur = cur + 1.0
      cur = cur + 1.0  // skip ,
      let isw_pt = tok_types[cur]
      let isw_pv = tok_values[cur]
      cur = cur + 1.0
      cur = cur + 1.0  // skip )
      let mut isw_s = isw_av
      if isw_at == "ident" && map_has(env_s, isw_av)
        isw_s = map_get(env_s, isw_av)
      end
      let mut isw_p = isw_pv
      if isw_pt == "ident" && map_has(env_s, isw_pv)
        isw_p = map_get(env_s, isw_pv)
      end
      let isw_r = starts_with(isw_s, isw_p)
      if isw_r == 1.0
        icond = 1.0
      end
    elif tok_values[cur] == "ends_with"
      // ends_with(str, pat) as boolean if condition
      cur = cur + 1.0  // skip "ends_with"
      cur = cur + 1.0  // skip (
      let iew_at = tok_types[cur]
      let iew_av = tok_values[cur]
      cur = cur + 1.0
      cur = cur + 1.0  // skip ,
      let iew_pt = tok_types[cur]
      let iew_pv = tok_values[cur]
      cur = cur + 1.0
      cur = cur + 1.0  // skip )
      let mut iew_s = iew_av
      if iew_at == "ident" && map_has(env_s, iew_av)
        iew_s = map_get(env_s, iew_av)
      end
      let mut iew_p = iew_pv
      if iew_pt == "ident" && map_has(env_s, iew_pv)
        iew_p = map_get(env_s, iew_pv)
      end
      let iew_r = ends_with(iew_s, iew_p)
      if iew_r == 1.0
        icond = 1.0
      end
    elif tok_values[cur] == "len"
      // len(x) op rhs — works for both arrays (__len_NAME) and string scalars
      cur = cur + 1.0  // skip "len"
      cur = cur + 1.0  // skip (
      let iln_v = tok_values[cur]
      cur = cur + 1.0  // skip arg
      cur = cur + 1.0  // skip )
      let icop_len = tok_values[cur]
      cur = cur + 1.0
      let irhs_t = tok_types[cur]
      let irhs_v = tok_values[cur]
      cur = cur + 1.0
      let mut iln_val = 0.0
      let iln_key = "__len_" + iln_v
      if map_has(env_num, iln_key)
        iln_val = map_get(env_num, iln_key)
      else
        if map_has(env_s, iln_v)
          let iln_s = map_get(env_s, iln_v)
          iln_val = len(iln_s)
        end
      end
      let mut irf_len = 0.0
      if irhs_t == "float"
        irf_len = float(irhs_v)
      end
      if irhs_t == "ident" && map_has(env_num, irhs_v)
        irf_len = map_get(env_num, irhs_v)
      end
      if icop_len == ">"
        if iln_val > irf_len
          icond = 1.0
        end
      end
      if icop_len == "<"
        if iln_val < irf_len
          icond = 1.0
        end
      end
      if icop_len == ">="
        if iln_val >= irf_len
          icond = 1.0
        end
      end
      if icop_len == "<="
        if iln_val <= irf_len
          icond = 1.0
        end
      end
      if icop_len == "=="
        if iln_val == irf_len
          icond = 1.0
        end
      end
      if icop_len == "!="
        if iln_val != irf_len
          icond = 1.0
        end
      end
    elif tok_values[cur] == "char_at"
      // char_at(str_var, idx) == / != "char"
      cur = cur + 1.0  // skip "char_at"
      cur = cur + 1.0  // skip (
      let ica_sv = tok_values[cur]
      cur = cur + 1.0  // skip str var
      cur = cur + 1.0  // skip ,
      let ica_it = tok_types[cur]
      let ica_iv = tok_values[cur]
      cur = cur + 1.0  // skip idx
      cur = cur + 1.0  // skip )
      let ica_op = tok_values[cur]
      cur = cur + 1.0  // skip op
      let ica_rt = tok_types[cur]
      let ica_rv = tok_values[cur]
      cur = cur + 1.0  // skip rhs
      let mut ica_src = ""
      if map_has(env_s, ica_sv)
        ica_src = map_get(env_s, ica_sv)
      end
      let mut ica_idx = 0.0
      if ica_it == "float"
        ica_idx = float(ica_iv)
      end
      if ica_it == "ident" && map_has(env_num, ica_iv)
        ica_idx = map_get(env_num, ica_iv)
      end
      let ica_c = char_at(ica_src, ica_idx)
      let mut ica_rhs = ica_rv
      if ica_rt == "ident" && map_has(env_s, ica_rv)
        ica_rhs = map_get(env_s, ica_rv)
      end
      if ica_op == "=="
        if ica_c == ica_rhs
          icond = 1.0
        end
      end
      if ica_op == "!="
        if ica_c != ica_rhs
          icond = 1.0
        end
      end
    elif tok_values[cur] == "abs" || tok_values[cur] == "floor" || tok_values[cur] == "ceil" || tok_values[cur] == "sqrt" || tok_values[cur] == "round"
      // math fn as condition LHS: abs(expr) < 0.01, floor(x) == y
      let icf_fn = tok_values[cur]
      cur = cur + 1.0  // skip fn name
      cur = cur + 1.0  // skip (
      let icf_at = tok_types[cur]
      let icf_av = tok_values[cur]
      cur = cur + 1.0
      let mut icf_af = 0.0
      if icf_at == "float"
        icf_af = float(icf_av)
      end
      if icf_at == "ident" && map_has(env_num, icf_av)
        icf_af = map_get(env_num, icf_av)
      end
      // arithmetic in arg: abs(f5 - 120.0)
      if cur < tok_count && tok_types[cur] == "op"
        let icf_iop = tok_values[cur]
        if icf_iop == "+" || icf_iop == "-" || icf_iop == "*" || icf_iop == "/"
          cur = cur + 1.0
          let icf_bt = tok_types[cur]
          let icf_bv = tok_values[cur]
          cur = cur + 1.0
          let mut icf_bf = 0.0
          if icf_bt == "float"
            icf_bf = float(icf_bv)
          end
          if icf_bt == "ident" && map_has(env_num, icf_bv)
            icf_bf = map_get(env_num, icf_bv)
          end
          if icf_iop == "+"
            icf_af = icf_af + icf_bf
          elif icf_iop == "-"
            icf_af = icf_af - icf_bf
          elif icf_iop == "*"
            icf_af = icf_af * icf_bf
          elif icf_iop == "/"
            icf_af = icf_af / icf_bf
          end
        end
      end
      if cur < tok_count && tok_values[cur] == ")"
        cur = cur + 1.0  // skip )
      end
      // apply math function
      let mut icf_r = icf_af
      if icf_fn == "abs"
        icf_r = abs(icf_af)
      elif icf_fn == "floor"
        icf_r = floor(icf_af)
      elif icf_fn == "ceil"
        icf_r = ceil(icf_af)
      elif icf_fn == "sqrt"
        icf_r = sqrt(icf_af)
      elif icf_fn == "round"
        icf_r = round(icf_af)
      end
      // read comparison op and rhs
      let icf_cop = tok_values[cur]
      cur = cur + 1.0
      let icf_rt = tok_types[cur]
      let icf_rv = tok_values[cur]
      cur = cur + 1.0
      let mut icf_rf = 0.0
      if icf_rt == "float"
        icf_rf = float(icf_rv)
      end
      if icf_rt == "ident" && map_has(env_num, icf_rv)
        icf_rf = map_get(env_num, icf_rv)
      end
      if icf_cop == "<"
        if icf_r < icf_rf
          icond = 1.0
        end
      end
      if icf_cop == ">"
        if icf_r > icf_rf
          icond = 1.0
        end
      end
      if icf_cop == "<="
        if icf_r <= icf_rf
          icond = 1.0
        end
      end
      if icf_cop == ">="
        if icf_r >= icf_rf
          icond = 1.0
        end
      end
      if icf_cop == "=="
        if icf_r == icf_rf
          icond = 1.0
        end
      end
      if icf_cop == "!="
        if icf_r != icf_rf
          icond = 1.0
        end
      end
    elif tok_values[cur] == "("
      // compound condition: (A op B || A op C) && D op E
      cur = cur + 1.0  // skip (
      let cpA_v = tok_values[cur]
      cur = cur + 1.0
      let cpA_op = tok_values[cur]
      cur = cur + 1.0
      let cpA_rhs_t = tok_types[cur]
      let cpA_rhs_v = tok_values[cur]
      cur = cur + 1.0
      let mut cpA_ls = ""
      if map_has(env_s, cpA_v)
        cpA_ls = map_get(env_s, cpA_v)
      end
      let mut cpA_rs = cpA_rhs_v
      if cpA_rhs_t == "ident" && map_has(env_s, cpA_rhs_v)
        cpA_rs = map_get(env_s, cpA_rhs_v)
      end
      let mut cpA_use_str = 0.0
      if cpA_rhs_t == "str"
        cpA_use_str = 1.0
      end
      if cpA_rhs_t == "ident" && map_has(env_s, cpA_rhs_v)
        if map_has(env_num, cpA_rhs_v)
        else
          cpA_use_str = 1.0
        end
      end
      if map_has(env_s, cpA_v)
        if map_has(env_num, cpA_v)
        else
          cpA_use_str = 1.0
        end
      end
      let mut cpA_lf = 0.0
      let mut cpA_rf = 0.0
      if map_has(env_num, cpA_v)
        cpA_lf = map_get(env_num, cpA_v)
      end
      if cpA_rhs_t == "float"
        cpA_rf = float(cpA_rhs_v)
      end
      if cpA_rhs_t == "ident" && map_has(env_num, cpA_rhs_v)
        cpA_rf = map_get(env_num, cpA_rhs_v)
      end
      let mut cpA_res = 0.0
      if cpA_use_str == 1.0
        if cpA_op == "=="
          if cpA_ls == cpA_rs
            cpA_res = 1.0
          end
        end
        if cpA_op == "!="
          if cpA_ls != cpA_rs
            cpA_res = 1.0
          end
        end
      else
        if cpA_op == "=="
          if cpA_lf == cpA_rf
            cpA_res = 1.0
          end
        end
        if cpA_op == "!="
          if cpA_lf != cpA_rf
            cpA_res = 1.0
          end
        end
      end
      let mut cp_group = cpA_res
      if cur < tok_count && tok_values[cur] == "||"
        cur = cur + 1.0  // skip ||
        let cpB_v = tok_values[cur]
        cur = cur + 1.0
        let cpB_op = tok_values[cur]
        cur = cur + 1.0
        let cpB_rhs_t = tok_types[cur]
        let cpB_rhs_v = tok_values[cur]
        cur = cur + 1.0
        let mut cpB_ls = ""
        if map_has(env_s, cpB_v)
          cpB_ls = map_get(env_s, cpB_v)
        end
        let mut cpB_rs = cpB_rhs_v
        if cpB_rhs_t == "ident" && map_has(env_s, cpB_rhs_v)
          cpB_rs = map_get(env_s, cpB_rhs_v)
        end
        let mut cpB_use_str = 0.0
        if cpB_rhs_t == "str"
          cpB_use_str = 1.0
        end
        if cpB_rhs_t == "ident" && map_has(env_s, cpB_rhs_v)
          if map_has(env_num, cpB_rhs_v)
          else
            cpB_use_str = 1.0
          end
        end
        if map_has(env_s, cpB_v)
          if map_has(env_num, cpB_v)
          else
            cpB_use_str = 1.0
          end
        end
        let mut cpB_lf = 0.0
        let mut cpB_rf = 0.0
        if map_has(env_num, cpB_v)
          cpB_lf = map_get(env_num, cpB_v)
        end
        if cpB_rhs_t == "float"
          cpB_rf = float(cpB_rhs_v)
        end
        if cpB_rhs_t == "ident" && map_has(env_num, cpB_rhs_v)
          cpB_rf = map_get(env_num, cpB_rhs_v)
        end
        let mut cpB_res = 0.0
        if cpB_use_str == 1.0
          if cpB_op == "=="
            if cpB_ls == cpB_rs
              cpB_res = 1.0
            end
          end
          if cpB_op == "!="
            if cpB_ls != cpB_rs
              cpB_res = 1.0
            end
          end
        else
          if cpB_op == "=="
            if cpB_lf == cpB_rf
              cpB_res = 1.0
            end
          end
          if cpB_op == "!="
            if cpB_lf != cpB_rf
              cpB_res = 1.0
            end
          end
        end
        if cpB_res == 1.0
          cp_group = 1.0
        end
      end
      if cur < tok_count && tok_values[cur] == ")"
        cur = cur + 1.0  // skip )
      end
      if cur < tok_count && tok_values[cur] == "&&"
        cur = cur + 1.0  // skip &&
        let cpC_lhs_v = tok_values[cur]
        cur = cur + 1.0
        let cpC_op = tok_values[cur]
        cur = cur + 1.0
        let cpC_rhs_t = tok_types[cur]
        let cpC_rhs_v = tok_values[cur]
        cur = cur + 1.0
        let mut cpC_ls = ""
        if map_has(env_s, cpC_lhs_v)
          cpC_ls = map_get(env_s, cpC_lhs_v)
        end
        let mut cpC_rs = cpC_rhs_v
        if cpC_rhs_t == "ident" && map_has(env_s, cpC_rhs_v)
          cpC_rs = map_get(env_s, cpC_rhs_v)
        end
        let mut cpC_use_str = 0.0
        if cpC_rhs_t == "str"
          cpC_use_str = 1.0
        end
        if cpC_rhs_t == "ident" && map_has(env_s, cpC_rhs_v)
          if map_has(env_num, cpC_rhs_v)
          else
            cpC_use_str = 1.0
          end
        end
        if map_has(env_s, cpC_lhs_v)
          if map_has(env_num, cpC_lhs_v)
          else
            cpC_use_str = 1.0
          end
        end
        let mut cpC_res = 0.0
        if cpC_use_str == 1.0
          if cpC_op == "=="
            if cpC_ls == cpC_rs
              cpC_res = 1.0
            end
          end
          if cpC_op == "!="
            if cpC_ls != cpC_rs
              cpC_res = 1.0
            end
          end
        end
        if cp_group == 1.0 && cpC_res == 1.0
          icond = 1.0
        end
      else
        if cp_group == 1.0
          icond = 1.0
        end
      end
    else
    // read: lhs op rhs
    it1 = tok_types[cur]
    iv1 = tok_values[cur]
    cur = cur + 1.0
    icop = tok_values[cur]
    cur = cur + 1.0
    it2 = tok_types[cur]
    iv2 = tok_values[cur]
    cur = cur + 1.0
    // handle array access LHS: if arr[idx] op rhs
    if icop == "["
      // iv2 already holds the index ident/float; cur points at "]"
      let mut iacc_idx = 0.0
      if it2 == "float"
        iacc_idx = float(iv2)
      end
      if it2 == "ident" && map_has(env_num, iv2)
        iacc_idx = map_get(env_num, iv2)
      end
      // skip ]
      if cur < tok_count && tok_values[cur] == "]"
        cur = cur + 1.0
      end
      // read real comparison op + rhs
      icop = tok_values[cur]
      cur = cur + 1.0
      it2 = tok_types[cur]
      iv2 = tok_values[cur]
      cur = cur + 1.0
      // resolve array element from inner env
      let iacc_key = "__arr_" + iv1
      it1 = "str"
      iv1 = ""
      if map_has(env_s, iacc_key)
        let iacc_enc = map_get(env_s, iacc_key)
        let iacc_parts = split(iacc_enc, SEP)
        if iacc_idx < len(iacc_parts)
          iv1 = iacc_parts[iacc_idx]
        end
      end
      if is_match(iv1, "^[0-9]")
        it1 = "float"
      end
      if is_match(iv1, "^-[0-9]")
        it1 = "float"
      end
    end
    // handle negative rhs: if x == -1.0
    let mut irhs_neg = 0.0
    if it2 == "op" && iv2 == "-"
      irhs_neg = 1.0
      it2 = tok_types[cur]
      iv2 = tok_values[cur]
      cur = cur + 1.0
    end
    // evaluate condition
    let mut ilf = 0.0
    if it1 == "float"
      ilf = float(iv1)
    end
    if it1 == "ident" && map_has(env_num, iv1)
      ilf = map_get(env_num, iv1)
    end
    let mut irf = 0.0
    if it2 == "float"
      irf = float(iv2)
    end
    if it2 == "ident" && map_has(env_num, iv2)
      irf = map_get(env_num, iv2)
    end
    if irhs_neg == 1.0
      irf = 0.0 - irf
    end
    // handle RHS arithmetic: if x == a + b, if x == 0.0 - 1.0 etc.
    if cur < tok_count && tok_types[cur] == "op"
      let irh_op1 = tok_values[cur]
      if irh_op1 == "+" || irh_op1 == "-" || irh_op1 == "*" || irh_op1 == "/"
        cur = cur + 1.0
        let irh_t2 = tok_types[cur]
        let irh_v2 = tok_values[cur]
        cur = cur + 1.0
        let mut irh_f2 = 0.0
        if irh_t2 == "float"
          irh_f2 = float(irh_v2)
        end
        if irh_t2 == "ident" && map_has(env_num, irh_v2)
          irh_f2 = map_get(env_num, irh_v2)
        end
        if irh_op1 == "+"
          irf = irf + irh_f2
        elif irh_op1 == "-"
          irf = irf - irh_f2
        elif irh_op1 == "*"
          irf = irf * irh_f2
        elif irh_op1 == "/"
          irf = irf / irh_f2
        end
      end
    end
    if icop == ">"
      if ilf > irf
        icond = 1.0
      end
    end
    if icop == "<"
      if ilf < irf
        icond = 1.0
      end
    end
    if icop == ">="
      if ilf >= irf
        icond = 1.0
      end
    end
    if icop == "<="
      if ilf <= irf
        icond = 1.0
      end
    end
    if icop == "=="
      if ilf == irf
        icond = 1.0
      end
    end
    if icop == "!="
      if ilf != irf
        icond = 1.0
      end
    end
    end  // close map_has else branch
    // String comparison (for c == "/" etc.) — only when non-numeric operands
    let mut iuse_str = 0.0
    if it1 == "str" || it2 == "str"
      iuse_str = 1.0
    end
    if it1 == "ident" && map_has(env_s, iv1)
      if map_has(env_num, iv1)
        // has numeric too - already handled
      else
        iuse_str = 1.0
      end
    end
    if it2 == "ident" && map_has(env_s, iv2)
      if map_has(env_num, iv2)
        // has numeric too
      else
        iuse_str = 1.0
      end
    end
    if iuse_str == 1.0
      icond = 0.0
      let mut ils = iv1
      if it1 == "ident" && map_has(env_s, iv1)
        ils = map_get(env_s, iv1)
      end
      let mut irs = iv2
      if it2 == "ident" && map_has(env_s, iv2)
        irs = map_get(env_s, iv2)
      end
      if icop == "=="
        if ils == irs
          icond = 1.0
        end
      end
      if icop == "!="
        if ils != irs
          icond = 1.0
        end
      end
    end
    // compound && in if (e.g. if co >= 48.0 && co <= 57.0 or if c == "x" && c2 == "y")
    while cur < tok_count && tok_values[cur] == "&&" && icond == 1.0
      cur = cur + 1.0  // skip &&
      let ia_t1 = tok_types[cur]
      let ia_v1 = tok_values[cur]
      cur = cur + 1.0
      let ia_op = tok_values[cur]
      cur = cur + 1.0
      let ia_t2 = tok_types[cur]
      let ia_v2 = tok_values[cur]
      cur = cur + 1.0
      if ia_op == "["
        // arr[idx] op rhs — supports arr[idx + offset] arithmetic index
        let mut ia_aidx = 0.0
        if ia_t2 == "ident" && map_has(env_num, ia_v2)
          ia_aidx = map_get(env_num, ia_v2)
        end
        if ia_t2 == "float"
          ia_aidx = float(ia_v2)
        end
        // arithmetic in index: idx + float
        if cur < tok_count && tok_values[cur] == "+"
          cur = cur + 1.0
          let ia_it = tok_types[cur]
          let ia_iv = tok_values[cur]
          cur = cur + 1.0
          let mut ia_ioff = 0.0
          if ia_it == "float"
            ia_ioff = float(ia_iv)
          elif ia_it == "ident" && map_has(env_num, ia_iv)
            ia_ioff = map_get(env_num, ia_iv)
          end
          ia_aidx = ia_aidx + ia_ioff
        elif cur < tok_count && tok_values[cur] == "-"
          cur = cur + 1.0
          let ia_it2 = tok_types[cur]
          let ia_iv2 = tok_values[cur]
          cur = cur + 1.0
          let mut ia_ioff2 = 0.0
          if ia_it2 == "float"
            ia_ioff2 = float(ia_iv2)
          elif ia_it2 == "ident" && map_has(env_num, ia_iv2)
            ia_ioff2 = map_get(env_num, ia_iv2)
          end
          ia_aidx = ia_aidx - ia_ioff2
        end
        if cur < tok_count && tok_values[cur] == "]"
          cur = cur + 1.0
        end
        let ia_aop = tok_values[cur]
        cur = cur + 1.0
        let ia_rt3 = tok_types[cur]
        let ia_rv3 = tok_values[cur]
        cur = cur + 1.0
        let ia_akey = "__arr_" + ia_v1
        let mut ia_aelem = ""
        if map_has(env_s, ia_akey)
          let ia_aenc = map_get(env_s, ia_akey)
          let ia_aparts = split(ia_aenc, SEP)
          let ia_ai = ia_aidx
          if ia_ai < len(ia_aparts)
            ia_aelem = ia_aparts[ia_ai]
          end
        end
        let mut ia_rhs_s = ia_rv3
        if ia_rt3 == "ident" && map_has(env_s, ia_rv3)
          ia_rhs_s = map_get(env_s, ia_rv3)
        end
        if ia_aop == "=="
          if ia_aelem != ia_rhs_s
            icond = 0.0
          end
        end
        if ia_aop == "!="
          if ia_aelem == ia_rhs_s
            icond = 0.0
          end
        end
      elif ia_v1 == "map_has"
        // && map_has(m, k) == 0.0 / != 0.0 / bare
        // ia_op = "(", ia_v2 = map name; cur at: , key ) [== cmp]
        cur = cur + 1.0  // skip ,
        let iamh_kt = tok_types[cur]
        let iamh_kv = tok_values[cur]
        cur = cur + 1.0  // skip key
        if cur < tok_count && tok_values[cur] == ")"
          cur = cur + 1.0  // skip )
        end
        let mut iamh_k = iamh_kv
        if iamh_kt == "ident" && map_has(env_s, iamh_kv)
          iamh_k = map_get(env_s, iamh_kv)
        end
        let iamh_compound = "__map_" + ia_v2 + "." + iamh_k
        let mut iamh_found = 0.0
        if map_has(env_s, iamh_compound) || map_has(env_num, iamh_compound)
          iamh_found = 1.0
        end
        if cur < tok_count && tok_values[cur] == "=="
          cur = cur + 1.0
          let iamh_cmp_v = tok_values[cur]
          cur = cur + 1.0
          let iamh_cmp_f = float(iamh_cmp_v)
          if iamh_found != iamh_cmp_f
            icond = 0.0
          end
        elif cur < tok_count && tok_values[cur] == "!="
          cur = cur + 1.0
          let iamh_cmp2_v = tok_values[cur]
          cur = cur + 1.0
          let iamh_cmp2_f = float(iamh_cmp2_v)
          if iamh_found == iamh_cmp2_f
            icond = 0.0
          end
        else
          if iamh_found == 0.0
            icond = 0.0
          end
        end
      else
        let mut ia_str = 0.0
        if ia_t1 == "str" || ia_t2 == "str"
          ia_str = 1.0
        end
        if ia_t1 == "ident" && map_has(env_s, ia_v1)
          if map_has(env_num, ia_v1)
          else
            ia_str = 1.0
          end
        end
        if ia_t2 == "ident" && map_has(env_s, ia_v2)
          if map_has(env_num, ia_v2)
          else
            ia_str = 1.0
          end
        end
        if ia_str == 1.0
          let mut ia_ls = ia_v1
          if ia_t1 == "ident" && map_has(env_s, ia_v1)
            ia_ls = map_get(env_s, ia_v1)
          end
          let mut ia_rs = ia_v2
          if ia_t2 == "ident" && map_has(env_s, ia_v2)
            ia_rs = map_get(env_s, ia_v2)
          end
          if ia_op == "=="
            if ia_ls != ia_rs
              icond = 0.0
            end
          end
          if ia_op == "!="
            if ia_ls == ia_rs
              icond = 0.0
            end
          end
        else
          let mut ia_lf = 0.0
          if ia_t1 == "float"
            ia_lf = float(ia_v1)
          end
          if ia_t1 == "ident" && map_has(env_num, ia_v1)
            ia_lf = map_get(env_num, ia_v1)
          end
          let mut ia_rf = 0.0
          if ia_t2 == "float"
            ia_rf = float(ia_v2)
          end
          if ia_t2 == "ident" && map_has(env_num, ia_v2)
            ia_rf = map_get(env_num, ia_v2)
          end
          if ia_op == ">="
            if ia_lf < ia_rf
              icond = 0.0
            end
          end
          if ia_op == "<="
            if ia_lf > ia_rf
              icond = 0.0
            end
          end
          if ia_op == ">"
            if ia_lf <= ia_rf
              icond = 0.0
            end
          end
          if ia_op == "<"
            if ia_lf >= ia_rf
              icond = 0.0
            end
          end
          if ia_op == "=="
            if ia_lf != ia_rf
              icond = 0.0
            end
          end
          if ia_op == "!="
            if ia_lf == ia_rf
              icond = 0.0
            end
          end
        end
      end
    end
    // compound || in if (e.g. if a == "x" || b == "y")
    while cur < tok_count && tok_values[cur] == "||"
      cur = cur + 1.0  // skip ||
      if icond == 1.0
        // already true — skip this || clause to end of line
        while cur < tok_count && tok_types[cur] != "nl"
          cur = cur + 1.0
        end
      else
        // evaluate this clause and OR into icond
        let ior_t1 = tok_types[cur]
        let ior_v1 = tok_values[cur]
        cur = cur + 1.0
        let ior_op = tok_values[cur]
        cur = cur + 1.0
        let ior_t2 = tok_types[cur]
        let ior_v2 = tok_values[cur]
        cur = cur + 1.0
        let mut ior_use_str = 0.0
        if ior_t1 == "str" || ior_t2 == "str"
          ior_use_str = 1.0
        end
        if ior_t1 == "ident" && map_has(env_s, ior_v1)
          if map_has(env_num, ior_v1)
          else
            ior_use_str = 1.0
          end
        end
        if ior_t2 == "ident" && map_has(env_s, ior_v2)
          if map_has(env_num, ior_v2)
          else
            ior_use_str = 1.0
          end
        end
        if ior_use_str == 1.0
          let mut ior_ls = ior_v1
          if ior_t1 == "ident" && map_has(env_s, ior_v1)
            ior_ls = map_get(env_s, ior_v1)
          end
          let mut ior_rs = ior_v2
          if ior_t2 == "ident" && map_has(env_s, ior_v2)
            ior_rs = map_get(env_s, ior_v2)
          end
          if ior_op == "=="
            if ior_ls == ior_rs
              icond = 1.0
            end
          end
          if ior_op == "!="
            if ior_ls != ior_rs
              icond = 1.0
            end
          end
        else
          let mut ior_lf = 0.0
          if ior_t1 == "float"
            ior_lf = float(ior_v1)
          end
          if ior_t1 == "ident" && map_has(env_num, ior_v1)
            ior_lf = map_get(env_num, ior_v1)
          end
          let mut ior_rf = 0.0
          if ior_t2 == "float"
            ior_rf = float(ior_v2)
          end
          if ior_t2 == "ident" && map_has(env_num, ior_v2)
            ior_rf = map_get(env_num, ior_v2)
          end
          if ior_op == "=="
            if ior_lf == ior_rf
              icond = 1.0
            end
          end
          if ior_op == "!="
            if ior_lf != ior_rf
              icond = 1.0
            end
          end
          if ior_op == ">"
            if ior_lf > ior_rf
              icond = 1.0
            end
          end
          if ior_op == "<"
            if ior_lf < ior_rf
              icond = 1.0
            end
          end
        end
      end
    end
    // If condition true: push if_exec; false: push if_skip and skip to next branch
    if icond == 1.0
      push(cstack_type, "if_exec")
      push(cstack_pos, 0.0)
    else
      push(cstack_type, "if_skip")
      push(cstack_pos, 0.0)
      // skip body to next elif/else/end at depth 0
      let mut sb_d = 0.0
      let mut sb_done = 0.0
      while cur < tok_count && sb_done == 0.0
        let sbt = tok_types[cur]
        let sbv = tok_values[cur]
        if sbt == "kw" && (sbv == "if" || sbv == "while" || sbv == "for")
          sb_d = sb_d + 1.0
          cur = cur + 1.0
        elif sbt == "kw" && sbv == "end"
          if sb_d > 0.0
            sb_d = sb_d - 1.0
          else
            // consumed end: also pop the if_skip frame
            let _sb_pt = pop(cstack_type)
            let _sb_pp = pop(cstack_pos)
            sb_done = 1.0
          end
          cur = cur + 1.0
        elif sbt == "kw" && (sbv == "elif" || sbv == "else") && sb_d == 0.0
          sb_done = 1.0  // stop; let main loop handle elif/else
        else
          cur = cur + 1.0
        end
      end
    end

  // elif cond ... (in interpreted program)
  elif tt == "kw" && tv == "elif"
    cur = cur + 1.0  // skip "elif"
    let elif_cs_len = len(cstack_type)
    if elif_cs_len > 0.0
      let elif_top_idx = elif_cs_len - 1.0
      let elif_top = cstack_type[elif_top_idx]
      if elif_top == "if_exec"
        // already took a branch — skip rest of if/elif/else to matching end
        let _elif_pt = pop(cstack_type)
        let _elif_pp = pop(cstack_pos)
        let mut elif_sed = 1.0
        while cur < tok_count && elif_sed > 0.0
          let est = tok_types[cur]
          let esv = tok_values[cur]
          cur = cur + 1.0
          if est == "kw" && (esv == "if" || esv == "while" || esv == "for")
            elif_sed = elif_sed + 1.0
          end
          if est == "kw" && esv == "end"
            elif_sed = elif_sed - 1.0
          end
        end
      elif elif_top == "if_skip"
        // no branch taken yet — evaluate elif condition
        let mut elif_cond = 0.0
        let mut elif_it1 = ""
        let mut elif_iv1 = ""
        let mut elif_it2 = ""
        let mut elif_iv2 = ""
        let mut elif_op = ""
        if tok_values[cur] == "map_has"
          cur = cur + 1.0
          cur = cur + 1.0
          let emhm = tok_values[cur]
          cur = cur + 1.0
          cur = cur + 1.0
          let emhk_t = tok_types[cur]
          let emhk_v = tok_values[cur]
          cur = cur + 1.0
          if cur < tok_count && tok_values[cur] == ")"
            cur = cur + 1.0
          end
          let mut emhk = emhk_v
          if emhk_t == "ident" && map_has(env_s, emhk_v)
            emhk = map_get(env_s, emhk_v)
          end
          let emh_compound = "__map_" + emhm + "." + emhk
          if map_has(env_s, emh_compound) || map_has(env_num, emh_compound)
            elif_cond = 1.0
          end
          // optional negation: map_has(...) == 0.0 / != 0.0
          if cur < tok_count && tok_values[cur] == "=="
            cur = cur + 1.0
            let emhcmp_v = tok_values[cur]
            cur = cur + 1.0
            let emhcmp_f = float(emhcmp_v)
            if elif_cond == emhcmp_f
              elif_cond = 1.0
            else
              elif_cond = 0.0
            end
          end
          if cur < tok_count && tok_values[cur] == "!="
            cur = cur + 1.0
            let emhcmp2_v = tok_values[cur]
            cur = cur + 1.0
            let emhcmp2_f = float(emhcmp2_v)
            if elif_cond != emhcmp2_f
              elif_cond = 1.0
            else
              elif_cond = 0.0
            end
          end
        elif tok_values[cur] == "is_match"
          // is_match(ident_or_char_at(src,pos), pattern) as elif condition
          cur = cur + 1.0  // skip is_match
          cur = cur + 1.0  // skip (
          let eismt = tok_types[cur]
          let eismv = tok_values[cur]
          cur = cur + 1.0
          let mut eism_s = ""
          if eismv == "char_at"
            // nested: is_match(char_at(src_var, pos_var), pattern)
            cur = cur + 1.0  // skip (
            let eism_ca_sv = tok_values[cur]
            cur = cur + 1.0
            cur = cur + 1.0  // skip ,
            let eism_ca_pv = tok_values[cur]
            cur = cur + 1.0
            cur = cur + 1.0  // skip inner )
            cur = cur + 1.0  // skip ,
            let eism_ca_src = map_get(env_s, eism_ca_sv)
            let mut eism_ca_pos = 0.0
            if map_has(env_num, eism_ca_pv)
              eism_ca_pos = map_get(env_num, eism_ca_pv)
            end
            eism_s = char_at(eism_ca_src, eism_ca_pos)
          else
            cur = cur + 1.0  // skip ,
            if eismt == "ident" && map_has(env_s, eismv)
              eism_s = map_get(env_s, eismv)
            else
              eism_s = eismv
            end
          end
          let eismp = tok_values[cur]
          cur = cur + 1.0
          cur = cur + 1.0  // skip )
          let eism_r = is_match(eism_s, eismp)
          if eism_r == 1.0
            elif_cond = 1.0
          end
        elif tok_values[cur] == "len"
          // len(x) op rhs as elif condition
          cur = cur + 1.0  // skip "len"
          cur = cur + 1.0  // skip (
          let eln_v = tok_values[cur]
          cur = cur + 1.0  // skip arg
          cur = cur + 1.0  // skip )
          let eln_op = tok_values[cur]
          cur = cur + 1.0
          let eln_rt = tok_types[cur]
          let eln_rv = tok_values[cur]
          cur = cur + 1.0
          let mut eln_val = 0.0
          let eln_key = "__len_" + eln_v
          if map_has(env_num, eln_key)
            eln_val = map_get(env_num, eln_key)
          else
            if map_has(env_s, eln_v)
              let eln_s = map_get(env_s, eln_v)
              eln_val = len(eln_s)
            end
          end
          let mut eln_rhs = 0.0
          if eln_rt == "float"
            eln_rhs = float(eln_rv)
          end
          if eln_rt == "ident" && map_has(env_num, eln_rv)
            eln_rhs = map_get(env_num, eln_rv)
          end
          if eln_op == ">"
            if eln_val > eln_rhs
              elif_cond = 1.0
            end
          end
          if eln_op == "<"
            if eln_val < eln_rhs
              elif_cond = 1.0
            end
          end
          if eln_op == ">="
            if eln_val >= eln_rhs
              elif_cond = 1.0
            end
          end
          if eln_op == "<="
            if eln_val <= eln_rhs
              elif_cond = 1.0
            end
          end
          if eln_op == "=="
            if eln_val == eln_rhs
              elif_cond = 1.0
            end
          end
          if eln_op == "!="
            if eln_val != eln_rhs
              elif_cond = 1.0
            end
          end
        elif tok_values[cur] == "contains"
          // contains(str, pat) as boolean elif condition
          cur = cur + 1.0  // skip "contains"
          cur = cur + 1.0  // skip (
          let eco_at = tok_types[cur]
          let eco_av = tok_values[cur]
          cur = cur + 1.0
          cur = cur + 1.0  // skip ,
          let eco_pt = tok_types[cur]
          let eco_pv = tok_values[cur]
          cur = cur + 1.0
          cur = cur + 1.0  // skip )
          let mut eco_s = eco_av
          if eco_at == "ident" && map_has(env_s, eco_av)
            eco_s = map_get(env_s, eco_av)
          end
          let mut eco_p = eco_pv
          if eco_pt == "ident" && map_has(env_s, eco_pv)
            eco_p = map_get(env_s, eco_pv)
          end
          let eco_r = contains(eco_s, eco_p)
          if eco_r == 1.0
            elif_cond = 1.0
          end
        elif tok_values[cur] == "starts_with"
          // starts_with(str, pat) as boolean elif condition
          cur = cur + 1.0  // skip "starts_with"
          cur = cur + 1.0  // skip (
          let esw_at = tok_types[cur]
          let esw_av = tok_values[cur]
          cur = cur + 1.0
          cur = cur + 1.0  // skip ,
          let esw_pt = tok_types[cur]
          let esw_pv = tok_values[cur]
          cur = cur + 1.0
          cur = cur + 1.0  // skip )
          let mut esw_s = esw_av
          if esw_at == "ident" && map_has(env_s, esw_av)
            esw_s = map_get(env_s, esw_av)
          end
          let mut esw_p = esw_pv
          if esw_pt == "ident" && map_has(env_s, esw_pv)
            esw_p = map_get(env_s, esw_pv)
          end
          let esw_r = starts_with(esw_s, esw_p)
          if esw_r == 1.0
            elif_cond = 1.0
          end
        elif tok_values[cur] == "ends_with"
          // ends_with(str, pat) as boolean elif condition
          cur = cur + 1.0  // skip "ends_with"
          cur = cur + 1.0  // skip (
          let eew_at = tok_types[cur]
          let eew_av = tok_values[cur]
          cur = cur + 1.0
          cur = cur + 1.0  // skip ,
          let eew_pt = tok_types[cur]
          let eew_pv = tok_values[cur]
          cur = cur + 1.0
          cur = cur + 1.0  // skip )
          let mut eew_s = eew_av
          if eew_at == "ident" && map_has(env_s, eew_av)
            eew_s = map_get(env_s, eew_av)
          end
          let mut eew_p = eew_pv
          if eew_pt == "ident" && map_has(env_s, eew_pv)
            eew_p = map_get(env_s, eew_pv)
          end
          let eew_r = ends_with(eew_s, eew_p)
          if eew_r == 1.0
            elif_cond = 1.0
          end
        elif tok_values[cur] == "char_at"
          // char_at(str_var, idx) == / != "char" as elif condition
          cur = cur + 1.0  // skip "char_at"
          cur = cur + 1.0  // skip (
          let eca_sv = tok_values[cur]
          cur = cur + 1.0  // skip str var
          cur = cur + 1.0  // skip ,
          let eca_it = tok_types[cur]
          let eca_iv = tok_values[cur]
          cur = cur + 1.0  // skip idx
          cur = cur + 1.0  // skip )
          let eca_op = tok_values[cur]
          cur = cur + 1.0  // skip op
          let eca_rt = tok_types[cur]
          let eca_rv = tok_values[cur]
          cur = cur + 1.0  // skip rhs
          let mut eca_src = ""
          if map_has(env_s, eca_sv)
            eca_src = map_get(env_s, eca_sv)
          end
          let mut eca_idx = 0.0
          if eca_it == "float"
            eca_idx = float(eca_iv)
          end
          if eca_it == "ident" && map_has(env_num, eca_iv)
            eca_idx = map_get(env_num, eca_iv)
          end
          let eca_c = char_at(eca_src, eca_idx)
          let mut eca_rhs = eca_rv
          if eca_rt == "ident" && map_has(env_s, eca_rv)
            eca_rhs = map_get(env_s, eca_rv)
          end
          if eca_op == "=="
            if eca_c == eca_rhs
              elif_cond = 1.0
            end
          end
          if eca_op == "!="
            if eca_c != eca_rhs
              elif_cond = 1.0
            end
          end
        else
          elif_it1 = tok_types[cur]
          elif_iv1 = tok_values[cur]
          cur = cur + 1.0
          elif_op = tok_values[cur]
          cur = cur + 1.0
          elif_it2 = tok_types[cur]
          elif_iv2 = tok_values[cur]
          cur = cur + 1.0
          // handle array access LHS: elif arr[idx] op rhs
          if elif_op == "["
            let mut elacc_idx = 0.0
            if elif_it2 == "float"
              elacc_idx = float(elif_iv2)
            end
            if elif_it2 == "ident" && map_has(env_num, elif_iv2)
              elacc_idx = map_get(env_num, elif_iv2)
            end
            // skip ]
            if cur < tok_count && tok_values[cur] == "]"
              cur = cur + 1.0
            end
            // read real comparison op + rhs
            elif_op = tok_values[cur]
            cur = cur + 1.0
            elif_it2 = tok_types[cur]
            elif_iv2 = tok_values[cur]
            cur = cur + 1.0
            // resolve array element
            let elacc_key = "__arr_" + elif_iv1
            elif_it1 = "str"
            elif_iv1 = ""
            if map_has(env_s, elacc_key)
              let elacc_enc = map_get(env_s, elacc_key)
              let elacc_parts = split(elacc_enc, SEP)
              if elacc_idx < len(elacc_parts)
                elif_iv1 = elacc_parts[elacc_idx]
              end
            end
            if is_match(elif_iv1, "^[0-9]")
              elif_it1 = "float"
            end
            if is_match(elif_iv1, "^-[0-9]")
              elif_it1 = "float"
            end
          end
          // numeric comparison
          let mut ellf = 0.0
          if elif_it1 == "float"
            ellf = float(elif_iv1)
          end
          if elif_it1 == "ident" && map_has(env_num, elif_iv1)
            ellf = map_get(env_num, elif_iv1)
          end
          let mut elrf = 0.0
          if elif_it2 == "float"
            elrf = float(elif_iv2)
          end
          if elif_it2 == "ident" && map_has(env_num, elif_iv2)
            elrf = map_get(env_num, elif_iv2)
          end
          if elif_op == ">"
            if ellf > elrf
              elif_cond = 1.0
            end
          end
          if elif_op == "<"
            if ellf < elrf
              elif_cond = 1.0
            end
          end
          if elif_op == ">="
            if ellf >= elrf
              elif_cond = 1.0
            end
          end
          if elif_op == "<="
            if ellf <= elrf
              elif_cond = 1.0
            end
          end
          if elif_op == "=="
            if ellf == elrf
              elif_cond = 1.0
            end
          end
          if elif_op == "!="
            if ellf != elrf
              elif_cond = 1.0
            end
          end
          // string comparison
          let mut eluse_str = 0.0
          if elif_it1 == "str" || elif_it2 == "str"
            eluse_str = 1.0
          end
          if elif_it1 == "ident" && map_has(env_s, elif_iv1)
            if map_has(env_num, elif_iv1)
              // numeric too
            else
              eluse_str = 1.0
            end
          end
          if elif_it2 == "ident" && map_has(env_s, elif_iv2)
            if map_has(env_num, elif_iv2)
              // numeric too
            else
              eluse_str = 1.0
            end
          end
          if eluse_str == 1.0
            elif_cond = 0.0
            let mut els = elif_iv1
            if elif_it1 == "ident" && map_has(env_s, elif_iv1)
              els = map_get(env_s, elif_iv1)
            end
            let mut ers = elif_iv2
            if elif_it2 == "ident" && map_has(env_s, elif_iv2)
              ers = map_get(env_s, elif_iv2)
            end
            if elif_op == "=="
              if els == ers
                elif_cond = 1.0
              end
            end
            if elif_op == "!="
              if els != ers
                elif_cond = 1.0
              end
            end
          end
        end
        // compound && in elif (e.g. elif co >= 48.0 && co <= 57.0 or elif c == "x" && c2 == "y")
        while cur < tok_count && tok_values[cur] == "&&" && elif_cond == 1.0
          cur = cur + 1.0  // skip &&
          let ea_t1 = tok_types[cur]
          let ea_v1 = tok_values[cur]
          cur = cur + 1.0
          let ea_op = tok_values[cur]
          cur = cur + 1.0
          let ea_t2 = tok_types[cur]
          let ea_v2 = tok_values[cur]
          cur = cur + 1.0
          if ea_op == "["
            // arr[idx] op rhs — supports arr[idx + offset] arithmetic index
            let mut ea_aidx = 0.0
            if ea_t2 == "ident" && map_has(env_num, ea_v2)
              ea_aidx = map_get(env_num, ea_v2)
            end
            if ea_t2 == "float"
              ea_aidx = float(ea_v2)
            end
            // arithmetic in index: idx + float
            if cur < tok_count && tok_values[cur] == "+"
              cur = cur + 1.0
              let ea_it = tok_types[cur]
              let ea_iv = tok_values[cur]
              cur = cur + 1.0
              let mut ea_ioff = 0.0
              if ea_it == "float"
                ea_ioff = float(ea_iv)
              elif ea_it == "ident" && map_has(env_num, ea_iv)
                ea_ioff = map_get(env_num, ea_iv)
              end
              ea_aidx = ea_aidx + ea_ioff
            elif cur < tok_count && tok_values[cur] == "-"
              cur = cur + 1.0
              let ea_it2 = tok_types[cur]
              let ea_iv2 = tok_values[cur]
              cur = cur + 1.0
              let mut ea_ioff2 = 0.0
              if ea_it2 == "float"
                ea_ioff2 = float(ea_iv2)
              elif ea_it2 == "ident" && map_has(env_num, ea_iv2)
                ea_ioff2 = map_get(env_num, ea_iv2)
              end
              ea_aidx = ea_aidx - ea_ioff2
            end
            if cur < tok_count && tok_values[cur] == "]"
              cur = cur + 1.0
            end
            let ea_aop = tok_values[cur]
            cur = cur + 1.0
            let ea_rt3 = tok_types[cur]
            let ea_rv3 = tok_values[cur]
            cur = cur + 1.0
            let ea_akey = "__arr_" + ea_v1
            let mut ea_aelem = ""
            if map_has(env_s, ea_akey)
              let ea_aenc = map_get(env_s, ea_akey)
              let ea_aparts = split(ea_aenc, SEP)
              let ea_ai = ea_aidx
              if ea_ai < len(ea_aparts)
                ea_aelem = ea_aparts[ea_ai]
              end
            end
            let mut ea_rhs_s = ea_rv3
            if ea_rt3 == "ident" && map_has(env_s, ea_rv3)
              ea_rhs_s = map_get(env_s, ea_rv3)
            end
            if ea_aop == "=="
              if ea_aelem != ea_rhs_s
                elif_cond = 0.0
              end
            end
            if ea_aop == "!="
              if ea_aelem == ea_rhs_s
                elif_cond = 0.0
              end
            end
          elif ea_op == "+" || ea_op == "-"
            // arithmetic LHS: ident + float op rhs (e.g. pi + 1.0 < tok_count)
            let mut ea_arith_lf = 0.0
            if ea_t1 == "ident" && map_has(env_num, ea_v1)
              ea_arith_lf = map_get(env_num, ea_v1)
            end
            let mut ea_arith_rhs2 = 0.0
            if ea_t2 == "float"
              ea_arith_rhs2 = float(ea_v2)
            elif ea_t2 == "ident" && map_has(env_num, ea_v2)
              ea_arith_rhs2 = map_get(env_num, ea_v2)
            end
            if ea_op == "+"
              ea_arith_lf = ea_arith_lf + ea_arith_rhs2
            else
              ea_arith_lf = ea_arith_lf - ea_arith_rhs2
            end
            let ea_arith_cmpop = tok_values[cur]
            cur = cur + 1.0
            let ea_arith_rt = tok_types[cur]
            let ea_arith_rv = tok_values[cur]
            cur = cur + 1.0
            let mut ea_arith_rhs = 0.0
            if ea_arith_rt == "float"
              ea_arith_rhs = float(ea_arith_rv)
            elif ea_arith_rt == "ident" && map_has(env_num, ea_arith_rv)
              ea_arith_rhs = map_get(env_num, ea_arith_rv)
            end
            if ea_arith_cmpop == "<"
              if ea_arith_lf >= ea_arith_rhs
                elif_cond = 0.0
              end
            end
            if ea_arith_cmpop == ">"
              if ea_arith_lf <= ea_arith_rhs
                elif_cond = 0.0
              end
            end
            if ea_arith_cmpop == "<="
              if ea_arith_lf > ea_arith_rhs
                elif_cond = 0.0
              end
            end
            if ea_arith_cmpop == ">="
              if ea_arith_lf < ea_arith_rhs
                elif_cond = 0.0
              end
            end
            if ea_arith_cmpop == "=="
              if ea_arith_lf != ea_arith_rhs
                elif_cond = 0.0
              end
            end
            if ea_arith_cmpop == "!="
              if ea_arith_lf == ea_arith_rhs
                elif_cond = 0.0
              end
            end
          elif ea_v1 == "map_has"
            // && map_has(m, k) == 0.0 / != 0.0 / bare in elif clause
            // ea_op = "(", ea_v2 = map name; cur at: , key ) [== cmp]
            cur = cur + 1.0  // skip ,
            let eamh_kt = tok_types[cur]
            let eamh_kv = tok_values[cur]
            cur = cur + 1.0  // skip key
            if cur < tok_count && tok_values[cur] == ")"
              cur = cur + 1.0  // skip )
            end
            let mut eamh_k = eamh_kv
            if eamh_kt == "ident" && map_has(env_s, eamh_kv)
              eamh_k = map_get(env_s, eamh_kv)
            end
            let eamh_compound = "__map_" + ea_v2 + "." + eamh_k
            let mut eamh_found = 0.0
            if map_has(env_s, eamh_compound) || map_has(env_num, eamh_compound)
              eamh_found = 1.0
            end
            if cur < tok_count && tok_values[cur] == "=="
              cur = cur + 1.0
              let eamh_cmp_v = tok_values[cur]
              cur = cur + 1.0
              let eamh_cmp_f = float(eamh_cmp_v)
              if eamh_found != eamh_cmp_f
                elif_cond = 0.0
              end
            elif cur < tok_count && tok_values[cur] == "!="
              cur = cur + 1.0
              let eamh_cmp2_v = tok_values[cur]
              cur = cur + 1.0
              let eamh_cmp2_f = float(eamh_cmp2_v)
              if eamh_found == eamh_cmp2_f
                elif_cond = 0.0
              end
            else
              if eamh_found == 0.0
                elif_cond = 0.0
              end
            end
          elif ea_v1 == "char_at"
            // && char_at(str_var, idx_expr) == / != "char"
            // ea_v2 = str_var (already read); ea_op = "("; cur is at ","
            cur = cur + 1.0  // skip ,
            let eaca_it = tok_types[cur]
            let eaca_iv = tok_values[cur]
            cur = cur + 1.0  // skip idx
            let mut eaca_idx = 0.0
            if eaca_it == "float"
              eaca_idx = float(eaca_iv)
            end
            if eaca_it == "ident" && map_has(env_num, eaca_iv)
              eaca_idx = map_get(env_num, eaca_iv)
            end
            // arithmetic in index: idx + offset or idx - offset
            if cur < tok_count && tok_values[cur] == "+"
              cur = cur + 1.0  // skip +
              let eaca_ot = tok_types[cur]
              let eaca_ov = tok_values[cur]
              cur = cur + 1.0  // skip operand
              let mut eaca_off = 0.0
              if eaca_ot == "float"
                eaca_off = float(eaca_ov)
              end
              if eaca_ot == "ident" && map_has(env_num, eaca_ov)
                eaca_off = map_get(env_num, eaca_ov)
              end
              eaca_idx = eaca_idx + eaca_off
            elif cur < tok_count && tok_values[cur] == "-"
              cur = cur + 1.0  // skip -
              let eaca_ot2 = tok_types[cur]
              let eaca_ov2 = tok_values[cur]
              cur = cur + 1.0  // skip operand
              let mut eaca_off2 = 0.0
              if eaca_ot2 == "float"
                eaca_off2 = float(eaca_ov2)
              end
              if eaca_ot2 == "ident" && map_has(env_num, eaca_ov2)
                eaca_off2 = map_get(env_num, eaca_ov2)
              end
              eaca_idx = eaca_idx - eaca_off2
            end
            if cur < tok_count && tok_values[cur] == ")"
              cur = cur + 1.0  // skip )
            end
            let eaca_op = tok_values[cur]
            cur = cur + 1.0  // skip comparison op
            let eaca_rt = tok_types[cur]
            let eaca_rv = tok_values[cur]
            cur = cur + 1.0  // skip rhs
            let mut eaca_src = ""
            if map_has(env_s, ea_v2)
              eaca_src = map_get(env_s, ea_v2)
            end
            let eaca_c = char_at(eaca_src, eaca_idx)
            let mut eaca_rhs = eaca_rv
            if eaca_rt == "ident" && map_has(env_s, eaca_rv)
              eaca_rhs = map_get(env_s, eaca_rv)
            end
            if eaca_op == "=="
              if eaca_c != eaca_rhs
                elif_cond = 0.0
              end
            end
            if eaca_op == "!="
              if eaca_c == eaca_rhs
                elif_cond = 0.0
              end
            end
          else
            // detect string vs numeric
            let mut ea_str = 0.0
            if ea_t1 == "str" || ea_t2 == "str"
              ea_str = 1.0
            end
            if ea_t1 == "ident" && map_has(env_s, ea_v1)
              if map_has(env_num, ea_v1)
              else
                ea_str = 1.0
              end
            end
            if ea_t2 == "ident" && map_has(env_s, ea_v2)
              if map_has(env_num, ea_v2)
              else
                ea_str = 1.0
              end
            end
            if ea_str == 1.0
              // string comparison
              let mut ea_ls = ea_v1
              if ea_t1 == "ident" && map_has(env_s, ea_v1)
                ea_ls = map_get(env_s, ea_v1)
              end
              let mut ea_rs = ea_v2
              if ea_t2 == "ident" && map_has(env_s, ea_v2)
                ea_rs = map_get(env_s, ea_v2)
              end
              if ea_op == "=="
                if ea_ls != ea_rs
                  elif_cond = 0.0
                end
              end
              if ea_op == "!="
                if ea_ls == ea_rs
                  elif_cond = 0.0
                end
              end
            else
              // numeric comparison
              let mut ea_lf = 0.0
              if ea_t1 == "float"
                ea_lf = float(ea_v1)
              end
              if ea_t1 == "ident" && map_has(env_num, ea_v1)
                ea_lf = map_get(env_num, ea_v1)
              end
              let mut ea_rf = 0.0
              if ea_t2 == "float"
                ea_rf = float(ea_v2)
              end
              if ea_t2 == "ident" && map_has(env_num, ea_v2)
                ea_rf = map_get(env_num, ea_v2)
              end
              if ea_op == ">="
                if ea_lf < ea_rf
                  elif_cond = 0.0
                end
              end
              if ea_op == "<="
                if ea_lf > ea_rf
                  elif_cond = 0.0
                end
              end
              if ea_op == ">"
                if ea_lf <= ea_rf
                  elif_cond = 0.0
                end
              end
              if ea_op == "<"
                if ea_lf >= ea_rf
                  elif_cond = 0.0
                end
              end
              if ea_op == "=="
                if ea_lf != ea_rf
                  elif_cond = 0.0
                end
              end
              if ea_op == "!="
                if ea_lf == ea_rf
                  elif_cond = 0.0
                end
              end
            end
          end
        end
        if elif_cond == 1.0
          // take this branch
          let _ec_pt = pop(cstack_type)
          let _ec_pp = pop(cstack_pos)
          push(cstack_type, "if_exec")
          push(cstack_pos, 0.0)
        else
          // keep if_skip; skip this elif body to next elif/else/end
          let mut esb_d = 0.0
          let mut esb_done = 0.0
          while cur < tok_count && esb_done == 0.0
            let esbt = tok_types[cur]
            let esbv = tok_values[cur]
            if esbt == "kw" && (esbv == "if" || esbv == "while" || esbv == "for")
              esb_d = esb_d + 1.0
              cur = cur + 1.0
            elif esbt == "kw" && esbv == "end"
              if esb_d > 0.0
                esb_d = esb_d - 1.0
              else
                let _esb_pt = pop(cstack_type)
                let _esb_pp = pop(cstack_pos)
                esb_done = 1.0
              end
              cur = cur + 1.0
            elif esbt == "kw" && (esbv == "elif" || esbv == "else") && esb_d == 0.0
              esb_done = 1.0
            else
              cur = cur + 1.0
            end
          end
        end
      else
        cur = cur + 1.0  // elif without if frame - skip
      end
    else
      cur = cur + 1.0
    end

  // else (in interpreted program)
  elif tt == "kw" && tv == "else"
    cur = cur + 1.0  // skip "else"
    let else_cs_len = len(cstack_type)
    if else_cs_len > 0.0
      let else_top_idx = else_cs_len - 1.0
      let else_top = cstack_type[else_top_idx]
      if else_top == "if_exec"
        // already took a branch — skip else body to matching end
        let _el_pt = pop(cstack_type)
        let _el_pp = pop(cstack_pos)
        let mut else_sed = 1.0
        while cur < tok_count && else_sed > 0.0
          let eset = tok_types[cur]
          let esev = tok_values[cur]
          cur = cur + 1.0
          if eset == "kw" && (esev == "if" || esev == "while" || esev == "for")
            else_sed = else_sed + 1.0
          end
          if eset == "kw" && esev == "end"
            else_sed = else_sed - 1.0
          end
        end
      elif else_top == "if_skip"
        // no branch taken — execute else body
        let _els_pt = pop(cstack_type)
        let _els_pp = pop(cstack_pos)
        push(cstack_type, "if_exec")
        push(cstack_pos, 0.0)
      else
        cur = cur + 1.0
      end
    else
      cur = cur + 1.0
    end

  // while cond ... end
  elif tt == "kw" && tv == "while"
    let wpos = cur
    cur = cur + 1.0
    // LHS: simple ident/float  or  len(arr)
    let wt1 = tok_types[cur]
    let wv1 = tok_values[cur]
    cur = cur + 1.0
    let mut wlf = 0.0
    if wt1 == "ident" && wv1 == "len" && tok_values[cur] == "("
      cur = cur + 1.0  // skip (
      let wlen_arr1 = tok_values[cur]
      cur = cur + 1.0  // skip arr name
      cur = cur + 1.0  // skip )
      let wlen_k1 = "__len_" + wlen_arr1
      if map_has(env_num, wlen_k1)
        wlf = map_get(env_num, wlen_k1)
      elif map_has(env_s, wlen_arr1)
        wlf = len(map_get(env_s, wlen_arr1))
      end
    else
      if wt1 == "float"
        wlf = float(wv1)
      end
      if wt1 == "ident" && map_has(env_num, wv1)
        wlf = map_get(env_num, wv1)
      end
    end
    let wcop = tok_values[cur]
    cur = cur + 1.0
    // RHS: simple ident/float  or  len(arr)
    let wt2 = tok_types[cur]
    let wv2 = tok_values[cur]
    cur = cur + 1.0
    let mut wrf = 0.0
    if wt2 == "ident" && wv2 == "len" && tok_values[cur] == "("
      cur = cur + 1.0  // skip (
      let wlen_arr2 = tok_values[cur]
      cur = cur + 1.0  // skip arr name
      cur = cur + 1.0  // skip )
      let wlen_k2 = "__len_" + wlen_arr2
      if map_has(env_num, wlen_k2)
        wrf = map_get(env_num, wlen_k2)
      elif map_has(env_s, wlen_arr2)
        wrf = len(map_get(env_s, wlen_arr2))
      end
    else
      if wt2 == "float"
        wrf = float(wv2)
      end
      if wt2 == "ident" && map_has(env_num, wv2)
        wrf = map_get(env_num, wv2)
      end
    end
    let mut wcond = 0.0
    if wcop == ">"
      if wlf > wrf
        wcond = 1.0
      end
    end
    if wcop == "<"
      if wlf < wrf
        wcond = 1.0
      end
    end
    if wcop == ">="
      if wlf >= wrf
        wcond = 1.0
      end
    end
    if wcop == "<="
      if wlf <= wrf
        wcond = 1.0
      end
    end
    if wcop == "=="
      if wlf == wrf
        wcond = 1.0
      end
    end
    if wcop == "!="
      if wlf != wrf
        wcond = 1.0
      end
    end
    // compound && conditions (e.g. while pos < n && ord(char_at(src, pos)) != NL)
    while cur < tok_count && tok_values[cur] == "&&" && wcond == 1.0
      cur = cur + 1.0  // skip &&
      let wfn = tok_values[cur]
      cur = cur + 1.0  // skip fn name
      cur = cur + 1.0  // skip (
      if wfn == "ord"
        // ord(char_at(src_var, pos_var)) op CONST
        cur = cur + 1.0  // skip "char_at"
        cur = cur + 1.0  // skip (
        let wo_sv = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip ,
        let wo_pv = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip inner )
        cur = cur + 1.0  // skip outer )
        let wo_src = map_get(env_s, wo_sv)
        let wo_pos = map_get(env_num, wo_pv)
        let wo_c = char_at(wo_src, wo_pos)
        let wo_o = ord(wo_c)
        let wo_op = tok_values[cur]
        cur = cur + 1.0
        let wo_rhsv = tok_values[cur]
        cur = cur + 1.0
        let mut wo_rhs = 0.0
        if map_has(env_num, wo_rhsv)
          wo_rhs = map_get(env_num, wo_rhsv)
        else
          wo_rhs = float(wo_rhsv)
        end
        if wo_op == "!="
          if wo_o == wo_rhs
            wcond = 0.0
          end
        end
        if wo_op == "=="
          if wo_o != wo_rhs
            wcond = 0.0
          end
        end
        if wo_op == ">="
          if wo_o < wo_rhs
            wcond = 0.0
          end
        end
        if wo_op == "<="
          if wo_o > wo_rhs
            wcond = 0.0
          end
        end
        if wo_op == ">"
          if wo_o <= wo_rhs
            wcond = 0.0
          end
        end
        if wo_op == "<"
          if wo_o >= wo_rhs
            wcond = 0.0
          end
        end
      elif wfn == "contains"
        // contains(lit_or_ident, char_at(src_var, pos_var))
        let wc_a0t = tok_types[cur]
        let wc_a0v = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip ,
        cur = cur + 1.0  // skip char_at
        cur = cur + 1.0  // skip (
        let wc_sv = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip ,
        let wc_pv = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip inner )
        cur = cur + 1.0  // skip outer )
        let mut wc_hay = wc_a0v
        if wc_a0t == "ident" && map_has(env_s, wc_a0v)
          wc_hay = map_get(env_s, wc_a0v)
        end
        let wc_src = map_get(env_s, wc_sv)
        let wc_pos = map_get(env_num, wc_pv)
        let wc_char = char_at(wc_src, wc_pos)
        let wc_res = contains(wc_hay, wc_char)
        if wc_res == 0.0
          wcond = 0.0
        end
      elif wfn == "is_match"
        // is_match(char_at(src_var, pos_var), pattern)
        cur = cur + 1.0  // skip char_at
        cur = cur + 1.0  // skip (
        let wm_sv = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip ,
        let wm_pv = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip inner )
        cur = cur + 1.0  // skip ,
        let wm_patt = tok_values[cur]
        cur = cur + 1.0
        cur = cur + 1.0  // skip outer )
        let wm_src = map_get(env_s, wm_sv)
        let wm_pos = map_get(env_num, wm_pv)
        let wm_char = char_at(wm_src, wm_pos)
        let wm_res = is_match(wm_char, wm_patt)
        if wm_res == 0.0
          wcond = 0.0
        end
      elif map_has(env_s, "__arr_" + wfn)
        // arr[idx] op str — e.g. && tok_values[cur] != ")"
        // wfn = array name; "[" already consumed as "(" by outer handler
        let wa_idxv = tok_values[cur]
        cur = cur + 1.0  // skip idx
        cur = cur + 1.0  // skip ]
        let mut wa_idx = 0.0
        if map_has(env_num, wa_idxv)
          wa_idx = map_get(env_num, wa_idxv)
        elif is_match(wa_idxv, "^[0-9]")
          wa_idx = float(wa_idxv)
        end
        let wa_key = "__arr_" + wfn
        let wa_enc = map_get(env_s, wa_key)
        let mut wa_elem = ""
        if len(wa_enc) > 0.0
          let wa_parts = split(wa_enc, SEP)
          let wa_n = len(wa_parts)
          if wa_idx < wa_n
            wa_elem = wa_parts[wa_idx]
          end
        end
        let wa_op = tok_values[cur]
        cur = cur + 1.0
        let wa_rhst = tok_types[cur]
        let wa_rhsv = tok_values[cur]
        cur = cur + 1.0
        let mut wa_rhs = wa_rhsv
        if wa_rhst == "ident" && map_has(env_s, wa_rhsv)
          wa_rhs = map_get(env_s, wa_rhsv)
        end
        if wa_op == "!="
          if wa_elem == wa_rhs
            wcond = 0.0
          end
        end
        if wa_op == "=="
          if wa_elem != wa_rhs
            wcond = 0.0
          end
        end
      elif wfn == "char_at"
        // && char_at(str_var, idx) == / != "char"
        // cur is at str_var (fn name and "(" already skipped)
        let wca_sv = tok_values[cur]
        cur = cur + 1.0  // skip str var
        cur = cur + 1.0  // skip ,
        let wca_it = tok_types[cur]
        let wca_iv = tok_values[cur]
        cur = cur + 1.0  // skip idx
        cur = cur + 1.0  // skip )
        let wca_op = tok_values[cur]
        cur = cur + 1.0  // skip op
        let wca_rt = tok_types[cur]
        let wca_rv = tok_values[cur]
        cur = cur + 1.0  // skip rhs
        let mut wca_src = ""
        if map_has(env_s, wca_sv)
          wca_src = map_get(env_s, wca_sv)
        end
        let mut wca_idx = 0.0
        if wca_it == "float"
          wca_idx = float(wca_iv)
        end
        if wca_it == "ident" && map_has(env_num, wca_iv)
          wca_idx = map_get(env_num, wca_iv)
        end
        let wca_c = char_at(wca_src, wca_idx)
        let mut wca_rhs = wca_rv
        if wca_rt == "ident" && map_has(env_s, wca_rv)
          wca_rhs = map_get(env_s, wca_rv)
        end
        if wca_op == "!="
          if wca_c == wca_rhs
            wcond = 0.0
          end
        end
        if wca_op == "=="
          if wca_c != wca_rhs
            wcond = 0.0
          end
        end
      else
        // simple scalar comparison: ident op rhs (e.g. parse_done == 0.0)
        // wfn = ident; cur-1 = operator (consumed as "skip ("); cur = rhs
        if map_has(env_num, wfn) || map_has(env_s, wfn)
          let ws_op = tok_values[cur - 1.0]
          let mut ws_rhst = tok_types[cur]
          let mut ws_rhsv = tok_values[cur]
          cur = cur + 1.0
          let mut ws_neg = 0.0
          if ws_rhst == "op" && ws_rhsv == "-"
            ws_neg = 1.0
            ws_rhst = tok_types[cur]
            ws_rhsv = tok_values[cur]
            cur = cur + 1.0
          end
          if map_has(env_num, wfn)
            let ws_lhf = map_get(env_num, wfn)
            let mut ws_rhf = 0.0
            if map_has(env_num, ws_rhsv)
              ws_rhf = map_get(env_num, ws_rhsv)
            else
              ws_rhf = float(ws_rhsv)
            end
            if ws_neg == 1.0
              ws_rhf = 0.0 - ws_rhf
            end
            if ws_op == "!="
              if ws_lhf == ws_rhf
                wcond = 0.0
              end
            end
            if ws_op == "=="
              if ws_lhf != ws_rhf
                wcond = 0.0
              end
            end
            if ws_op == "<"
              if ws_lhf >= ws_rhf
                wcond = 0.0
              end
            end
            if ws_op == ">"
              if ws_lhf <= ws_rhf
                wcond = 0.0
              end
            end
            if ws_op == "<="
              if ws_lhf > ws_rhf
                wcond = 0.0
              end
            end
            if ws_op == ">="
              if ws_lhf < ws_rhf
                wcond = 0.0
              end
            end
          else
            let ws_lhs = map_get(env_s, wfn)
            let mut ws_rhs = ws_rhsv
            if ws_rhst == "ident" && map_has(env_s, ws_rhsv)
              ws_rhs = map_get(env_s, ws_rhsv)
            end
            if ws_op == "!="
              if ws_lhs == ws_rhs
                wcond = 0.0
              end
            end
            if ws_op == "=="
              if ws_lhs != ws_rhs
                wcond = 0.0
              end
            end
          end
        else
          // truly unknown: skip to newline
          while cur < tok_count && tok_types[cur] != "nl"
            cur = cur + 1.0
          end
        end
      end
    end
    if wcond == 1.0
      push(cstack_type, "while")
      push(cstack_pos, wpos)
    else
      let mut wdepth = 1.0
      while cur < tok_count && wdepth > 0.0
        let wskt = tok_types[cur]
        let wskv = tok_values[cur]
        cur = cur + 1.0
        if wskt == "kw" && (wskv == "if" || wskv == "while" || wskv == "for")
          wdepth = wdepth + 1.0
        end
        if wskt == "kw" && wskv == "end"
          wdepth = wdepth - 1.0
        end
      end
    end

  // for item in array — for-each loop
  elif tt == "kw" && tv == "for"
    cur = cur + 1.0  // past "for"
    let fi_item = tok_values[cur]
    cur = cur + 1.0  // past item name
    cur = cur + 1.0  // past "in"
    let fi_arr_name = tok_values[cur]
    cur = cur + 1.0  // past arr name
    while cur < tok_count && tok_types[cur] == "nl"
      cur = cur + 1.0
    end
    let fi_body = cur
    let fi_enc_key = "__arr_" + fi_arr_name
    let mut fi_enc = ""
    if map_has(env_s, fi_enc_key)
      fi_enc = map_get(env_s, fi_enc_key)
    end
    let mut fi_cnt = 0.0
    if len(fi_enc) > 0.0
      let fi_elems0 = split(fi_enc, SEP)
      fi_cnt = len(fi_elems0)
    end
    if fi_cnt > 0.0
      let fi_elems1 = split(fi_enc, SEP)
      let fi_first = fi_elems1[0.0]
      map_set(env_s, fi_item, fi_first)
      if is_match(fi_first, "^[0-9]")
        let fi_ff = float(fi_first)
        map_set(env_num, fi_item, fi_ff)
      end
      let fi_k = str(fi_body)
      map_set(env_s, "__fe_item_" + fi_k, fi_item)
      map_set(env_s, "__fe_arr_" + fi_k, fi_enc)
      map_set(env_num, "__fe_idx_" + fi_k, 0.0)
      map_set(env_num, "__fe_cnt_" + fi_k, fi_cnt)
      push(cstack_type, "for_each")
      push(cstack_pos, fi_body)
    else
      let mut fi_depth = 1.0
      while cur < tok_count && fi_depth > 0.0
        let fit = tok_types[cur]
        let fiv = tok_values[cur]
        cur = cur + 1.0
        if fit == "kw" && (fiv == "if" || fiv == "while" || fiv == "for" || fiv == "fn")
          fi_depth = fi_depth + 1.0
        end
        if fit == "kw" && fiv == "end"
          fi_depth = fi_depth - 1.0
        end
      end
    end

  // break — exit innermost while/for-each loop
  elif tt == "kw" && tv == "break"
    cur = cur + 1.0
    let mut brk_depth = 1.0
    while len(cstack_type) > 0.0
      let brk_ft = pop(cstack_type)
      let _fx_pp = pop(cstack_pos)
      if brk_ft == "while" || brk_ft == "for_each"
        break
      else
        brk_depth = brk_depth + 1.0
      end
    end
    let mut brk_scan = brk_depth
    while cur < tok_count && brk_scan > 0.0
      let brk_t = tok_types[cur]
      let brk_v = tok_values[cur]
      cur = cur + 1.0
      if brk_t == "kw" && (brk_v == "if" || brk_v == "while" || brk_v == "for" || brk_v == "fn")
        brk_scan = brk_scan + 1.0
      end
      if brk_t == "kw" && brk_v == "end"
        brk_scan = brk_scan - 1.0
      end
    end

  // continue — skip to end of current loop body, let end-handler re-evaluate
  elif tt == "kw" && tv == "continue"
    cur = cur + 1.0
    let mut cont_depth = 1.0
    let mut cont_done = 0.0
    while len(cstack_type) > 0.0 && cont_done == 0.0
      let cont_ti = len(cstack_type) - 1.0
      let cont_ft = cstack_type[cont_ti]
      if cont_ft == "while" || cont_ft == "for_each"
        cont_done = 1.0
      else
        let _fx_pt = pop(cstack_type)
        let _fx_pp = pop(cstack_pos)
        cont_depth = cont_depth + 1.0
      end
    end
    let mut cont_at_end = 0.0
    while cur < tok_count && cont_at_end == 0.0
      let cont_t = tok_types[cur]
      let cont_v = tok_values[cur]
      if cont_t == "kw" && (cont_v == "if" || cont_v == "while" || cont_v == "for" || cont_v == "fn")
        cont_depth = cont_depth + 1.0
        cur = cur + 1.0
      elif cont_t == "kw" && cont_v == "end"
        cont_depth = cont_depth - 1.0
        if cont_depth == 0.0
          cont_at_end = 1.0
        else
          cur = cur + 1.0
        end
      else
        cur = cur + 1.0
      end
    end

  // use — skip module import line (not yet supported in meta-interpreter)
  elif tt == "kw" && tv == "use"
    cur = cur + 1.0
    while cur < tok_count && tok_types[cur] != "nl"
      cur = cur + 1.0
    end

  // extern "lib" { ... } — skip extern block (eval.flow handles FFI dispatch directly)
  elif tt == "kw" && tv == "extern"
    while cur < tok_count && tok_values[cur] != "}"
      cur = cur + 1.0
    end
    if cur < tok_count
      cur = cur + 1.0  // skip }
    end

  // ── stream NAME = source |> stage |> stage ... ──────────────────────
  // Streams are float arrays stored using the same __arr_/__len_ convention.
  // Source: tap("path"), random_stream(N), random_stream(N,lo,hi), or stream ref.
  // Pipe stages: map ops applied element-wise.
  elif tt == "kw" && tv == "stream"
    cur = cur + 1.0
    let st_name = tok_values[cur]
    cur = cur + 1.0  // skip name
    // expect "="
    if cur < tok_count && tok_values[cur] == "="
      cur = cur + 1.0
    end
    // ── parse source expression ──
    let st_src = tok_values[cur]
    let st_src_t = tok_types[cur]
    let mut st_arr_key = ""
    let mut st_arr_enc = ""
    let mut st_count = 0.0
    if st_src == "tap"
      // tap("path") — read CSV into float array
      cur = cur + 1.0  // skip tap
      if cur < tok_count && tok_values[cur] == "("
        cur = cur + 1.0  // skip (
      end
      let st_path = tok_values[cur]
      cur = cur + 1.0  // skip path string
      if cur < tok_count && tok_values[cur] == ")"
        cur = cur + 1.0  // skip )
      end
      let st_lines = read_lines(st_path)
      let mut st_vals = []
      let mut st_li = 0.0
      while st_li < len(st_lines)
        let st_ln = trim(st_lines[st_li])
        if len(st_ln) > 0.0
          // try to parse as float
          let st_fv = float(st_ln)
          push(st_vals, str(st_fv))
        end
        st_li = st_li + 1.0
      end
      st_count = len(st_vals)
      if st_count > 0.0
        st_arr_enc = join(st_vals, SEP)
      end
    elif st_src == "random_stream"
      // random_stream(N) or random_stream(N, lo, hi)
      cur = cur + 1.0  // skip random_stream
      if cur < tok_count && tok_values[cur] == "("
        cur = cur + 1.0  // skip (
      end
      // parse N
      let mut rs_n = 0.0
      let rs_nt = tok_types[cur]
      let rs_nv = tok_values[cur]
      if rs_nt == "float"
        rs_n = float(rs_nv)
      elif rs_nt == "ident" && map_has(env_num, rs_nv)
        rs_n = map_get(env_num, rs_nv)
      end
      cur = cur + 1.0
      let mut rs_lo = 0.0 - 1.0
      let mut rs_hi = 1.0
      if cur < tok_count && tok_values[cur] == ","
        cur = cur + 1.0  // skip ,
        let rs_lot = tok_types[cur]
        let rs_lov = tok_values[cur]
        if rs_lot == "float"
          rs_lo = float(rs_lov)
        elif rs_lot == "ident" && map_has(env_num, rs_lov)
          rs_lo = map_get(env_num, rs_lov)
        end
        cur = cur + 1.0
        if cur < tok_count && tok_values[cur] == ","
          cur = cur + 1.0
          let rs_hit = tok_types[cur]
          let rs_hiv = tok_values[cur]
          if rs_hit == "float"
            rs_hi = float(rs_hiv)
          elif rs_hit == "ident" && map_has(env_num, rs_hiv)
            rs_hi = map_get(env_num, rs_hiv)
          end
          cur = cur + 1.0
        end
      end
      if cur < tok_count && tok_values[cur] == ")"
        cur = cur + 1.0
      end
      // generate random values using simple xorshift
      let mut rs_vals = []
      let mut rs_seed = now_ms() * 1000.0 + 12345.0
      let rs_range = rs_hi - rs_lo
      let mut rs_i = 0.0
      while rs_i < rs_n
        // simple hash-based pseudo-random
        rs_seed = rs_seed * 6364136223846793005.0 + 1442695040888963407.0
        let rs_frac = abs(rs_seed) / 9223372036854775807.0
        let rs_v = rs_lo + rs_frac * rs_range
        push(rs_vals, str(rs_v))
        rs_i = rs_i + 1.0
      end
      st_count = len(rs_vals)
      if st_count > 0.0
        st_arr_enc = join(rs_vals, SEP)
      end
    elif st_src_t == "ident"
      // stream reference — copy existing stream/array
      let mut st_ref_k = "__arr_" + st_src
      // resolve alias
      let st_ref_aa = "__arr_alias_" + st_src
      let mut st_ref_real = st_src
      if map_has(env_s, st_ref_aa)
        st_ref_real = map_get(env_s, st_ref_aa)
        st_ref_k = "__arr_" + st_ref_real
      end
      if map_has(env_s, st_ref_k)
        st_arr_enc = map_get(env_s, st_ref_k)
        let st_ref_lk = "__len_" + st_ref_real
        if map_has(env_num, st_ref_lk)
          st_count = map_get(env_num, st_ref_lk)
        end
      end
      cur = cur + 1.0
    else
      cur = cur + 1.0
    end
    // ── apply pipe stages: |> operation(args) ──
    while cur < tok_count && tok_values[cur] == "|>"
      cur = cur + 1.0  // skip |>
      let ps_op = tok_values[cur]
      cur = cur + 1.0  // skip operation name
      // collect arguments
      let mut ps_args = []
      if cur < tok_count && tok_values[cur] == "("
        cur = cur + 1.0  // skip (
        while cur < tok_count && tok_values[cur] != ")"
          let ps_at = tok_types[cur]
          let ps_av = tok_values[cur]
          if ps_at == "float"
            push(ps_args, ps_av)
          elif ps_at == "ident" && map_has(env_num, ps_av)
            push(ps_args, str(map_get(env_num, ps_av)))
          elif ps_at == "ident" && map_has(env_s, ps_av)
            push(ps_args, map_get(env_s, ps_av))
          elif ps_av != ","
            push(ps_args, ps_av)
          end
          cur = cur + 1.0
        end
        if cur < tok_count && tok_values[cur] == ")"
          cur = cur + 1.0
        end
      end
      // apply the operation element-wise to the stream array
      if st_count > 0.0
        let ps_elems = split(st_arr_enc, SEP)
        let mut ps_out = []
        let ps_nargs = len(ps_args)
        let mut ps_a0 = 0.0
        let mut ps_a1 = 0.0
        if ps_nargs > 0.0
          ps_a0 = float(ps_args[0])
        end
        if ps_nargs > 1.0
          ps_a1 = float(ps_args[1])
        end
        let mut ps_i = 0.0
        while ps_i < st_count
          let ps_x = float(ps_elems[ps_i])
          let mut ps_r = ps_x
          // ── unary map ops ──
          if ps_op == "abs"
            if ps_x < 0.0
              ps_r = 0.0 - ps_x
            end
          elif ps_op == "negate"
            ps_r = 0.0 - ps_x
          elif ps_op == "sqrt"
            ps_r = sqrt(ps_x)
          elif ps_op == "exp"
            ps_r = exp(ps_x)
          elif ps_op == "log"
            ps_r = log(ps_x)
          elif ps_op == "floor"
            ps_r = floor(ps_x)
          elif ps_op == "ceil"
            ps_r = ceil(ps_x)
          elif ps_op == "round"
            ps_r = round(ps_x)
          elif ps_op == "sin"
            ps_r = sin(ps_x)
          elif ps_op == "cos"
            ps_r = cos(ps_x)
          // ── parametric map ops ──
          elif ps_op == "add"
            ps_r = ps_x + ps_a0
          elif ps_op == "subtract"
            ps_r = ps_x - ps_a0
          elif ps_op == "multiply" || ps_op == "scale"
            ps_r = ps_x * ps_a0
          elif ps_op == "divide"
            if ps_a0 != 0.0
              ps_r = ps_x / ps_a0
            end
          elif ps_op == "pow"
            ps_r = pow(ps_x, ps_a0)
          elif ps_op == "mod"
            ps_r = ps_x - floor(ps_x / ps_a0) * ps_a0
          elif ps_op == "min"
            if ps_a0 < ps_x
              ps_r = ps_a0
            end
          elif ps_op == "max"
            if ps_a0 > ps_x
              ps_r = ps_a0
            end
          elif ps_op == "clamp"
            if ps_x < ps_a0
              ps_r = ps_a0
            elif ps_x > ps_a1
              ps_r = ps_a1
            end
          end
          push(ps_out, str(ps_r))
          ps_i = ps_i + 1.0
        end
        st_arr_enc = join(ps_out, SEP)
        st_count = len(ps_out)
      end
      // ── temporal/sequential pipe ops ──
      if ps_op == "ema" || ps_op == "decay" || ps_op == "scan"
        let tp_elems = split(st_arr_enc, SEP)
        let mut tp_out = []
        let mut tp_prev = 0.0
        if st_count > 0.0
          tp_prev = float(tp_elems[0])
        end
        let mut tp_i = 0.0
        while tp_i < st_count
          let tp_x = float(tp_elems[tp_i])
          let mut tp_r = tp_x
          if ps_op == "ema"
            // EMA: out[t] = alpha * x[t] + (1-alpha) * out[t-1]
            if tp_i == 0.0
              tp_r = tp_x
            else
              tp_r = ps_a0 * tp_x + (1.0 - ps_a0) * tp_prev
            end
          elif ps_op == "decay"
            // Decay: out[t] = x[t] + factor * out[t-1]
            if tp_i == 0.0
              tp_r = tp_x
            else
              tp_r = tp_x + ps_a0 * tp_prev
            end
          elif ps_op == "scan"
            // Prefix sum: out[t] = out[t-1] + x[t]
            if tp_i == 0.0
              tp_r = tp_x
            else
              tp_r = tp_prev + tp_x
            end
          end
          tp_prev = tp_r
          push(tp_out, str(tp_r))
          tp_i = tp_i + 1.0
        end
        st_arr_enc = join(tp_out, SEP)
        st_count = len(tp_out)
      end
    end
    // ── store the stream as an array ──
    let st_ak = "__arr_" + st_name
    let st_lk = "__len_" + st_name
    map_set(env_s, st_ak, st_arr_enc)
    map_set(env_num, st_lk, st_count)

  // ── emit(stream, "path") — write stream to CSV ─────────────────────
  elif tt == "kw" && tv == "emit"
    cur = cur + 1.0  // skip emit
    if cur < tok_count && tok_values[cur] == "("
      cur = cur + 1.0  // skip (
    end
    let em_name = tok_values[cur]
    cur = cur + 1.0  // skip stream name
    if cur < tok_count && tok_values[cur] == ","
      cur = cur + 1.0  // skip ,
    end
    let em_path = tok_values[cur]
    cur = cur + 1.0  // skip path
    if cur < tok_count && tok_values[cur] == ")"
      cur = cur + 1.0  // skip )
    end
    // resolve stream/array
    let mut em_real = em_name
    let em_aa = "__arr_alias_" + em_name
    if map_has(env_s, em_aa)
      em_real = map_get(env_s, em_aa)
    end
    let em_ak = "__arr_" + em_real
    if map_has(env_s, em_ak)
      let em_enc = map_get(env_s, em_ak)
      let em_elems = split(em_enc, SEP)
      let mut em_out = ""
      let mut em_i = 0.0
      while em_i < len(em_elems)
        if em_i > 0.0
          em_out = em_out + chr(10)
        end
        em_out = em_out + em_elems[em_i]
        em_i = em_i + 1.0
      end
      write_file(em_path, em_out)
    end

  // end — pop control stack; for_each → next element, while → jump back, fn → return
  elif tt == "kw" && tv == "end"
    if len(cstack_type) > 0.0
      let end_cs = len(cstack_type)
      let end_ti = end_cs - 1.0
      let end_t = cstack_type[end_ti]
      if end_t == "for_each"
        let end_p = cstack_pos[end_ti]
        let fe_k = str(end_p)
        let fe_idx = map_get(env_num, "__fe_idx_" + fe_k) + 1.0
        let fe_cnt = map_get(env_num, "__fe_cnt_" + fe_k)
        if fe_idx < fe_cnt
          let fe_arr = map_get(env_s, "__fe_arr_" + fe_k)
          let fe_elems = split(fe_arr, SEP)
          let fe_elem = fe_elems[fe_idx]
          let fe_item = map_get(env_s, "__fe_item_" + fe_k)
          map_set(env_s, fe_item, fe_elem)
          if is_match(fe_elem, "^[0-9]")
            let fe_f = float(fe_elem)
            map_set(env_num, fe_item, fe_f)
          end
          map_set(env_num, "__fe_idx_" + fe_k, fe_idx)
          cur = end_p
        else
          let _fx_pt = pop(cstack_type)
          let _fx_pp = pop(cstack_pos)
          cur = cur + 1.0
        end
      else
        let end_p = pop(cstack_pos)
        let _fx_pt = pop(cstack_type)
        if end_t == "while"
          cur = end_p
        elif end_t == "fn"
          // function body ended without explicit return: store __ret (if any) to dest
          if len(call_dest) > 0.0
            let fn_vname = pop(call_dest)
            if map_has(env_num, "__ret")
              map_set(env_num, fn_vname, map_get(env_num, "__ret"))
            end
            if map_has(env_s, "__ret")
              map_set(env_s, fn_vname, map_get(env_s, "__ret"))
            end
          end
          cur = end_p
        else
          cur = cur + 1.0
        end
      end
    else
      cur = cur + 1.0
    end

  // assignment: ident = expr or arr[idx] = val
  elif tt == "ident"
    let an1 = cur + 1.0
    // check for arr[idx] = val pattern first
    if an1 < tok_count && tok_values[an1] == "["
      let ai_arr = tv
      cur = cur + 2.0  // past arr and [
      let ai_idx_t = tok_types[cur]
      let ai_idx_v = tok_values[cur]
      cur = cur + 1.0  // past idx
      cur = cur + 1.0  // past ]
      cur = cur + 1.0  // past =
      let mut ai_idx_f = 0.0
      if ai_idx_t == "float"
        ai_idx_f = float(ai_idx_v)
      end
      if ai_idx_t == "ident" && map_has(env_num, ai_idx_v)
        ai_idx_f = map_get(env_num, ai_idx_v)
      end
      // resolve rhs: str(scalar), str(arr[idx]), or simple ident/literal
      let mut ai_val_s = ""
      let ai_rhs_t = tok_types[cur]
      let ai_rhs_v = tok_values[cur]
      let ai_nxt = cur + 1.0
      if ai_rhs_t == "ident" && ai_rhs_v == "str" && ai_nxt < tok_count && tok_values[ai_nxt] == "("
        // str(scalar) or str(arr[idx])
        cur = cur + 2.0  // skip str and (
        let ai_sc_t = tok_types[cur]
        let ai_sc_v = tok_values[cur]
        cur = cur + 1.0
        if cur < tok_count && tok_values[cur] == "["
          // str(arr[idx])
          cur = cur + 1.0  // skip [
          let ai_si_t = tok_types[cur]
          let ai_si_v = tok_values[cur]
          cur = cur + 1.0
          if cur < tok_count && tok_values[cur] == "]"
            cur = cur + 1.0
          end
          let mut ai_si_f = 0.0
          if ai_si_t == "float"
            ai_si_f = float(ai_si_v)
          end
          if ai_si_t == "ident" && map_has(env_num, ai_si_v)
            ai_si_f = map_get(env_num, ai_si_v)
          end
          let ai_sakey = "__arr_" + ai_sc_v
          let mut ai_sf = 0.0
          let mut ai_se = "-1"
          if map_has(env_s, ai_sakey)
            let ai_selems = split(map_get(env_s, ai_sakey), SEP)
            let ai_sei = ai_si_f
            if ai_sei < len(ai_selems)
              ai_se = ai_selems[ai_sei]
              if is_match(ai_se, "^[0-9]")
                ai_sf = float(ai_se)
              end
              if is_match(ai_se, "^-[0-9]")
                ai_sf = float(ai_se)
              end
            end
          end
          ai_val_s = str(ai_sf)
          if ai_se == "-1"
            ai_val_s = "-1"
          end
        else
          // str(scalar_var)
          let mut ai_sf2 = 0.0
          if ai_sc_t == "float"
            ai_sf2 = float(ai_sc_v)
          end
          if ai_sc_t == "ident" && map_has(env_num, ai_sc_v)
            ai_sf2 = map_get(env_num, ai_sc_v)
          end
          ai_val_s = str(ai_sf2)
        end
        if cur < tok_count && tok_values[cur] == ")"
          cur = cur + 1.0  // skip inner )
        end
      else
        cur = cur + 1.0  // skip simple value token
        ai_val_s = ai_rhs_v
        if ai_rhs_t == "ident" && map_has(env_s, ai_rhs_v)
          ai_val_s = map_get(env_s, ai_rhs_v)
        end
      end
      let ai_key = "__arr_" + ai_arr
      if map_has(env_s, ai_key)
        let ai_enc = map_get(env_s, ai_key)
        let ai_parts = split(ai_enc, SEP)
        let mut ai_new_enc = ""
        let mut ai_p = 0.0
        let ai_plen = len(ai_parts)
        while ai_p < ai_plen
          if ai_p > 0.0
            ai_new_enc = ai_new_enc + SEP
          end
          if ai_p == ai_idx_f
            ai_new_enc = ai_new_enc + ai_val_s
          else
            ai_new_enc = ai_new_enc + ai_parts[ai_p]
          end
          ai_p = ai_p + 1.0
        end
        map_set(env_s, ai_key, ai_new_enc)
      end
    elif an1 < tok_count && tok_types[an1] == "op" && tok_values[an1] == "="
      let aname = tv
      cur = cur + 2.0
      let artt = tok_types[cur]
      let artv = tok_values[cur]
      cur = cur + 1.0
      // assignment with function call RHS: x = fn(args) [OP val]
      if artt == "ident" && cur < tok_count && tok_values[cur] == "(" && map_has(fn_start, artv) == 0.0
        // builtin fn call as RHS
        let afn = artv
        cur = cur + 1.0  // skip (
        // collect up to 3 args
        let mut afa0 = ""
        let mut afa0f = 0.0
        let mut afa1 = ""
        let mut afa1f = 0.0
        let mut afa2 = ""
        let mut afa2f = 0.0
        let mut afn_ac = 0.0
        while cur < tok_count && tok_values[cur] != ")"
          let afat = tok_types[cur]
          let afav = tok_values[cur]
          if afat == "ident" || afat == "float" || afat == "str"
            let mut af_val_s = afav
            let mut af_val_f = 0.0
            if afat == "float"
              af_val_f = float(afav)
              af_val_s = afav
            elif afat == "str"
              af_val_s = afav
            else
              if map_has(env_s, afav)
                af_val_s = map_get(env_s, afav)
              end
              if map_has(env_num, afav)
                af_val_f = map_get(env_num, afav)
              end
            end
            if afn_ac == 0.0
              afa0 = af_val_s
              afa0f = af_val_f
            elif afn_ac == 1.0
              afa1 = af_val_s
              afa1f = af_val_f
            elif afn_ac == 2.0
              afa2 = af_val_s
              afa2f = af_val_f
            end
            afn_ac = afn_ac + 1.0
          end
          cur = cur + 1.0
        end
        if cur < tok_count
          cur = cur + 1.0  // skip )
        end
        // dispatch builtins
        let mut afr = 0.0
        let mut afs = ""
        let mut af_is_str = 0.0
        if afn == "floor"
          afr = floor(afa0f)
        elif afn == "ceil"
          afr = ceil(afa0f)
        elif afn == "sqrt"
          afr = sqrt(afa0f)
        elif afn == "abs"
          afr = afa0f
          if afr < 0.0
            afr = afr - afr - afr
          end
        elif afn == "round"
          afr = round(afa0f)
        elif afn == "min"
          afr = afa0f
          if afa1f < afr
            afr = afa1f
          end
        elif afn == "max"
          afr = afa0f
          if afa1f > afr
            afr = afa1f
          end
        elif afn == "pow"
          afr = pow(afa0f, afa1f)
        elif afn == "len"
          let af_lk = "__len_" + afa0
          if map_has(env_num, af_lk)
            afr = map_get(env_num, af_lk)
          else
            afr = len(afa0)
          end
        elif afn == "ord"
          afr = ord(afa0)
        elif afn == "chr"
          afs = chr(afa0f)
          af_is_str = 1.0
        elif afn == "char_at"
          afs = char_at(afa0, afa1f)
          af_is_str = 1.0
        elif afn == "str"
          afs = str(afa0f)
          af_is_str = 1.0
        elif afn == "float"
          afr = float(afa0)
        elif afn == "trim"
          afs = trim(afa0)
          af_is_str = 1.0
        elif afn == "replace"
          afs = replace(afa0, afa1, afa2)
          af_is_str = 1.0
        elif afn == "contains"
          afr = contains(afa0, afa1)
        elif afn == "starts_with"
          afr = starts_with(afa0, afa1)
        elif afn == "ends_with"
          afr = ends_with(afa0, afa1)
        elif afn == "is_match"
          afr = is_match(afa0, afa1)
        elif afn == "regex_match"
          afr = is_match(afa0, afa1)
        elif afn == "index_of"
          afr = index_of(afa0, afa1)
        elif afn == "substr"
          afs = substr(afa0, afa1f, afa2f)
          af_is_str = 1.0
        elif afn == "repeat"
          afs = repeat(afa0, afa1f)
          af_is_str = 1.0
        elif afn == "int"
          afr = floor(float(afa0))
        elif afn == "type_of"
          // type_of in eval.flow context — check env for type info
          if map_has(env_s, "__arr_" + afa0)
            afs = "array"
          elif map_has(env_s, "__map_keys_" + afa0)
            afs = "map"
          elif map_has(env_num, afa0)
            afs = "float"
          elif map_has(env_s, afa0)
            afs = "string"
          else
            afs = "nil"
          end
          af_is_str = 1.0
        elif afn == "map_get"
          // map_get(m, key) — resolve from compound key storage
          let afmg_key = afa1
          let afmg_ck = "__map_" + afa0 + "." + afmg_key
          let mut afmg_has_num = 0.0
          if map_has(env_num, afmg_ck)
            afr = map_get(env_num, afmg_ck)
            afmg_has_num = 1.0
          end
          if map_has(env_s, afmg_ck)
            afs = map_get(env_s, afmg_ck)
            if afmg_has_num == 0.0
              af_is_str = 1.0
            end
          end
        elif afn == "map_has"
          let afmh_key = afa1
          let afmh_ck = "__map_" + afa0 + "." + afmh_key
          if map_has(env_num, afmh_ck) || map_has(env_s, afmh_ck)
            afr = 1.0
          else
            afr = 0.0
          end
        elif afn == "env"
          afs = env(afa0)
          af_is_str = 1.0
        elif afn == "read_file"
          afs = read_file(afa0)
          af_is_str = 1.0
        elif afn == "join"
          // join(arr, sep) — resolve array
          let afj_akey = "__arr_" + afa0
          if map_has(env_s, afj_akey)
            let afj_enc = map_get(env_s, afj_akey)
            let afj_parts = split(afj_enc, SEP)
            afs = join(afj_parts, afa1)
          else
            afs = afa0
          end
          af_is_str = 1.0
        elif afn == "split"
          // split returns array — but in assignment context, just store as string
          afs = afa0
          af_is_str = 1.0
        elif afn == "time"
          afr = time()
        elif afn == "random"
          afr = random()
        elif afn == "os_name"
          afs = os_name()
          af_is_str = 1.0
        elif afn == "now"
          afr = now()
        elif afn == "now_ms"
          afr = now_ms()
        elif afn == "read_line"
          afs = read_line()
          af_is_str = 1.0
        elif afn == "write_file"
          write_file(afa0, afa1)
          afr = 1.0
        elif afn == "float_to_bits"
          afr = float_to_bits(afa0f)
        elif afn == "bits_to_float"
          afr = bits_to_float(afa0f)
        elif afn == "float_byte"
          afr = float_byte(afa0f, afa1f)
        elif afn == "file_ext"
          let af_fe_dot = index_of(afa0, ".")
          if af_fe_dot >= 0.0
            afs = substr(afa0, af_fe_dot + 1.0, len(afa0))
          end
          af_is_str = 1.0
        elif afn == "file_name"
          let af_fn_n = len(afa0)
          let mut af_fn_last = -1.0
          let mut af_fn_i = 0.0
          while af_fn_i < af_fn_n
            let af_fn_c = char_at(afa0, af_fn_i)
            if af_fn_c == "/" || af_fn_c == chr(92.0)
              af_fn_last = af_fn_i
            end
            af_fn_i = af_fn_i + 1.0
          end
          if af_fn_last >= 0.0
            afs = substr(afa0, af_fn_last + 1.0, af_fn_n)
          else
            afs = afa0
          end
          af_is_str = 1.0
        elif afn == "dirname"
          let af_dn_n = len(afa0)
          let mut af_dn_last = -1.0
          let mut af_dn_i = 0.0
          while af_dn_i < af_dn_n
            let af_dn_c = char_at(afa0, af_dn_i)
            if af_dn_c == "/" || af_dn_c == chr(92.0)
              af_dn_last = af_dn_i
            end
            af_dn_i = af_dn_i + 1.0
          end
          if af_dn_last >= 0.0
            afs = substr(afa0, 0.0, af_dn_last)
          else
            afs = "."
          end
          af_is_str = 1.0
        elif afn == "basename"
          let af_bn_n = len(afa0)
          let mut af_bn_last = -1.0
          let mut af_bn_i = 0.0
          while af_bn_i < af_bn_n
            let af_bn_c = char_at(afa0, af_bn_i)
            if af_bn_c == "/" || af_bn_c == chr(92.0)
              af_bn_last = af_bn_i
            end
            af_bn_i = af_bn_i + 1.0
          end
          if af_bn_last >= 0.0
            afs = substr(afa0, af_bn_last + 1.0, af_bn_n)
          else
            afs = afa0
          end
          let af_bn_dot = index_of(afs, ".")
          if af_bn_dot >= 0.0
            afs = substr(afs, 0.0, af_bn_dot)
          end
          af_is_str = 1.0
        elif afn == "path_join"
          let mut af_pj_r = afa0
          if len(af_pj_r) > 0.0
            let af_pj_last = char_at(af_pj_r, len(af_pj_r) - 1.0)
            if af_pj_last != "/" && af_pj_last != chr(92.0)
              af_pj_r = af_pj_r + "/"
            end
          end
          afs = af_pj_r + afa1
          af_is_str = 1.0
        elif afn == "hex_encode"
          let af_he_n = len(afa0)
          let af_he_hex = "0123456789abcdef"
          let mut af_he_r = ""
          let mut af_he_i = 0.0
          while af_he_i < af_he_n
            let af_he_o = ord(char_at(afa0, af_he_i))
            let af_he_hi = floor(af_he_o / 16.0)
            let af_he_lo = af_he_o - af_he_hi * 16.0
            af_he_r = af_he_r + char_at(af_he_hex, af_he_hi) + char_at(af_he_hex, af_he_lo)
            af_he_i = af_he_i + 1.0
          end
          afs = af_he_r
          af_is_str = 1.0
        elif afn == "hex_decode"
          let af_hd_n = len(afa0)
          let af_hd_hex = "0123456789abcdef"
          let mut af_hd_r = ""
          let mut af_hd_i = 0.0
          while af_hd_i < af_hd_n - 1.0
            let af_hd_hi = index_of(af_hd_hex, to_lower(char_at(afa0, af_hd_i)))
            let af_hd_lo = index_of(af_hd_hex, to_lower(char_at(afa0, af_hd_i + 1.0)))
            if af_hd_hi >= 0.0 && af_hd_lo >= 0.0
              af_hd_r = af_hd_r + chr(af_hd_hi * 16.0 + af_hd_lo)
            end
            af_hd_i = af_hd_i + 2.0
          end
          afs = af_hd_r
          af_is_str = 1.0
        elif afn == "add_seconds"
          afr = afa0f + afa1f
        elif afn == "add_minutes"
          afr = afa0f + afa1f * 60.0
        elif afn == "add_hours"
          afr = afa0f + afa1f * 3600.0
        elif afn == "add_days"
          afr = afa0f + afa1f * 86400.0
        elif afn == "diff_seconds"
          afr = afa0f - afa1f
        elif afn == "diff_hours"
          afr = (afa0f - afa1f) / 3600.0
        elif afn == "diff_days"
          afr = (afa0f - afa1f) / 86400.0
        elif afn == "file_exists"
          afr = file_exists(afa0)
        elif afn == "file_size"
          afr = file_size(afa0)
        elif afn == "is_directory"
          afr = is_directory(afa0)
        elif afn == "regex_match"
          afs = regex_match(afa0, afa1)
          af_is_str = 1.0
        elif afn == "type_of"
          if map_has(env_num, afa0)
            afs = "float"
          elif map_has(env_s, afa0)
            afs = "string"
          else
            afs = "unknown"
          end
          af_is_str = 1.0
        end
        if af_is_str == 1.0
          map_set(env_s, aname, afs)
        else
          afs = str(afr)
          map_set(env_num, aname, afr)
          map_set(env_s, aname, afs)
        end
        // post-call arithmetic: x = floor(y) * 2.0
        if cur < tok_count && tok_types[cur] == "op"
          let afpc_op = tok_values[cur]
          if afpc_op == "+" || afpc_op == "-" || afpc_op == "*" || afpc_op == "/"
            cur = cur + 1.0
            let afpc_rt = tok_types[cur]
            let afpc_rv = tok_values[cur]
            cur = cur + 1.0
            let mut afpc_rhs = 0.0
            if afpc_rt == "float"
              afpc_rhs = float(afpc_rv)
            elif afpc_rt == "ident" && map_has(env_num, afpc_rv)
              afpc_rhs = map_get(env_num, afpc_rv)
            end
            let mut afpc_lhs = afr
            let mut afpc_res = 0.0
            if afpc_op == "+"
              afpc_res = afpc_lhs + afpc_rhs
            elif afpc_op == "-"
              afpc_res = afpc_lhs - afpc_rhs
            elif afpc_op == "*"
              afpc_res = afpc_lhs * afpc_rhs
            elif afpc_op == "/"
              afpc_res = afpc_lhs / afpc_rhs
            end
            map_set(env_num, aname, afpc_res)
            map_set(env_s, aname, str(afpc_res))
          end
        end
      // assignment with user-defined fn call RHS: x = user_fn(args)
      elif artt == "ident" && cur < tok_count && tok_values[cur] == "(" && map_has(fn_start, artv)
        let aufn = artv
        cur = cur + 1.0  // skip (
        let mut au_args = []
        let mut au_argt = []
        while cur < tok_count && tok_values[cur] != ")"
          let auct = tok_types[cur]
          let aucv = tok_values[cur]
          if auct == "ident" || auct == "float" || auct == "str"
            let aunxt = cur + 1.0
            if aunxt < tok_count && (tok_values[aunxt] == "+" || tok_values[aunxt] == "-" || tok_values[aunxt] == "*" || tok_values[aunxt] == "/")
              let auop = tok_values[aunxt]
              let aunxt2 = aunxt + 1.0
              if aunxt2 < tok_count && (tok_types[aunxt2] == "ident" || tok_types[aunxt2] == "float")
                let mut aulhs = 0.0
                if auct == "float"
                  aulhs = float(aucv)
                elif map_has(env_num, aucv)
                  aulhs = map_get(env_num, aucv)
                end
                let aurv = tok_values[aunxt2]
                let mut aurhs = 0.0
                if tok_types[aunxt2] == "float"
                  aurhs = float(aurv)
                elif map_has(env_num, aurv)
                  aurhs = map_get(env_num, aurv)
                end
                let mut auexpr = 0.0
                if auop == "+"
                  auexpr = aulhs + aurhs
                elif auop == "-"
                  auexpr = aulhs - aurhs
                elif auop == "*"
                  auexpr = aulhs * aurhs
                elif auop == "/"
                  auexpr = aulhs / aurhs
                end
                push(au_args, str(auexpr))
                push(au_argt, "float")
                cur = aunxt2 + 1.0
              else
                push(au_args, aucv)
                push(au_argt, auct)
                cur = cur + 1.0
              end
            else
              push(au_args, aucv)
              push(au_argt, auct)
              cur = cur + 1.0
            end
          else
            cur = cur + 1.0
          end
        end
        if cur < tok_count
          cur = cur + 1.0  // skip )
        end
        // bind args to params
        let au_raw_params = map_get(fn_params, aufn)
        let au_pnames = split(au_raw_params, " ")
        let au_nparams = len(au_pnames)
        let au_nargs = len(au_args)
        // save caller's values for params AND callee locals (scope isolation)
        let mut au_save_cnt = 0.0
        let mut au_si = 0.0
        while au_si < au_nparams
          let au_sp = au_pnames[au_si]
          if map_has(env_num, au_sp)
            push(save_stack_names, au_sp)
            push(save_stack_nums, str(map_get(env_num, au_sp)))
            if map_has(env_s, au_sp)
              push(save_stack_strs, map_get(env_s, au_sp))
            else
              push(save_stack_strs, "")
            end
            au_save_cnt = au_save_cnt + 1.0
          end
          au_si = au_si + 1.0
        end
        // also save callee's local var names
        if map_has(fn_locals, aufn)
          let au_callee_locals = split(map_get(fn_locals, aufn), " ")
          let mut au_cli = 0.0
          while au_cli < len(au_callee_locals)
            let au_cl = au_callee_locals[au_cli]
            if map_has(env_num, au_cl)
              push(save_stack_names, au_cl)
              push(save_stack_nums, str(map_get(env_num, au_cl)))
              if map_has(env_s, au_cl)
                push(save_stack_strs, map_get(env_s, au_cl))
              else
                push(save_stack_strs, "")
              end
              au_save_cnt = au_save_cnt + 1.0
            end
            au_cli = au_cli + 1.0
          end
        end
        push(save_stack_count, str(au_save_cnt))
        let mut au_pi = 0.0
        while au_pi < au_nparams && au_pi < au_nargs
          let au_pn = au_pnames[au_pi]
          let au_av = au_args[au_pi]
          let au_at = au_argt[au_pi]
          if au_at == "str"
            map_set(env_s, au_pn, au_av)
          elif is_match(au_av, "^[0-9]") || is_match(au_av, "^-[0-9]")
            let au_af = float(au_av)
            map_set(env_num, au_pn, au_af)
            map_set(env_s, au_pn, au_av)
          else
            if map_has(env_num, au_av)
              map_set(env_num, au_pn, map_get(env_num, au_av))
            end
            if map_has(env_s, au_av)
              map_set(env_s, au_pn, map_get(env_s, au_av))
            end
          end
          au_pi = au_pi + 1.0
        end
        push(cstack_type, "fn")
        push(cstack_pos, cur)
        push(call_dest, aname)
        cur = map_get(fn_start, aufn)
      elif cur < tok_count && tok_types[cur] == "op"
        let aop = tok_values[cur]
        if aop == "+" || aop == "-" || aop == "*" || aop == "/"
          cur = cur + 1.0
          let artt2 = tok_types[cur]
          let artv2 = tok_values[cur]
          cur = cur + 1.0
          // check if rhs2 is array[idx], function call, or simple value
          let mut ar2_s = ""
          let mut ar2_f = 0.0
          let mut ar2_is_fn = 0.0
          if artt2 == "ident" && cur < tok_count && tok_values[cur] == "["
            // arr[idx] as rhs operand: e.g. p_rhs + tok_values[pc]
            ar2_is_fn = 1.0
            cur = cur + 1.0  // skip [
            let ar2_idx_t = tok_types[cur]
            let ar2_idx_v = tok_values[cur]
            cur = cur + 1.0  // skip idx
            if cur < tok_count && tok_values[cur] == "]"
              cur = cur + 1.0  // skip ]
            end
            let mut ar2_idx_f = 0.0
            if ar2_idx_t == "ident" && map_has(env_num, ar2_idx_v)
              ar2_idx_f = map_get(env_num, ar2_idx_v)
            end
            if ar2_idx_t == "float"
              ar2_idx_f = float(ar2_idx_v)
            end
            let ar2_akey = "__arr_" + artv2
            if map_has(env_s, ar2_akey)
              let ar2_enc = map_get(env_s, ar2_akey)
              let ar2_parts = split(ar2_enc, SEP)
              let ar2_ai = ar2_idx_f
              if ar2_ai < len(ar2_parts)
                ar2_s = ar2_parts[ar2_ai]
                if is_match(ar2_s, "^[0-9]")
                  ar2_f = float(ar2_s)
                end
                if is_match(ar2_s, "^-[0-9]")
                  ar2_f = float(ar2_s)
                end
              end
            end
          elif artt2 == "ident" && artv2 == "map_get" && cur < tok_count && tok_values[cur] == "("
            ar2_is_fn = 1.0
            cur = cur + 1.0  // skip (
            let amg2_raw_m = tok_values[cur]
            cur = cur + 1.0  // skip map name
            cur = cur + 1.0  // skip ,
            let amg2_kt = tok_types[cur]
            let amg2_kv = tok_values[cur]
            cur = cur + 1.0  // skip key
            if cur < tok_count && tok_values[cur] == ")"
              cur = cur + 1.0
            end
            let mut amg2_key = amg2_kv
            if amg2_kt == "ident" && map_has(env_s, amg2_kv)
              let amg2_kr = map_get(env_s, amg2_kv)
              amg2_key = amg2_kr
            end
            let amg2_ck = "__map_" + amg2_raw_m + "." + amg2_key
            if map_has(env_num, amg2_ck)
              ar2_f = map_get(env_num, amg2_ck)
              ar2_s = str(ar2_f)
            end
            if map_has(env_s, amg2_ck)
              ar2_s = map_get(env_s, amg2_ck)
            end
          elif artt2 == "ident" && cur < tok_count && tok_values[cur] == "("
            ar2_is_fn = 1.0
            cur = cur + 1.0  // skip (
            let mut rc_a0n = ""
            let mut rc_a0f = 0.0
            if cur < tok_count && tok_values[cur] != ")"
              let rca0t = tok_types[cur]
              let rca0v = tok_values[cur]
              cur = cur + 1.0
              if rca0t == "str"
                rc_a0n = rca0v
              elif rca0t == "float"
                rc_a0n = rca0v
                rc_a0f = float(rca0v)
              else
                if map_has(env_s, rca0v)
                  rc_a0n = map_get(env_s, rca0v)
                end
                if map_has(env_num, rca0v)
                  rc_a0f = map_get(env_num, rca0v)
                end
              end
            end
            // arithmetic in first arg: floor(x / y), abs(a - b)
            if cur < tok_count && tok_types[cur] == "op"
              let rca_iop = tok_values[cur]
              if rca_iop == "+" || rca_iop == "-" || rca_iop == "*" || rca_iop == "/"
                cur = cur + 1.0
                let rca_bt = tok_types[cur]
                let rca_bv = tok_values[cur]
                cur = cur + 1.0
                let mut rca_bf = 0.0
                if rca_bt == "float"
                  rca_bf = float(rca_bv)
                end
                if rca_bt == "ident" && map_has(env_num, rca_bv)
                  rca_bf = map_get(env_num, rca_bv)
                end
                if rca_iop == "+"
                  rc_a0f = rc_a0f + rca_bf
                elif rca_iop == "-"
                  rc_a0f = rc_a0f - rca_bf
                elif rca_iop == "*"
                  rc_a0f = rc_a0f * rca_bf
                elif rca_iop == "/"
                  rc_a0f = rc_a0f / rca_bf
                end
                rc_a0n = str(rc_a0f)
              end
            end
            if cur < tok_count && tok_values[cur] == ","
              cur = cur + 1.0
            end
            let mut rc_a1n = ""
            let mut rc_a1f = 0.0
            if cur < tok_count && tok_values[cur] != ")"
              let rca1t = tok_types[cur]
              let rca1v = tok_values[cur]
              cur = cur + 1.0
              if rca1t == "str"
                rc_a1n = rca1v
              elif rca1t == "float"
                rc_a1n = rca1v
                rc_a1f = float(rca1v)
              else
                if map_has(env_s, rca1v)
                  rc_a1n = map_get(env_s, rca1v)
                end
                if map_has(env_num, rca1v)
                  rc_a1f = map_get(env_num, rca1v)
                end
              end
            end
            if cur < tok_count && tok_values[cur] == ")"
              cur = cur + 1.0
            end
            if artv2 == "char_at"
              ar2_s = char_at(rc_a0n, rc_a1f)
            elif artv2 == "str"
              ar2_s = str(rc_a0f)
              ar2_f = rc_a0f
            elif artv2 == "ord"
              ar2_f = ord(rc_a0n)
              ar2_s = str(ar2_f)
            elif artv2 == "floor"
              ar2_f = floor(rc_a0f)
              ar2_s = str(ar2_f)
            elif artv2 == "ceil"
              ar2_f = ceil(rc_a0f)
              ar2_s = str(ar2_f)
            elif artv2 == "abs"
              ar2_f = abs(rc_a0f)
              ar2_s = str(ar2_f)
            elif artv2 == "sqrt"
              ar2_f = sqrt(rc_a0f)
              ar2_s = str(ar2_f)
            elif artv2 == "round"
              ar2_f = round(rc_a0f)
              ar2_s = str(ar2_f)
            elif artv2 == "float"
              ar2_f = float(rc_a0n)
              ar2_s = str(ar2_f)
            elif artv2 == "len"
              ar2_f = len(rc_a0n)
              ar2_s = str(ar2_f)
            elif artv2 == "pow"
              ar2_f = pow(rc_a0f, rc_a1f)
              ar2_s = str(ar2_f)
            end
          elif artt2 == "op" && artv2 == "("
            // parenthesized sub-expression: result * (n - i)
            ar2_is_fn = 1.0
            let pe_t1 = tok_types[cur]
            let pe_v1 = tok_values[cur]
            cur = cur + 1.0
            let mut pe_f = 0.0
            if pe_t1 == "float"
              pe_f = float(pe_v1)
            end
            if pe_t1 == "ident" && map_has(env_num, pe_v1)
              pe_f = map_get(env_num, pe_v1)
            end
            // evaluate operations until )
            let mut pe_go = 1.0
            while pe_go == 1.0 && cur < tok_count && tok_values[cur] != ")"
              let pe_op = tok_values[cur]
              cur = cur + 1.0
              let pe_nt = tok_types[cur]
              let pe_nv = tok_values[cur]
              cur = cur + 1.0
              let mut pe_nf = 0.0
              if pe_nt == "float"
                pe_nf = float(pe_nv)
              end
              if pe_nt == "ident" && map_has(env_num, pe_nv)
                pe_nf = map_get(env_num, pe_nv)
              end
              if pe_op == "+"
                pe_f = pe_f + pe_nf
              elif pe_op == "-"
                pe_f = pe_f - pe_nf
              elif pe_op == "*"
                pe_f = pe_f * pe_nf
              elif pe_op == "/"
                pe_f = pe_f / pe_nf
              else
                pe_go = 0.0
              end
            end
            if cur < tok_count && tok_values[cur] == ")"
              cur = cur + 1.0
            end
            ar2_f = pe_f
            ar2_s = str(pe_f)
          end
          // resolve lhs operand
          let mut alf = 0.0
          let mut als = ""
          if artt == "float"
            alf = float(artv)
            als = artv
          end
          if artt == "str"
            als = artv
          end
          if artt == "ident" && map_has(env_num, artv)
            alf = map_get(env_num, artv)
          end
          if artt == "ident" && map_has(env_s, artv)
            als = map_get(env_s, artv)
          end
          // resolve rhs operand if not fn call
          let mut arf = 0.0
          if ar2_is_fn == 0.0
            if artt2 == "float"
              arf = float(artv2)
              ar2_s = artv2
            end
            if artt2 == "str"
              ar2_s = artv2
            end
            if artt2 == "ident" && map_has(env_num, artv2)
              arf = map_get(env_num, artv2)
            end
            if artt2 == "ident" && map_has(env_s, artv2)
              ar2_s = map_get(env_s, artv2)
            end
          else
            arf = ar2_f
          end
          // multi-term precedence: fold * / into arf when main op is + or -
          if aop == "+" || aop == "-"
            let mut mf_cont = 1.0
            while mf_cont == 1.0 && cur < tok_count && tok_types[cur] == "op"
              let mf_opv = tok_values[cur]
              if mf_opv == "*" || mf_opv == "/"
                cur = cur + 1.0
                let mf_nt = tok_types[cur]
                let mf_nv = tok_values[cur]
                cur = cur + 1.0
                let mut mf_nf = 0.0
                if mf_nt == "float"
                  mf_nf = float(mf_nv)
                end
                if mf_nt == "ident" && map_has(env_num, mf_nv)
                  mf_nf = map_get(env_num, mf_nv)
                end
                if mf_opv == "*"
                  arf = arf * mf_nf
                elif mf_opv == "/"
                  arf = arf / mf_nf
                end
              else
                mf_cont = 0.0
              end
            end
          end
          // detect string concatenation: lhs is string-only or result is string
          let mut a_use_str = 0.0
          if aop == "+"
            if artt == "str"
              a_use_str = 1.0
            end
            if artt == "ident" && map_has(env_s, artv)
              if map_has(env_num, artv)
              else
                a_use_str = 1.0
              end
            end
            if artt2 == "str"
              a_use_str = 1.0
            end
            if ar2_is_fn == 1.0 && artv2 == "char_at"
              a_use_str = 1.0
            end
            if ar2_is_fn == 1.0 && map_has(env_s, "__arr_" + artv2)
              // only treat as string concat if element is not numeric
              if is_match(ar2_s, "^[0-9]") == 0.0 && is_match(ar2_s, "^-[0-9]") == 0.0
                a_use_str = 1.0
              end
            end
          end
          if aop == "+" && a_use_str == 1.0
            let mut a_concat = als + ar2_s
            // chained concat: handle a + b + c + d
            while cur < tok_count && tok_values[cur] == "+"
              cur = cur + 1.0
              let ac_t = tok_types[cur]
              let ac_v = tok_values[cur]
              cur = cur + 1.0
              let mut ac_s = ac_v
              if ac_t == "ident" && map_has(env_s, ac_v)
                ac_s = map_get(env_s, ac_v)
              end
              a_concat = a_concat + ac_s
            end
            map_set(env_s, aname, a_concat)
          else
            let mut ares = 0.0
            if aop == "+"
              ares = alf + arf
            end
            if aop == "-"
              ares = alf - arf
            end
            if aop == "*"
              ares = alf * arf
            end
            if aop == "/"
              ares = alf / arf
            end
            // handle additional +/- terms: y = a - b + c - d
            let mut mt_go = 1.0
            while mt_go == 1.0 && cur < tok_count && tok_types[cur] == "op"
              let mt_op = tok_values[cur]
              if mt_op == "+" || mt_op == "-"
                cur = cur + 1.0
                let mt_t = tok_types[cur]
                let mt_v = tok_values[cur]
                cur = cur + 1.0
                let mut mt_f = 0.0
                if mt_t == "float"
                  mt_f = float(mt_v)
                end
                if mt_t == "ident" && map_has(env_num, mt_v)
                  mt_f = map_get(env_num, mt_v)
                end
                // fold higher-precedence * / into this term
                let mut mt_fgo = 1.0
                while mt_fgo == 1.0 && cur < tok_count && tok_types[cur] == "op"
                  let mt_fop = tok_values[cur]
                  if mt_fop == "*" || mt_fop == "/"
                    cur = cur + 1.0
                    let mt_ft = tok_types[cur]
                    let mt_fv = tok_values[cur]
                    cur = cur + 1.0
                    let mut mt_ff = 0.0
                    if mt_ft == "float"
                      mt_ff = float(mt_fv)
                    end
                    if mt_ft == "ident" && map_has(env_num, mt_fv)
                      mt_ff = map_get(env_num, mt_fv)
                    end
                    if mt_fop == "*"
                      mt_f = mt_f * mt_ff
                    elif mt_fop == "/"
                      mt_f = mt_f / mt_ff
                    end
                  else
                    mt_fgo = 0.0
                  end
                end
                if mt_op == "+"
                  ares = ares + mt_f
                elif mt_op == "-"
                  ares = ares - mt_f
                end
              else
                mt_go = 0.0
              end
            end
            map_set(env_num, aname, ares)
            map_set(env_s, aname, str(ares))
          end
        elif aop == "["
          // array read: aname = artv[idx]
          cur = cur + 1.0  // consume [
          let aa_idx_t = tok_types[cur]
          let aa_idx_v = tok_values[cur]
          cur = cur + 1.0  // skip idx
          if cur < tok_count && tok_values[cur] == "]"
            cur = cur + 1.0  // skip ]
          end
          let mut aa_idx_f = 0.0
          if aa_idx_t == "float"
            aa_idx_f = float(aa_idx_v)
          end
          if aa_idx_t == "ident" && map_has(env_num, aa_idx_v)
            aa_idx_f = map_get(env_num, aa_idx_v)
          end
          let aa_key = "__arr_" + artv
          if map_has(env_s, aa_key)
            let aa_enc = map_get(env_s, aa_key)
            let aa_parts = split(aa_enc, SEP)
            if aa_idx_f < len(aa_parts)
              let aa_elem = aa_parts[aa_idx_f]
              map_set(env_s, aname, aa_elem)
              if is_match(aa_elem, "^[0-9]")
                let aa_f = float(aa_elem)
                map_set(env_num, aname, aa_f)
              end
              if is_match(aa_elem, "^-[0-9]")
                let aa_f2 = float(aa_elem)
                map_set(env_num, aname, aa_f2)
              end
            end
          end
        else
          // map_get(m, k) as sole RHS when aop was "("
          if artv == "map_get"
            cur = cur + 1.0  // skip (
            let amg_raw_m = tok_values[cur]
            cur = cur + 1.0  // skip map name
            cur = cur + 1.0  // skip ,
            let amg_kt = tok_types[cur]
            let amg_kv = tok_values[cur]
            cur = cur + 1.0  // skip key
            if cur < tok_count && tok_values[cur] == ")"
              cur = cur + 1.0
            end
            let mut amg_key = amg_kv
            if amg_kt == "ident" && map_has(env_s, amg_kv)
              let amg_kr = map_get(env_s, amg_kv)
              amg_key = amg_kr
            end
            let amg_ck = "__map_" + amg_raw_m + "." + amg_key
            if map_has(env_num, amg_ck)
              let amg_nv = map_get(env_num, amg_ck)
              map_set(env_num, aname, amg_nv)
              map_set(env_s, aname, str(amg_nv))
            end
            if map_has(env_s, amg_ck)
              let amg_sv = map_get(env_s, amg_ck)
              map_set(env_s, aname, amg_sv)
            end
          else
            // single value, non-arithmetic op follows
            if artt == "float"
              let afv = float(artv)
              map_set(env_num, aname, afv)
              map_set(env_s, aname, str(afv))
            end
            if artt == "str"
              map_set(env_s, aname, artv)
            end
            if artt == "ident" && map_has(env_num, artv)
              let anv = map_get(env_num, artv)
              map_set(env_num, aname, anv)
              map_set(env_s, aname, str(anv))
            end
            if artt == "ident" && map_has(env_s, artv)
              let asv = map_get(env_s, artv)
              map_set(env_s, aname, asv)
            end
          end
        end
      else
        // single value rhs
        if artt == "float"
          let afv = float(artv)
          map_set(env_num, aname, afv)
          map_set(env_s, aname, str(afv))
        end
        if artt == "str"
          map_set(env_s, aname, artv)
        end
        if artt == "ident" && map_has(env_num, artv)
          let anv = map_get(env_num, artv)
          map_set(env_num, aname, anv)
          map_set(env_s, aname, str(anv))
        end
        if artt == "ident" && map_has(env_s, artv)
          let asv = map_get(env_s, artv)
          map_set(env_s, aname, asv)
        end
      end
    elif an1 < tok_count && tok_values[an1] == "("
      // ── Bare function call as statement (ExprStmt) ─────────────────
      let xs_fname = tv
      cur = cur + 2.0  // skip fname and (
      let mut xs_args = []
      let mut xs_argt = []
      while cur < tok_count && tok_values[cur] != ")"
        if tok_types[cur] == "ident" || tok_types[cur] == "float" || tok_types[cur] == "str"
          // Check for arr[idx] pattern: ident followed by [
          let xs_next = cur + 1.0
          if tok_types[cur] == "ident" && xs_next < tok_count && tok_values[xs_next] == "["
            // arr[idx] — resolve array element
            let xs_aname = tok_values[cur]
            cur = cur + 2.0  // skip ident and [
            // resolve index (ident or float)
            let mut xs_aidx = 0.0
            if tok_types[cur] == "float"
              xs_aidx = float(tok_values[cur])
            elif tok_types[cur] == "ident" && map_has(env_num, tok_values[cur])
              xs_aidx = map_get(env_num, tok_values[cur])
            end
            cur = cur + 1.0  // skip index
            if cur < tok_count && tok_values[cur] == "]"
              cur = cur + 1.0  // skip ]
            end
            // resolve array name (may be aliased)
            let mut xs_areal = xs_aname
            let xs_aa = "__arr_alias_" + xs_aname
            if map_has(env_s, xs_aa)
              xs_areal = map_get(env_s, xs_aa)
            end
            let xs_ak = "__arr_" + xs_areal
            if map_has(env_s, xs_ak)
              let xs_enc = map_get(env_s, xs_ak)
              let xs_elems = split(xs_enc, SEP)
              let xs_idx_i = floor(xs_aidx)
              if xs_idx_i < len(xs_elems)
                push(xs_args, xs_elems[xs_idx_i])
                push(xs_argt, "float")
              else
                push(xs_args, "0")
                push(xs_argt, "float")
              end
            else
              push(xs_args, "0")
              push(xs_argt, "float")
            end
            // don't advance cur — while loop condition will check next token
            if cur < tok_count && tok_values[cur] == ","
              cur = cur + 1.0
            end
          else
            push(xs_args, tok_values[cur])
            push(xs_argt, tok_types[cur])
            cur = cur + 1.0
          end
        else
          cur = cur + 1.0
        end
      end
      if cur < tok_count
        cur = cur + 1.0  // skip )
      end
      // resolve up to 8 args to floats
      let mut xf0 = 0.0
      let mut xf1 = 0.0
      let mut xf2 = 0.0
      let mut xf3 = 0.0
      let mut xf4 = 0.0
      let mut xf5 = 0.0
      let mut xf6 = 0.0
      let mut xf7 = 0.0
      if len(xs_args) > 0.0
        let xr0 = xs_args[0]
        if xs_argt[0] == "float"
          xf0 = float(xr0)
        elif map_has(env_num, xr0)
          xf0 = map_get(env_num, xr0)
        end
      end
      if len(xs_args) > 1.0
        let xr1 = xs_args[1]
        if xs_argt[1] == "float"
          xf1 = float(xr1)
        elif map_has(env_num, xr1)
          xf1 = map_get(env_num, xr1)
        end
      end
      if len(xs_args) > 2.0
        let xr2 = xs_args[2]
        if xs_argt[2] == "float"
          xf2 = float(xr2)
        elif map_has(env_num, xr2)
          xf2 = map_get(env_num, xr2)
        end
      end
      if len(xs_args) > 3.0
        let xr3 = xs_args[3]
        if xs_argt[3] == "float"
          xf3 = float(xr3)
        elif map_has(env_num, xr3)
          xf3 = map_get(env_num, xr3)
        end
      end
      // dispatch — user fn first
      if map_has(fn_start, xs_fname)
        let raw_p = map_get(fn_params, xs_fname)
        let pn = split(raw_p, " ")
        let mut xpi = 0.0
        while xpi < len(pn) && xpi < len(xs_args)
          let xpn = pn[xpi]
          let xav = xs_args[xpi]
          if xs_argt[xpi] == "str"
            map_set(env_s, xpn, xav)
          elif xs_argt[xpi] == "float"
            map_set(env_num, xpn, float(xav))
            map_set(env_s, xpn, xav)
          else
            if map_has(env_num, xav)
              map_set(env_num, xpn, map_get(env_num, xav))
            end
            if map_has(env_s, xav)
              map_set(env_s, xpn, map_get(env_s, xav))
            end
            // forward arrays (pass-by-reference)
            let xav_akey = "__arr_" + xav
            if map_has(env_s, xav_akey)
              let xpn_alias = "__arr_alias_" + xpn
              map_set(env_s, xpn_alias, xav)
              let xpn_akey = "__arr_" + xpn
              let xpn_lkey = "__len_" + xpn
              let xav_lkey = "__len_" + xav
              map_set(env_s, xpn_akey, map_get(env_s, xav_akey))
              if map_has(env_num, xav_lkey)
                map_set(env_num, xpn_lkey, map_get(env_num, xav_lkey))
              end
            end
            // forward maps (pass-by-reference)
            let xav_mmark = "__map_" + xav
            if map_has(env_s, xav_mmark)
              let xpn_malias = "__map_alias_" + xpn
              map_set(env_s, xpn_malias, xav)
              let xpn_mmark = "__map_" + xpn
              map_set(env_s, xpn_mmark, "exists")
            end
          end
          xpi = xpi + 1.0
        end
        push(cstack_type, "fn")
        push(cstack_pos, cur)
        push(call_dest, "__discard")
        cur = map_get(fn_start, xs_fname)
      // mem_* builtins as bare statements
      elif xs_fname == "mem_free"
        let _xr2 = mem_free(xf0)
      elif xs_fname == "mem_set_u32"
        let _xr2 = mem_set_u32(xf0, xf1, xf2)
      elif xs_fname == "mem_set_f32"
        let _xr2 = mem_set_f32(xf0, xf1, xf2)
      elif xs_fname == "mem_set_ptr"
        let _xr2 = mem_set_ptr(xf0, xf1, xf2)
      elif xs_fname == "mem_set_u8"
        let _xr2 = mem_set_u8(xf0, xf1, xf2)
      elif xs_fname == "mem_set_u64"
        let _xr2 = mem_set_u64(xf0, xf1, xf2)
      // FFI bare calls (void-like)
      elif xs_fname == "vkDestroyInstance"
        let _xr2 = vkDestroyInstance(xf0, xf1)
      elif xs_fname == "vkDestroyDevice"
        let _xr2 = vkDestroyDevice(xf0, xf1)
      elif xs_fname == "vkDestroyBuffer"
        let _xr2 = vkDestroyBuffer(xf0, xf1, xf2)
      elif xs_fname == "vkFreeMemory"
        let _xr2 = vkFreeMemory(xf0, xf1, xf2)
      elif xs_fname == "vkUnmapMemory"
        let _xr2 = vkUnmapMemory(xf0, xf1)
      elif xs_fname == "vkDestroyShaderModule"
        let _xr2 = vkDestroyShaderModule(xf0, xf1, xf2)
      elif xs_fname == "vkDestroyDescriptorSetLayout"
        let _xr2 = vkDestroyDescriptorSetLayout(xf0, xf1, xf2)
      elif xs_fname == "vkDestroyPipelineLayout"
        let _xr2 = vkDestroyPipelineLayout(xf0, xf1, xf2)
      elif xs_fname == "vkDestroyPipeline"
        let _xr2 = vkDestroyPipeline(xf0, xf1, xf2)
      elif xs_fname == "vkDestroyDescriptorPool"
        let _xr2 = vkDestroyDescriptorPool(xf0, xf1, xf2)
      elif xs_fname == "vkFreeCommandBuffers"
        let _xr2 = vkFreeCommandBuffers(xf0, xf1, xf2, xf3)
      elif xs_fname == "vkDestroyCommandPool"
        let _xr2 = vkDestroyCommandPool(xf0, xf1, xf2)
      elif xs_fname == "vkDestroyFence"
        let _xr2 = vkDestroyFence(xf0, xf1, xf2)
      elif xs_fname == "vkGetPhysicalDeviceMemoryProperties"
        let _xr2 = vkGetPhysicalDeviceMemoryProperties(xf0, xf1)
      elif xs_fname == "vkGetDeviceQueue"
        let _xr2 = vkGetDeviceQueue(xf0, xf1, xf2, xf3)
      elif xs_fname == "vkGetBufferMemoryRequirements"
        let _xr2 = vkGetBufferMemoryRequirements(xf0, xf1, xf2)
      elif xs_fname == "puts"
        let _xr2 = puts(xf0)
      elif xs_fname == "fclose"
        let _xr2 = fclose(xf0)
      elif xs_fname == "map_set"
        // map_set as bare call (not keyword-triggered)
        let mut xms_map = xs_args[0]
        let xms_malias = "__map_alias_" + xms_map
        if map_has(env_s, xms_malias)
          xms_map = map_get(env_s, xms_malias)
        end
        let xms_kt = xs_argt[1]
        let xms_kv = xs_args[1]
        let mut xms_key = xms_kv
        if xms_kt == "ident" && map_has(env_s, xms_kv)
          xms_key = map_get(env_s, xms_kv)
        end
        let xms_vt = xs_argt[2]
        let xms_vv = xs_args[2]
        let xms_ck = "__map_" + xms_map + "." + xms_key
        if xms_vt == "float"
          map_set(env_num, xms_ck, float(xms_vv))
          map_set(env_s, xms_ck, xms_vv)
        elif xms_vt == "str"
          map_set(env_s, xms_ck, xms_vv)
        elif xms_vt == "ident"
          if map_has(env_num, xms_vv)
            map_set(env_num, xms_ck, map_get(env_num, xms_vv))
          end
          if map_has(env_s, xms_vv)
            map_set(env_s, xms_ck, map_get(env_s, xms_vv))
          end
        end
        // track keys for map_keys()
        let xms_kk = "__map_keys_" + xms_map
        if map_has(env_s, xms_kk)
          let xms_existing = map_get(env_s, xms_kk)
          // check if key already tracked
          if contains(xms_existing, xms_key) == 0.0
            map_set(env_s, xms_kk, xms_existing + SEP + xms_key)
          end
        else
          map_set(env_s, xms_kk, xms_key)
        end
      elif xs_fname == "write_bytes"
        // write_bytes(path, arr) — write array as binary
        let xwb_path = ""
        let xwb_pt = xs_argt[0]
        let xwb_pv = xs_args[0]
        let mut xwb_p = xwb_pv
        if xwb_pt == "ident" && map_has(env_s, xwb_pv)
          xwb_p = map_get(env_s, xwb_pv)
        end
        let xwb_aname = xs_args[1]
        let mut xwb_real = xwb_aname
        let xwb_alias = "__arr_alias_" + xwb_aname
        if map_has(env_s, xwb_alias)
          xwb_real = map_get(env_s, xwb_alias)
        end
        let xwb_akey = "__arr_" + xwb_real
        if map_has(env_s, xwb_akey)
          let xwb_enc = map_get(env_s, xwb_akey)
          let xwb_parts = split(xwb_enc, SEP)
          // convert to float array and call write_bytes
          let mut xwb_arr = []
          let mut xwb_i = 0.0
          while xwb_i < len(xwb_parts)
            push(xwb_arr, float(xwb_parts[xwb_i]))
            xwb_i = xwb_i + 1.0
          end
          write_bytes(xwb_p, xwb_arr)
        end
      elif xs_fname == "write_file"
        // write_file(path, content) — write string to file
        let xwf_pt = xs_argt[0]
        let xwf_pv = xs_args[0]
        let mut xwf_p = xwf_pv
        if xwf_pt == "ident" && map_has(env_s, xwf_pv)
          xwf_p = map_get(env_s, xwf_pv)
        end
        let xwf_ct = xs_argt[1]
        let xwf_cv = xs_args[1]
        let mut xwf_c = xwf_cv
        if xwf_ct == "ident" && map_has(env_s, xwf_cv)
          xwf_c = map_get(env_s, xwf_cv)
        end
        write_file(xwf_p, xwf_c)
      end
    else
      cur = cur + 1.0
    end

  // Unknown: skip
  else
    cur = cur + 1.0
  end
end

print("--- OctoFlow Eval Done ---")
