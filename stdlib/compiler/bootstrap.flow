// stdlib/compiler/bootstrap.flow
// OctoFlow Self-Hosting Bootstrap (Phase 53)
//
// Validates the self-hosting compiler chain by comparing:
//   v1 = Rust runtime  (octoflow run prog.flow)
//   v2 = eval.flow     (FLOW_INPUT=prog.flow octoflow run eval.flow)
//
// For each program, v1 and v2 must produce identical output.
// This proves eval.flow (pure OctoFlow) correctly implements the language.
//
// Usage:
//   OCTOFLOW_BIN=./target/debug/flowgpu-cli.exe
//   octoflow run stdlib/compiler/bootstrap.flow --allow-read --allow-exec

let octoflow  = env("OCTOFLOW_BIN")
let eval_path = "stdlib/compiler/eval.flow"
let NL        = chr(10)

// ---- TEST SUITE (Phase 53: 11 programs) --------
let mut test_paths = []
push(test_paths, "stdlib/compiler/test_hello.flow")
push(test_paths, "stdlib/compiler/test_fib.flow")
push(test_paths, "stdlib/compiler/test_foreach.flow")
push(test_paths, "stdlib/compiler/test_fn.flow")
push(test_paths, "stdlib/compiler/test_while.flow")
push(test_paths, "stdlib/compiler/test_if_elif.flow")
push(test_paths, "stdlib/compiler/test_elif.flow")
push(test_paths, "stdlib/compiler/test_nested.flow")
push(test_paths, "stdlib/compiler/test_arrays.flow")
push(test_paths, "stdlib/compiler/test_builtins.flow")
push(test_paths, "stdlib/compiler/test_fe2.flow")
push(test_paths, "stdlib/compiler/test_stack.flow")
push(test_paths, "stdlib/compiler/test_while_len.flow")
push(test_paths, "stdlib/compiler/test_map_ops.flow")
push(test_paths, "stdlib/compiler/test_cond_ext.flow")
push(test_paths, "stdlib/compiler/test_split_join.flow")
push(test_paths, "stdlib/compiler/test_nested_fn.flow")
push(test_paths, "stdlib/compiler/test_mini_lexer2.flow")
push(test_paths, "stdlib/compiler/test_mini_lex.flow")
push(test_paths, "stdlib/compiler/test_str_math.flow")
push(test_paths, "stdlib/compiler/test_char_scan.flow")
push(test_paths, "stdlib/compiler/test_triple_cond.flow")
push(test_paths, "stdlib/compiler/test_debug_lexer.flow")
push(test_paths, "stdlib/compiler/test_lexer_ops.flow")
push(test_paths, "stdlib/compiler/test_lexer_full.flow")
let test_count = len(test_paths)

let mut pass_count = 0.0
let mut fail_count = 0.0
let mut skip_count = 0.0

print("=== OctoFlow Self-Hosting Bootstrap (Phase 63) ===")
print("  v1 = Rust runtime  (octoflow run)")
print("  v2 = eval.flow     (pure OctoFlow interpreter)")
print("  Programs: {test_count}")
print("")

let mut ti = 0.0
while ti < test_count
  let tpath = test_paths[ti]
  print("TEST [{ti}] {tpath}")

  // Run both interpreters unconditionally — normalize outside if blocks
  let v1_r = exec(octoflow, "run", tpath)
  let v2_cmd = "$env:FLOW_INPUT='" + tpath + "'; " + octoflow + " run " + eval_path + " --allow-read"
  let v2_r = exec("powershell", "-Command", v2_cmd)

  // Normalize v1: trim, drop header/status lines and blanks
  let v1_split = split(v1_r.output, NL)
  let mut v1_out = ""
  let mut v1i = 0.0
  while v1i < len(v1_split)
    let vl = trim(v1_split[v1i])
    let skip_it = starts_with(vl, "LINT") || starts_with(vl, "---") || starts_with(vl, "STATUS:") || starts_with(vl, "[D0") || starts_with(vl, "GPU:") || starts_with(vl, "Processed") || starts_with(vl, "Remove") || starts_with(vl, "let ") || starts_with(vl, "stage ")
    if skip_it == 0.0 && len(vl) > 0.0
      if len(v1_out) > 0.0
        v1_out = v1_out + NL
      end
      v1_out = v1_out + vl
    end
    v1i = v1i + 1.0
  end

  // Normalize v2: same filter + strip eval Done footer
  let v2_split = split(v2_r.output, NL)
  let mut v2_out = ""
  let mut v2i = 0.0
  while v2i < len(v2_split)
    let vl2 = trim(v2_split[v2i])
    let skip2 = starts_with(vl2, "LINT") || starts_with(vl2, "---") || starts_with(vl2, "STATUS:") || starts_with(vl2, "[D0") || starts_with(vl2, "GPU:") || starts_with(vl2, "Processed") || starts_with(vl2, "Remove") || starts_with(vl2, "let ") || starts_with(vl2, "stage ")
    if skip2 == 0.0 && len(vl2) > 0.0
      if len(v2_out) > 0.0
        v2_out = v2_out + NL
      end
      v2_out = v2_out + vl2
    end
    v2i = v2i + 1.0
  end

  // Decide outcome (flat if/elif — no deep nesting)
  if v1_r.ok == 0.0
    print("  SKIP (v1 failed): {v1_r.error}")
    skip_count = skip_count + 1.0
  elif v2_r.ok == 0.0
    print("  SKIP (v2 failed): {v2_r.error}")
    skip_count = skip_count + 1.0
  elif v1_out == v2_out
    print("  PASS")
    pass_count = pass_count + 1.0
  else
    print("  FAIL")
    print("    v1: {v1_out}")
    print("    v2: {v2_out}")
    fail_count = fail_count + 1.0
  end

  ti = ti + 1.0
end

// ---- TOOLCHAIN SELF-TESTS -------------------------------------------
print("")
print("TEST [lexer] Self-lex: eval.flow interprets lexer.flow (Stage 3)")
let lx1_cmd = "$env:FLOW_INPUT='stdlib/compiler/lexer.flow'; " + octoflow + " run stdlib/compiler/lexer.flow --allow-read"
let lx2_cmd = "$env:FLOW_INPUT='stdlib/compiler/lexer.flow'; " + octoflow + " run stdlib/compiler/eval.flow --allow-read"
let lx1_r = exec("powershell", "-Command", lx1_cmd)
let lx2_r = exec("powershell", "-Command", lx2_cmd)
// Normalize both: trim, strip headers/status
let lx1_split = split(lx1_r.output, NL)
let mut lx1_out = ""
let mut lx1i = 0.0
while lx1i < len(lx1_split)
  let lxl = trim(lx1_split[lx1i])
  let lx_skip = starts_with(lxl, "LINT") || starts_with(lxl, "---") || starts_with(lxl, "STATUS:") || starts_with(lxl, "[D0") || starts_with(lxl, "GPU:") || starts_with(lxl, "Processed") || starts_with(lxl, "let ") || starts_with(lxl, "stage ")
  if lx_skip == 0.0 && len(lxl) > 0.0
    if len(lx1_out) > 0.0
      lx1_out = lx1_out + NL
    end
    lx1_out = lx1_out + lxl
  end
  lx1i = lx1i + 1.0
end
let lx2_split = split(lx2_r.output, NL)
let mut lx2_out = ""
let mut lx2i = 0.0
while lx2i < len(lx2_split)
  let lxl2 = trim(lx2_split[lx2i])
  let lx2_skip = starts_with(lxl2, "LINT") || starts_with(lxl2, "---") || starts_with(lxl2, "STATUS:") || starts_with(lxl2, "[D0") || starts_with(lxl2, "GPU:") || starts_with(lxl2, "Processed") || starts_with(lxl2, "let ") || starts_with(lxl2, "stage ")
  if lx2_skip == 0.0 && len(lxl2) > 0.0
    if len(lx2_out) > 0.0
      lx2_out = lx2_out + NL
    end
    lx2_out = lx2_out + lxl2
  end
  lx2i = lx2i + 1.0
end
if lx1_r.ok == 0.0
  print("  SKIP (v1 failed): {lx1_r.error}")
  skip_count = skip_count + 1.0
elif lx2_r.ok == 0.0
  print("  SKIP (v2 failed): {lx2_r.error}")
  skip_count = skip_count + 1.0
elif lx1_out == lx2_out
  print("  PASS: eval.flow correctly interprets lexer.flow (Stage 3 achieved)")
  pass_count = pass_count + 1.0
else
  print("  FAIL: lexer self-lex mismatch")
  fail_count = fail_count + 1.0
end

print("")
print("TEST [parser] Self-parse of parser.flow")
let p1_cmd = "$env:FLOW_INPUT='stdlib/compiler/parser.flow'; " + octoflow + " run stdlib/compiler/parser.flow --allow-read"
let p1_r = exec("powershell", "-Command", p1_cmd)
if p1_r.ok == 1.0
  if contains(p1_r.output, "nodes:")
    print("  PASS: parser.flow parses itself")
    pass_count = pass_count + 1.0
  else
    print("  FAIL: parser.flow self-parse did not produce AST nodes")
    fail_count = fail_count + 1.0
  end
else
  print("  SKIP: {p1_r.error}")
  skip_count = skip_count + 1.0
end

print("")
print("TEST [stage4] eval.flow interprets parser.flow on test_hello.flow (Stage 4)")
let s4_test = "stdlib/compiler/test_hello.flow"
let s4_v1_cmd = "$env:FLOW_INPUT='" + s4_test + "'; " + octoflow + " run stdlib/compiler/parser.flow --allow-read"
let s4_v2_cmd = "$env:EVAL_PROG_PATH='stdlib/compiler/parser.flow'; $env:FLOW_INPUT='" + s4_test + "'; " + octoflow + " run stdlib/compiler/eval.flow --allow-read"
let s4_v1 = exec("powershell", "-Command", s4_v1_cmd)
let s4_v2 = exec("powershell", "-Command", s4_v2_cmd)
let s4_v1_split = split(s4_v1.output, NL)
let mut s4_v1_out = ""
let mut s4_v1i = 0.0
while s4_v1i < len(s4_v1_split)
  let s4l = trim(s4_v1_split[s4_v1i])
  let s4_skip = starts_with(s4l, "LINT") || starts_with(s4l, "---") || starts_with(s4l, "STATUS:") || starts_with(s4l, "[D0") || starts_with(s4l, "GPU:") || starts_with(s4l, "Processed") || starts_with(s4l, "Remove") || starts_with(s4l, "let ") || starts_with(s4l, "stage ")
  if s4_skip == 0.0 && len(s4l) > 0.0
    if len(s4_v1_out) > 0.0
      s4_v1_out = s4_v1_out + NL
    end
    s4_v1_out = s4_v1_out + s4l
  end
  s4_v1i = s4_v1i + 1.0
end
let s4_v2_split = split(s4_v2.output, NL)
let mut s4_v2_out = ""
let mut s4_v2i = 0.0
while s4_v2i < len(s4_v2_split)
  let s4l2 = trim(s4_v2_split[s4_v2i])
  let s4_skip2 = starts_with(s4l2, "LINT") || starts_with(s4l2, "---") || starts_with(s4l2, "STATUS:") || starts_with(s4l2, "[D0") || starts_with(s4l2, "GPU:") || starts_with(s4l2, "Processed") || starts_with(s4l2, "Remove") || starts_with(s4l2, "let ") || starts_with(s4l2, "stage ")
  if s4_skip2 == 0.0 && len(s4l2) > 0.0
    if len(s4_v2_out) > 0.0
      s4_v2_out = s4_v2_out + NL
    end
    s4_v2_out = s4_v2_out + s4l2
  end
  s4_v2i = s4_v2i + 1.0
end
if s4_v1.ok == 0.0
  print("  SKIP (v1 failed): {s4_v1.error}")
  skip_count = skip_count + 1.0
elif s4_v2.ok == 0.0
  print("  SKIP (v2 failed): {s4_v2.error}")
  skip_count = skip_count + 1.0
elif s4_v1_out == s4_v2_out
  print("  PASS: STAGE 4 ACHIEVED — eval.flow interprets parser.flow correctly")
  pass_count = pass_count + 1.0
else
  print("  FAIL: parser AST mismatch")
  print("    v1: {s4_v1_out}")
  print("    v2: {s4_v2_out}")
  fail_count = fail_count + 1.0
end

print("")
print("TEST [preflight] Self-analysis of preflight.flow")
let pf_cmd = "$env:FLOW_INPUT='stdlib/compiler/preflight.flow'; " + octoflow + " run stdlib/compiler/preflight.flow --allow-read"
let pf_r = exec("powershell", "-Command", pf_cmd)
if pf_r.ok == 1.0
  if contains(pf_r.output, "STATUS: OK")
    print("  PASS: preflight.flow is preflight-clean on itself")
    pass_count = pass_count + 1.0
  else
    print("  FAIL: preflight.flow found issues in itself")
    fail_count = fail_count + 1.0
  end
else
  print("  SKIP: {pf_r.error}")
  skip_count = skip_count + 1.0
end

print("")
print("TEST [stage5] eval.flow interprets preflight.flow on test_hello.flow (Stage 5)")
let s5_test = "stdlib/compiler/test_hello.flow"
let s5_v1_cmd = "$env:FLOW_INPUT='" + s5_test + "'; " + octoflow + " run stdlib/compiler/preflight.flow --allow-read"
let s5_v2_cmd = "$env:EVAL_PROG_PATH='stdlib/compiler/preflight.flow'; $env:FLOW_INPUT='" + s5_test + "'; " + octoflow + " run stdlib/compiler/eval.flow --allow-read"
let s5_v1 = exec("powershell", "-Command", s5_v1_cmd)
let s5_v2 = exec("powershell", "-Command", s5_v2_cmd)
let s5_v1_split = split(s5_v1.output, NL)
let mut s5_v1_out = ""
let mut s5_v1i = 0.0
while s5_v1i < len(s5_v1_split)
  let s5l = trim(s5_v1_split[s5_v1i])
  let s5_skip = starts_with(s5l, "LINT") || starts_with(s5l, "---") || starts_with(s5l, "STATUS:") || starts_with(s5l, "[D0") || starts_with(s5l, "GPU:") || starts_with(s5l, "Processed") || starts_with(s5l, "Remove") || starts_with(s5l, "let ") || starts_with(s5l, "stage ")
  if s5_skip == 0.0 && len(s5l) > 0.0
    if len(s5_v1_out) > 0.0
      s5_v1_out = s5_v1_out + NL
    end
    s5_v1_out = s5_v1_out + s5l
  end
  s5_v1i = s5_v1i + 1.0
end
let s5_v2_split = split(s5_v2.output, NL)
let mut s5_v2_out = ""
let mut s5_v2i = 0.0
while s5_v2i < len(s5_v2_split)
  let s5l2 = trim(s5_v2_split[s5_v2i])
  let s5_skip2 = starts_with(s5l2, "LINT") || starts_with(s5l2, "---") || starts_with(s5l2, "STATUS:") || starts_with(s5l2, "[D0") || starts_with(s5l2, "GPU:") || starts_with(s5l2, "Processed") || starts_with(s5l2, "Remove") || starts_with(s5l2, "let ") || starts_with(s5l2, "stage ")
  if s5_skip2 == 0.0 && len(s5l2) > 0.0
    if len(s5_v2_out) > 0.0
      s5_v2_out = s5_v2_out + NL
    end
    s5_v2_out = s5_v2_out + s5l2
  end
  s5_v2i = s5_v2i + 1.0
end
if s5_v1.ok == 0.0
  print("  SKIP (v1 failed): {s5_v1.error}")
  skip_count = skip_count + 1.0
elif s5_v2.ok == 0.0
  print("  SKIP (v2 failed): {s5_v2.error}")
  skip_count = skip_count + 1.0
elif s5_v1_out == s5_v2_out
  print("  PASS: STAGE 5 ACHIEVED — eval.flow interprets preflight.flow correctly")
  pass_count = pass_count + 1.0
else
  print("  FAIL: preflight output mismatch")
  print("    v1: {s5_v1_out}")
  print("    v2: {s5_v2_out}")
  fail_count = fail_count + 1.0
end

print("")
print("TEST [stage6] eval.flow meta-interprets eval.flow on test_hello.flow (Stage 6)")
let s6_test = "stdlib/compiler/test_hello.flow"
let s6_v1_cmd = "$env:FLOW_INPUT='" + s6_test + "'; " + octoflow + " run " + eval_path + " --allow-read"
let s6_v2_cmd = "$env:EVAL_PROG_PATH='" + eval_path + "'; $env:FLOW_INPUT='" + s6_test + "'; " + octoflow + " run " + eval_path + " --allow-read --max-iters 50000000"
let s6_v1 = exec("powershell", "-Command", s6_v1_cmd)
let s6_v2 = exec("powershell", "-Command", s6_v2_cmd)
let s6_v1_split = split(s6_v1.output, NL)
let mut s6_v1_out = ""
let mut s6_v1i = 0.0
while s6_v1i < len(s6_v1_split)
  let s6l = trim(s6_v1_split[s6_v1i])
  let s6_skip = starts_with(s6l, "LINT") || starts_with(s6l, "---") || starts_with(s6l, "STATUS:") || starts_with(s6l, "[D0") || starts_with(s6l, "GPU:") || starts_with(s6l, "Processed") || starts_with(s6l, "Remove") || starts_with(s6l, "let ") || starts_with(s6l, "stage ")
  if s6_skip == 0.0 && len(s6l) > 0.0
    if len(s6_v1_out) > 0.0
      s6_v1_out = s6_v1_out + NL
    end
    s6_v1_out = s6_v1_out + s6l
  end
  s6_v1i = s6_v1i + 1.0
end
let s6_v2_split = split(s6_v2.output, NL)
let mut s6_v2_out = ""
let mut s6_v2i = 0.0
while s6_v2i < len(s6_v2_split)
  let s6l2 = trim(s6_v2_split[s6_v2i])
  let s6_skip2 = starts_with(s6l2, "LINT") || starts_with(s6l2, "---") || starts_with(s6l2, "STATUS:") || starts_with(s6l2, "[D0") || starts_with(s6l2, "GPU:") || starts_with(s6l2, "Processed") || starts_with(s6l2, "Remove") || starts_with(s6l2, "let ") || starts_with(s6l2, "stage ")
  if s6_skip2 == 0.0 && len(s6l2) > 0.0
    if len(s6_v2_out) > 0.0
      s6_v2_out = s6_v2_out + NL
    end
    s6_v2_out = s6_v2_out + s6l2
  end
  s6_v2i = s6_v2i + 1.0
end
if s6_v1.ok == 0.0
  print("  SKIP (v1 failed): {s6_v1.error}")
  skip_count = skip_count + 1.0
elif s6_v2.ok == 0.0
  print("  SKIP (v2 failed): {s6_v2.error}")
  skip_count = skip_count + 1.0
elif s6_v1_out == s6_v2_out
  print("  PASS: STAGE 6 ACHIEVED — eval.flow meta-interprets eval.flow correctly")
  pass_count = pass_count + 1.0
else
  print("  FAIL: meta-interpreter output mismatch")
  print("    v1: {s6_v1_out}")
  print("    v2: {s6_v2_out}")
  fail_count = fail_count + 1.0
end

print("")
print("TEST [codegen] GPU shader generation from gpu_double.flow")
let cg_input = "stdlib/compiler/examples/gpu_double.flow"
let cg_cmd = "$env:FLOW_INPUT='" + cg_input + "'; " + octoflow + " run stdlib/compiler/codegen.flow --allow-read --allow-write"
let cg_r = exec("powershell", "-Command", cg_cmd)
if cg_r.ok == 1.0
  if contains(cg_r.output, "CODEGEN COMPLETE")
    print("  PASS: codegen.flow generated GLSL from gpu_double.flow")
    pass_count = pass_count + 1.0
  else
    print("  FAIL: CODEGEN COMPLETE not found in output")
    fail_count = fail_count + 1.0
  end
else
  print("  SKIP: exec error running codegen.flow")
  skip_count = skip_count + 1.0
end

// ---- VERDICT -------------------------------------------------------
print("")
print("=== BOOTSTRAP RESULTS (Phase 65) ===")
print("  passed:  {pass_count}")
print("  failed:  {fail_count}")
print("  skipped: {skip_count}")
print("")

if fail_count == 0.0
  if pass_count > 0.0
    print("BOOTSTRAP VERDICT: VERIFIED")
    print("  eval.flow matches Rust runtime for all {pass_count} test programs.")
    print("  parser.flow, preflight.flow, codegen.flow all self-test clean.")
    print("  Phase 65 milestone: STAGE 6 ACHIEVED — eval.flow meta-interprets eval.flow (3-layer execution)")
  else
    print("BOOTSTRAP VERDICT: NO TESTS RAN (all skipped)")
  end
else
  print("BOOTSTRAP VERDICT: PARTIAL ({pass_count} pass, {fail_count} fail)")
  print("  Fix eval.flow gaps for the failing programs above.")
end
