// stdlib/science/calculus.flow â€” Numerical calculus

fn derivative(arr, dx)
  // Numerical derivative using central differences
  // Returns array of same length (forward/backward at endpoints)
  let n = len(arr)
  let mut result = []
  if n < 2.0
    push(result, 0.0)
    return result
  end
  // Forward difference at first point
  push(result, (arr[1] - arr[0]) / dx)
  // Central differences for interior points
  let mut i = 1.0
  while i < n - 1.0
    let deriv = (arr[i + 1.0] - arr[i - 1.0]) / (2.0 * dx)
    push(result, deriv)
    i = i + 1.0
  end
  // Backward difference at last point
  push(result, (arr[n - 1.0] - arr[n - 2.0]) / dx)
  return result
end

fn integrate_trapz(arr, dx)
  // Trapezoidal integration over evenly-spaced data
  let n = len(arr)
  if n < 2.0
    return 0.0
  end
  let mut sum = 0.0
  let mut i = 0.0
  while i < n - 1.0
    sum = sum + (arr[i] + arr[i + 1.0]) * 0.5 * dx
    i = i + 1.0
  end
  return sum
end

fn cumulative_trapz(arr, dx)
  // Cumulative trapezoidal integration
  // Returns array of cumulative integrals (first element is 0)
  let n = len(arr)
  let mut result = []
  push(result, 0.0)
  if n < 2.0
    return result
  end
  let mut cumsum = 0.0
  let mut i = 0.0
  while i < n - 1.0
    cumsum = cumsum + (arr[i] + arr[i + 1.0]) * 0.5 * dx
    push(result, cumsum)
    i = i + 1.0
  end
  return result
end

fn second_derivative(arr, dx)
  // Second numerical derivative using central differences
  let n = len(arr)
  let mut result = []
  if n < 3.0
    let mut i = 0.0
    while i < n
      push(result, 0.0)
      i = i + 1.0
    end
    return result
  end
  // Forward at first point
  push(result, (arr[2] - 2.0 * arr[1] + arr[0]) / (dx * dx))
  // Central for interior
  let mut i = 1.0
  while i < n - 1.0
    let d2 = (arr[i + 1.0] - 2.0 * arr[i] + arr[i - 1.0]) / (dx * dx)
    push(result, d2)
    i = i + 1.0
  end
  // Backward at last point
  push(result, (arr[n - 1.0] - 2.0 * arr[n - 2.0] + arr[n - 3.0]) / (dx * dx))
  return result
end
