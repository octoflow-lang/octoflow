// stdlib/science/matrix.flow â€” Matrix operations (flat row-major arrays)

fn mat_norm(a, n)
  // Frobenius norm: sqrt(sum of squares of all elements)
  let total = n * n
  let mut sum = 0.0
  let mut i = 0.0
  while i < total
    sum = sum + a[i] * a[i]
    i = i + 1.0
  end
  return sqrt(sum)
end

fn mat_diag(a, n)
  // Extract diagonal elements from n x n matrix
  let mut result = []
  let mut i = 0.0
  while i < n
    push(result, a[i * n + i])
    i = i + 1.0
  end
  return result
end

fn mat_from_diag(d)
  // Create n x n diagonal matrix from vector d
  let n = len(d)
  let total = n * n
  let mut result = []
  let mut i = 0.0
  while i < total
    push(result, 0.0)
    i = i + 1.0
  end
  i = 0.0
  while i < n
    result[i * n + i] = d[i]
    i = i + 1.0
  end
  return result
end

fn mat_solve_triangular(a, b, n)
  // Solve Ax = b where A is lower triangular (forward substitution)
  // a: n x n lower triangular matrix (flat), b: n-vector
  // Returns x such that Ax = b
  let mut x = []
  let mut i = 0.0
  while i < n
    push(x, 0.0)
    i = i + 1.0
  end
  i = 0.0
  while i < n
    let mut sum = 0.0
    let mut j = 0.0
    while j < i
      sum = sum + a[i * n + j] * x[j]
      j = j + 1.0
    end
    let diag = a[i * n + i]
    if abs(diag) < 0.000001
      x[i] = 0.0
    else
      x[i] = (b[i] - sum) / diag
    end
    i = i + 1.0
  end
  return x
end

fn mat_solve_upper(a, b, n)
  // Solve Ax = b where A is upper triangular (back substitution)
  let mut x = []
  let mut i = 0.0
  while i < n
    push(x, 0.0)
    i = i + 1.0
  end
  i = n - 1.0
  while i >= 0.0
    let mut sum = 0.0
    let mut j = i + 1.0
    while j < n
      sum = sum + a[i * n + j] * x[j]
      j = j + 1.0
    end
    let diag = a[i * n + i]
    if abs(diag) < 0.000001
      x[i] = 0.0
    else
      x[i] = (b[i] - sum) / diag
    end
    i = i - 1.0
  end
  return x
end

fn mat_row_norm(a, n, row)
  // L2 norm of a single row in n x n matrix
  let mut sum = 0.0
  let mut j = 0.0
  while j < n
    let val = a[row * n + j]
    sum = sum + val * val
    j = j + 1.0
  end
  return sqrt(sum)
end

fn mat_col_norm(a, n, col)
  // L2 norm of a single column in n x n matrix
  let mut sum = 0.0
  let mut i = 0.0
  while i < n
    let val = a[i * n + col]
    sum = sum + val * val
    i = i + 1.0
  end
  return sqrt(sum)
end
