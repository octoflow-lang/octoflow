// stdlib/science/interpolate.flow â€” Interpolation methods
//
// Functions: linear_interp, linear_interp_array, bilinear_interp, nearest_interp

fn linear_interp(x_data, y_data, x)
  // Linear interpolation at point x
  let n = len(x_data)
  if x <= x_data[0]
    return y_data[0]
  end
  if x >= x_data[n - 1.0]
    return y_data[n - 1.0]
  end
  let mut i = 0.0
  while i < n - 1.0
    if x >= x_data[i] && x <= x_data[i + 1.0]
      let dx_span = x_data[i + 1.0] - x_data[i]
      if dx_span == 0.0
        return y_data[i]
      end
      let t = (x - x_data[i]) / dx_span
      return y_data[i] + t * (y_data[i + 1.0] - y_data[i])
    end
    i = i + 1.0
  end
  return y_data[n - 1.0]
end

fn linear_interp_array(x_data, y_data, x_new)
  let mut result = []
  for x in x_new
    push(result, linear_interp(x_data, y_data, x))
  end
  return result
end

fn bilinear_interp(x, y, x0, x1, y0, y1, q00, q10, q01, q11)
  // Bilinear interpolation at (x,y) in rectangle [x0,x1] x [y0,y1]
  // Guard against degenerate rectangles (division by zero)
  if x1 == x0
    let ty2 = 0.0
    if y1 != y0
      ty2 = (y - y0) / (y1 - y0)
    end
    return q00 * (1.0 - ty2) + q01 * ty2
  end
  if y1 == y0
    let tx2 = (x - x0) / (x1 - x0)
    return q00 * (1.0 - tx2) + q10 * tx2
  end
  let tx = (x - x0) / (x1 - x0)
  let ty = (y - y0) / (y1 - y0)
  let r1 = q00 * (1.0 - tx) + q10 * tx
  let r2 = q01 * (1.0 - tx) + q11 * tx
  return r1 * (1.0 - ty) + r2 * ty
end

fn nearest_interp(x_data, y_data, x)
  let n = len(x_data)
  let mut best_i = 0.0
  let mut best_dist = abs(x - x_data[0])
  let mut i = 1.0
  while i < n
    let d = abs(x - x_data[i])
    if d < best_dist
      best_dist = d
      best_i = i
    end
    i = i + 1.0
  end
  return y_data[best_i]
end
