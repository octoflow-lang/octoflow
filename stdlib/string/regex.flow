// stdlib/string/regex.flow — Pattern matching and text utilities
//
// Functions: glob_match, str_escape, word_count, re_match, re_find,
//            re_replace, re_test, re_split
//
// Built-in regex functions (implemented in Rust, always available):
//
//   regex_match(text, pattern)      → 1.0 if pattern matches text fully, else 0.0
//   is_match(text, pattern)         → alias for regex_match
//   regex_find(text, pattern)       → first match as string, or "" if none
//   regex_find_all(text, pattern)   → populates array "matches" with all matches
//   regex_replace(text, pat, repl)  → text with first match of pat replaced by repl
//   capture_groups(text, pattern)   → populates array "captures" with group matches
//
// Patterns use standard regex syntax: . * + ? [] () | ^ $ \d \w \s etc.
// Examples:
//   regex_match("hello123", "[a-z]+\d+")     → 1.0
//   regex_find("abc 42 def", "\d+")           → "42"
//   regex_replace("hello world", "world", "OctoFlow") → "hello OctoFlow"
//

fn glob_match(pattern, text)
  // Simple glob matching: * matches any sequence, ? matches one char
  let plen = len(pattern)
  let tlen = len(text)
  let mut pi = 0.0
  let mut ti = 0.0
  let mut star_pi = -1.0
  let mut star_ti = -1.0
  while ti < tlen
    if pi < plen && char_at(pattern, pi) == "?"
      pi = pi + 1.0
      ti = ti + 1.0
    elif pi < plen && char_at(pattern, pi) == "*"
      star_pi = pi
      star_ti = ti
      pi = pi + 1.0
    elif pi < plen && char_at(pattern, pi) == char_at(text, ti)
      pi = pi + 1.0
      ti = ti + 1.0
    elif star_pi >= 0.0
      pi = star_pi + 1.0
      star_ti = star_ti + 1.0
      ti = star_ti
    else
      return 0.0
    end
  end
  while pi < plen && char_at(pattern, pi) == "*"
    pi = pi + 1.0
  end
  if pi == plen
    return 1.0
  end
  return 0.0
end

fn str_escape(s)
  // Escape glob/regex special chars: * ? [ ] with backslash
  let n = len(s)
  let mut result = ""
  let mut i = 0.0
  while i < n
    let c = char_at(s, i)
    if c == "*" || c == "?" || c == "[" || c == "]"
      result = result + "\" + c
    else
      result = result + c
    end
    i = i + 1.0
  end
  return result
end

fn word_count(s)
  // Count whitespace-separated words in string
  let trimmed = trim(s)
  if len(trimmed) == 0.0
    return 0.0
  end
  let mut count = 1.0
  let n = len(trimmed)
  let mut in_space = 0.0
  let mut i = 0.0
  while i < n
    let c = char_at(trimmed, i)
    let is_ws = c == " " || ord(c) == 9.0 || ord(c) == 10.0 || ord(c) == 13.0
    if is_ws == 1.0
      if in_space == 0.0
        count = count + 1.0
        in_space = 1.0
      end
    else
      in_space = 0.0
    end
    i = i + 1.0
  end
  return count
end

// ── Regex wrapper functions ──
// These call the built-in regex builtins and provide a convenient API
// for code that does `use "string/regex"`.

fn re_match(text, pattern)
  // Returns 1.0 if pattern matches the full text, 0.0 otherwise.
  return regex_match(text, pattern)
end

fn re_find(text, pattern)
  // Returns the first substring matching pattern, or "" if none.
  return regex_find(text, pattern)
end

fn re_replace(text, pattern, replacement)
  // Replaces first occurrence of pattern in text with replacement.
  return regex_replace(text, pattern, replacement)
end

fn re_test(text, pattern)
  // Tests if pattern matches anywhere in text (partial match).
  let found = regex_find(text, pattern)
  if len(found) > 0.0
    return 1.0
  end
  return 0.0
end

fn re_split(text, pattern)
  // Splits text on pattern matches. Returns word_count-like result.
  // Uses regex_replace to convert delimiters, then splits.
  let normalized = regex_replace(text, pattern, "\n")
  return split(normalized, "\n")
end
