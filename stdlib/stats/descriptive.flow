// stdlib/stats/descriptive.flow â€” Descriptive statistics
//
// Functions: skewness, kurtosis, iqr, percentile, weighted_mean,
//            trimmed_mean, describe, mode, geometric_mean, harmonic_mean,
//            coeff_of_variation, zscore
//
// All functions guard against empty arrays and division by zero.

fn skewness(arr)
  let n = len(arr)
  if n < 3.0
    return 0.0
  end
  let m = mean(arr)
  let sd = stddev(arr)
  if sd == 0.0
    return 0.0
  end
  let mut s = 0.0
  for x in arr
    let d = (x - m) / sd
    s = s + d * d * d
  end
  return s * n / ((n - 1.0) * (n - 2.0))
end

fn kurtosis(arr)
  let n = len(arr)
  if n < 4.0
    return 0.0
  end
  let m = mean(arr)
  let sd = stddev(arr)
  if sd == 0.0
    return 0.0
  end
  let mut s = 0.0
  for x in arr
    let d = (x - m) / sd
    s = s + d * d * d * d
  end
  return s / n - 3.0
end

fn iqr(arr)
  if len(arr) < 4.0
    return 0.0
  end
  let sorted = sort_array(arr)
  let n = len(sorted)
  let q1_idx = floor(n * 0.25)
  let q3_idx = floor(n * 0.75)
  return sorted[q3_idx] - sorted[q1_idx]
end

fn percentile(arr, p)
  if len(arr) == 0.0
    return 0.0
  end
  let sorted = sort_array(arr)
  let n = len(sorted)
  let mut idx = floor(n * p / 100.0)
  if idx >= n
    idx = n - 1.0
  end
  return sorted[idx]
end

fn weighted_mean(arr, weights)
  let n = len(arr)
  let mut sum_wv = 0.0
  let mut sum_w = 0.0
  let mut i = 0.0
  while i < n
    sum_wv = sum_wv + arr[i] * weights[i]
    sum_w = sum_w + weights[i]
    i = i + 1.0
  end
  if sum_w == 0.0
    return 0.0
  end
  return sum_wv / sum_w
end

fn trimmed_mean(arr, pct)
  let sorted = sort_array(arr)
  let n = len(sorted)
  let trim = floor(n * pct / 100.0)
  let mut sum = 0.0
  let mut count = 0.0
  let mut i = trim
  let upper = n - trim
  while i < upper
    sum = sum + sorted[i]
    count = count + 1.0
    i = i + 1.0
  end
  if count == 0.0
    return 0.0
  end
  return sum / count
end

fn describe(arr)
  let mut d = map()
  let n = len(arr)
  if n == 0.0
    map_set(d, "count", "0")
    return d
  end
  map_set(d, "count", str(n))
  map_set(d, "mean", str(mean(arr)))
  map_set(d, "std", str(stddev(arr)))
  map_set(d, "var", str(variance(arr)))
  map_set(d, "median", str(median(arr)))
  let sorted = sort_array(arr)
  map_set(d, "min", str(sorted[0]))
  map_set(d, "max", str(sorted[n - 1.0]))
  let q1 = sorted[floor(n * 0.25)]
  let q3 = sorted[floor(n * 0.75)]
  map_set(d, "q1", str(q1))
  map_set(d, "q3", str(q3))
  map_set(d, "iqr", str(q3 - q1))
  return d
end

fn mode(arr)
  // Returns most frequent value
  if len(arr) == 0.0
    return 0.0
  end
  let mut counts = map()
  let mut best = arr[0]
  let mut best_count = 0.0
  for x in arr
    let key = str(x)
    let mut c = 1.0
    if map_has(counts, key)
      c = float(map_get(counts, key)) + 1.0
    end
    map_set(counts, key, str(c))
    if c > best_count
      best_count = c
      best = x
    end
  end
  return best
end

fn geometric_mean(arr)
  let n = len(arr)
  if n == 0.0
    return 0.0
  end
  let mut log_sum = 0.0
  for x in arr
    if x <= 0.0
      return 0.0
    end
    log_sum = log_sum + log(x)
  end
  return exp(log_sum / n)
end

fn harmonic_mean(arr)
  let n = len(arr)
  if n == 0.0
    return 0.0
  end
  let mut inv_sum = 0.0
  for x in arr
    if x == 0.0
      return 0.0
    end
    inv_sum = inv_sum + 1.0 / x
  end
  return n / inv_sum
end

fn coeff_of_variation(arr)
  if len(arr) == 0.0
    return 0.0
  end
  let m = mean(arr)
  if m == 0.0
    return 0.0
  end
  return stddev(arr) / abs(m)
end

fn zscore(arr)
  if len(arr) == 0.0
    return []
  end
  let m = mean(arr)
  let sd = stddev(arr)
  let n = len(arr)
  let mut result = []
  for x in arr
    if sd == 0.0
      push(result, 0.0)
    else
      push(result, (x - m) / sd)
    end
  end
  return result
end
