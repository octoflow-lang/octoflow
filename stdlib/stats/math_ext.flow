// stdlib/stats/math_ext.flow â€” Extended math functions
//
// Functions: factorial, permutations, gcd, lcm, is_prime, fibonacci,
//            power_mod, sigmoid, tanh_fn, relu, softplus, logistic,
//            linspace, arange, dot_product, magnitude, normalize_vec,
//            cross_product_3d

let PI = 3.14159265358979
let E = 2.71828182845905
let TAU = 6.28318530717959
let GOLDEN_RATIO = 1.61803398874989
let SQRT2 = 1.41421356237310

fn factorial(n)
  let mut result = 1.0
  let mut i = 2.0
  while i <= n
    result = result * i
    i = i + 1.0
  end
  return result
end

fn permutations(n, k)
  let mut result = 1.0
  let mut i = 0.0
  while i < k
    result = result * (n - i)
    i = i + 1.0
  end
  return result
end

fn gcd(a, b)
  let mut x = abs(floor(a))
  let mut y = abs(floor(b))
  while y > 0.0
    let t = y
    y = x - floor(x / y) * y
    x = t
  end
  return x
end

fn lcm(a, b)
  if a == 0.0 || b == 0.0
    return 0.0
  end
  return abs(a * b) / gcd(a, b)
end

fn is_prime(n)
  if n < 2.0
    return 0.0
  end
  if n < 4.0
    return 1.0
  end
  let r2 = n - floor(n / 2.0) * 2.0
  if r2 == 0.0
    return 0.0
  end
  let r3 = n - floor(n / 3.0) * 3.0
  if r3 == 0.0
    return 0.0
  end
  let mut i = 5.0
  while i * i <= n
    let ri = n - floor(n / i) * i
    let ri2 = n - floor(n / (i + 2.0)) * (i + 2.0)
    if ri == 0.0 || ri2 == 0.0
      return 0.0
    end
    i = i + 6.0
  end
  return 1.0
end

fn fibonacci(n)
  if n <= 0.0
    return 0.0
  end
  if n == 1.0
    return 1.0
  end
  let mut a = 0.0
  let mut b = 1.0
  let mut i = 2.0
  while i <= n
    let c = a + b
    a = b
    b = c
    i = i + 1.0
  end
  return b
end

fn power_mod(base, exp_val, modulus)
  // Modular exponentiation: base^exp mod modulus
  let mut result = 1.0
  let mut b = base - floor(base / modulus) * modulus
  let mut e = exp_val
  while e > 0.0
    let r2 = e - floor(e / 2.0) * 2.0
    if r2 == 1.0
      result = result * b
      result = result - floor(result / modulus) * modulus
    end
    e = floor(e / 2.0)
    b = b * b
    b = b - floor(b / modulus) * modulus
  end
  return result
end

fn sigmoid(x)
  return 1.0 / (1.0 + exp(-1.0 * x))
end

fn tanh_fn(x)
  if x > 20.0
    return 1.0
  end
  if x < -20.0
    return -1.0
  end
  let e2x = exp(2.0 * x)
  return (e2x - 1.0) / (e2x + 1.0)
end

fn relu(x)
  if x > 0.0
    return x
  end
  return 0.0
end

fn softplus(x)
  if x > 20.0
    return x
  end
  return log(1.0 + exp(x))
end

fn logistic(x, L, k, x0)
  return L / (1.0 + exp(-1.0 * k * (x - x0)))
end

fn linspace(start, stop, n)
  if n <= 0.0
    return []
  end
  if n == 1.0
    return [start]
  end
  let mut result = []
  let step = (stop - start) / (n - 1.0)
  let mut i = 0.0
  while i < n
    push(result, start + i * step)
    i = i + 1.0
  end
  return result
end

fn arange(start, stop, step)
  let mut result = []
  let mut v = start
  while v < stop
    push(result, v)
    v = v + step
  end
  return result
end

fn dot_product(a, b)
  let n = len(a)
  if len(b) < n
    n = len(b)
  end
  let mut sum = 0.0
  let mut i = 0.0
  while i < n
    sum = sum + a[i] * b[i]
    i = i + 1.0
  end
  return sum
end

fn magnitude(arr)
  let mut sum = 0.0
  for x in arr
    sum = sum + x * x
  end
  return sqrt(sum)
end

fn normalize_vec(arr)
  let mag = magnitude(arr)
  if mag == 0.0
    return arr
  end
  let n = len(arr)
  let mut result = []
  for x in arr
    push(result, x / mag)
  end
  return result
end

fn cross_product_3d(a, b)
  if len(a) < 3.0 || len(b) < 3.0
    return [0.0, 0.0, 0.0]
  end
  let mut result = []
  push(result, a[1] * b[2] - a[2] * b[1])
  push(result, a[2] * b[0] - a[0] * b[2])
  push(result, a[0] * b[1] - a[1] * b[0])
  return result
end
