// stdlib/stats/distribution.flow â€” Probability distributions
//
// Functions: normal_pdf, normal_cdf, normal_inv, uniform_random,
//            normal_random, exponential_random, poisson_pmf, binomial_pmf,
//            combinations, random_sample
//
// All functions guard against division by zero and invalid parameters.

fn normal_pdf(x, mu, sigma)
  if sigma == 0.0
    return 0.0
  end
  let PI = 3.14159265358979
  let z = (x - mu) / sigma
  return exp(-0.5 * z * z) / (sigma * sqrt(2.0 * PI))
end

fn normal_cdf(x, mu, sigma)
  if sigma == 0.0
    if x >= mu
      return 1.0
    end
    return 0.0
  end
  // Approximation using error function (Abramowitz & Stegun)
  let z = (x - mu) / (sigma * sqrt(2.0))
  let t = 1.0 / (1.0 + 0.3275911 * abs(z))
  let a1 = 0.254829592
  let a2 = -0.284496736
  let a3 = 1.421413741
  let a4 = -1.453152027
  let a5 = 1.061405429
  let mut erf = 1.0 - (a1 * t + a2 * t * t + a3 * t * t * t + a4 * t * t * t * t + a5 * t * t * t * t * t) * exp(-1.0 * z * z)
  if z < 0.0
    erf = -1.0 * erf
  end
  return 0.5 * (1.0 + erf)
end

fn normal_inv(p, mu, sigma)
  if sigma == 0.0
    return mu
  end
  // Approximation of inverse normal (Beasley-Springer-Moro)
  let a0 = -8.78103344
  let a1 = 23.08336743
  let a2 = -21.06224101
  let a3 = 3.13082909
  let b0 = -0.00778489
  let b1 = -0.32239645
  let b2 = -2.40088677
  let b3 = -7.06190291
  let t = p - 0.5
  if abs(t) < 0.42
    let r = t * t
    let z = t * (((a3 * r + a2) * r + a1) * r + a0) / ((((b3 * r + b2) * r + b1) * r + b0) * r + 1.0)
    return mu + sigma * z
  end
  let mut r = p
  if t > 0.0
    r = 1.0 - p
  end
  r = log(-1.0 * log(r))
  let mut z = 0.27061 + r * (0.99229 + r * 0.04481)
  if t < 0.0
    z = -1.0 * z
  end
  return mu + sigma * z
end

fn uniform_random(lo, hi)
  return lo + random() * (hi - lo)
end

fn normal_random(mu, sigma)
  // Box-Muller transform
  let u1 = random()
  let u2 = random()
  let PI = 3.14159265358979
  let z = sqrt(-2.0 * log(u1)) * cos(2.0 * PI * u2)
  return mu + sigma * z
end

fn exponential_random(lambda)
  if lambda <= 0.0
    return 0.0
  end
  return -1.0 * log(random()) / lambda
end

fn poisson_pmf(k, lambda)
  if lambda <= 0.0
    if k == 0.0
      return 1.0
    end
    return 0.0
  end
  // P(X=k) = lambda^k * e^(-lambda) / k!
  let mut result = exp(-1.0 * lambda)
  let mut i = 1.0
  while i <= k
    result = result * lambda / i
    i = i + 1.0
  end
  return result
end

fn binomial_pmf(k, n, p)
  // P(X=k) = C(n,k) * p^k * (1-p)^(n-k)
  let c = combinations(n, k)
  return c * pow(p, k) * pow(1.0 - p, n - k)
end

fn combinations(n, k)
  if k < 0.0 || k > n
    return 0.0
  end
  if k == 0.0 || k == n
    return 1.0
  end
  let mut result = 1.0
  let mut i = 0.0
  let mut kk = k
  if kk > n - kk
    kk = n - kk
  end
  while i < kk
    result = result * (n - i) / (i + 1.0)
    i = i + 1.0
  end
  return result
end

fn random_sample(arr, n)
  if len(arr) == 0.0 || n <= 0.0
    return []
  end
  // Random sample without replacement (Fisher-Yates partial shuffle)
  let total = len(arr)
  let mut indices = []
  let mut i = 0.0
  while i < total
    push(indices, i)
    i = i + 1.0
  end
  let mut result = []
  i = 0.0
  while i < n && i < total
    let j = floor(random() * (total - i)) + i
    // Swap indices[i] and indices[j]
    let tmp = indices[i]
    indices[i] = indices[j]
    indices[j] = tmp
    push(result, arr[indices[i]])
    i = i + 1.0
  end
  return result
end
