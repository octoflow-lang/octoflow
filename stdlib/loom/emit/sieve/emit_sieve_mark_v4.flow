// emit_sieve_mark_v4.flow — Unified Mark Kernel with Carry-Forward Offsets
//
// Each thread handles ONE prime. Reads starting offset from carry-forward area
// in B0, marks all composites of that prime in the current segment, writes
// updated offset back for the next segment.
//
// This replaces both mark_v3_small and mark_v3_large with a single kernel.
// The carry-forward eliminates per-segment ceil_to_odd_multiple computation.
//
// Thread gid:
//   prime_idx = gid + prime_start
//   if prime_idx >= prime_end: exit
//   prime = ftou(B2[prime_idx])            // from globals
//   offset = B0[offset_base + prime_idx]   // carry-forward from last segment
//   step = 2 * prime
//
//   seg_start = seg_idx * seg_range + 1
//   seg_end   = seg_start + (num_words * 32 - 1) * 2
//
//   // Skip forward if offset < seg_start (shouldn't happen with correct init)
//   // Mark composites in [seg_start, seg_end]
//   while offset <= seg_end:
//     bit_idx = (offset - seg_start) / 2
//     word_idx = bit_idx / 32
//     bit_pos = bit_idx % 32
//     atomic_and(B0[word_idx], ~(1 << bit_pos))
//     offset += step
//
//   B0[offset_base + prime_idx] = offset   // save for next segment
//
// Push constants:
//   pc[0] = seg_idx       (segment index)
//   pc[1] = num_words     (bitmap words per segment)
//   pc[2] = prime_start   (first prime index for this dispatch)
//   pc[3] = prime_end     (one past last prime index)
//   pc[4] = offset_base   (start of carry-forward area in B0)
//
// Binding layout (5-SSBO):
//   B0 (uint): Read/write bitmap [0..num_words] + read/write offsets [offset_base..]
//   B2 (float): Read primes from globals
//
// Dispatch: wg = ceil((prime_end - prime_start) / 256)
//
// Run: octoflow run stdlib/loom/emit_sieve_mark_v4.flow --allow-read --allow-write

use "../compiler/ir"

fn emit_sieve_mark_v4(out_path)
  ir_new()
  ir_input_count = 3.0
  push(ir_uint_bindings, 0.0)

  let entry      = ir_block("entry")
  let pre_loop   = ir_block("pre_loop")
  let loop_header = ir_block("loop_header")
  let loop_body  = ir_block("loop_body")
  let loop_cont  = ir_block("loop_cont")
  let loop_merge = ir_block("loop_merge")
  let exit_block = ir_block("exit")

  // ── Entry: gid, push constants, bounds check ──────────────
  let gid      = ir_load_gid(entry)
  let pc_seg   = ir_push_const(entry, 0.0)   // seg_idx
  let pc_words = ir_push_const(entry, 1.0)   // num_words
  let pc_pst   = ir_push_const(entry, 2.0)   // prime_start
  let pc_pen   = ir_push_const(entry, 3.0)   // prime_end
  let pc_obase = ir_push_const(entry, 4.0)   // offset_base

  // Compute prime_idx = gid + prime_start
  let pstart_u = ir_ftou(entry, pc_pst)
  let pend_u   = ir_ftou(entry, pc_pen)
  let prime_idx = ir_iadd(entry, gid, pstart_u)

  // Bounds check: prime_idx >= prime_end → exit
  let oob      = ir_ugte(entry, prime_idx, pend_u)
  let _sm      = ir_selection_merge(entry, exit_block)
  let _br      = ir_term_cond_branch(entry, oob, exit_block, pre_loop)

  // ── pre_loop: load prime, load carry-forward offset, compute segment bounds ──
  let seg_u    = ir_ftou(pre_loop, pc_seg)
  let obase_u  = ir_ftou(pre_loop, pc_obase)

  let c0       = ir_const_u(pre_loop, 0.0)
  let c1       = ir_const_u(pre_loop, 1.0)
  let c2       = ir_const_u(pre_loop, 2.0)
  let c32      = ir_const_u(pre_loop, 32.0)
  let c64      = ir_const_u(pre_loop, 64.0)

  // SEG_RANGE = num_words * 64
  let words_u   = ir_ftou(pre_loop, pc_words)
  let seg_range = ir_imul(pre_loop, words_u, c64)

  // seg_start = seg_idx * SEG_RANGE + 1
  let seg_base  = ir_imul(pre_loop, seg_u, seg_range)
  let seg_start = ir_iadd(pre_loop, seg_base, c1)

  // seg_end = seg_start + (num_words*32 - 1)*2 = last odd candidate value
  let words32   = ir_imul(pre_loop, words_u, c32)
  let w32m1     = ir_isub(pre_loop, words32, c1)
  let seg_end_off = ir_imul(pre_loop, w32m1, c2)
  let seg_end_val = ir_iadd(pre_loop, seg_start, seg_end_off)

  // Load prime from globals (B2)
  let prime_f   = ir_load_input_at(pre_loop, 2.0, prime_idx)
  let prime_u   = ir_ftou(pre_loop, prime_f)

  // step = 2 * prime (distance between consecutive odd multiples)
  let step      = ir_imul(pre_loop, prime_u, c2)

  // Load carry-forward offset from B0[offset_base + prime_idx]
  let off_idx   = ir_iadd(pre_loop, obase_u, prime_idx)
  let offset    = ir_buf_load_u(pre_loop, 0.0, off_idx)

  let _bpl      = ir_term_branch(pre_loop, loop_header)

  // ── Loop: iterate over odd multiples of prime in segment ──
  let phi_m     = ir_phi(loop_header, 2.0)    // uint: current multiple
  let _pm0      = ir_phi_add(phi_m, offset, pre_loop)

  // Check: mult > seg_end_val → done
  let m_past    = ir_ugte(loop_header, phi_m, ir_iadd(loop_header, seg_end_val, c1))
  let _lm       = ir_loop_merge(loop_header, loop_merge, loop_cont)
  let _bc       = ir_term_cond_branch(loop_header, m_past, loop_merge, loop_body)

  // ── loop_body: compute word index and bit position, atomic AND ──
  // bit_idx = (mult - seg_start) / 2
  let m_offset  = ir_isub(loop_body, phi_m, seg_start)
  let half_off  = ir_udiv(loop_body, m_offset, c2)

  // word_idx = half_off / 32
  let word_idx  = ir_udiv(loop_body, half_off, c32)

  // bit_pos = half_off % 32
  let bit_pos   = ir_umod(loop_body, half_off, c32)

  // mask = ~(1 << bit_pos)
  let one_shl   = ir_shl(loop_body, c1, bit_pos)
  let mask      = ir_not(loop_body, one_shl)

  // Atomic AND: R0[word_idx] &= mask (clears the bit)
  let _atomic   = ir_buf_atomic_and(loop_body, 0.0, word_idx, mask)

  let _br_lb    = ir_term_branch(loop_body, loop_cont)

  // ── loop_cont: advance mult by step (2 * prime) ──
  let next_m    = ir_iadd(loop_cont, phi_m, step)
  let _br_lc    = ir_term_branch(loop_cont, loop_header)
  let _pm1      = ir_phi_add(phi_m, next_m, loop_cont)

  // ── loop_merge: save carry-forward offset for next segment ──
  // B0[offset_base + prime_idx] = phi_m (the next multiple to try)
  let _save     = ir_buf_store_u(loop_merge, 0.0, off_idx, phi_m)
  let _br_lm    = ir_term_branch(loop_merge, exit_block)

  // ── exit ──
  let _ret      = ir_term_return(exit_block)

  ir_emit_spirv(out_path)
  return 0.0
end

let out = "stdlib/loom/kernels/sieve/sieve_mark_v4.spv"
let _r = emit_sieve_mark_v4(out)
print("Emitted: {out}")
