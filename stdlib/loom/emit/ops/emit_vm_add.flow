// emit_vm_add.flow — VM Register Elementwise Add Kernel Emitter
//
// Adds two register slices element-by-element and writes the result to a
// third slice (all within the registers SSBO, binding 0).
// Supports in-place if dst_off == a_off or dst_off == b_off.
//
// Push constants:
//   pc[0] = a_off   (flat float index into registers SSBO, source A)
//   pc[1] = b_off   (flat float index into registers SSBO, source B)
//   pc[2] = dst_off (flat float index into registers SSBO, destination)
//   pc[3] = count   (number of elements — bounds guard)
//
// Each thread: if gid < count: registers[dst+gid] = registers[a+gid] + registers[b+gid]
//
// Binding layout (VM 4-SSBO):
//   Binding 0: registers (read/write)
//   Binding 1: metrics   (unused)
//   Binding 2: globals   (unused)
//   Binding 3: control   (unused)
//
// Dispatch: workgroups = ceil(count / 256)
//
// Run: octoflow run stdlib/loom/emit_vm_add.flow --allow-read --allow-write

use "../compiler/ir"

fn emit_vm_add(out_path)
  ir_new()
  ir_input_count = 3.0

  let entry      = ir_block("entry")
  let body       = ir_block("body")
  let exit_block = ir_block("exit")

  // ── Entry: load gid, push constants, bounds check ───────────────────
  let gid       = ir_load_gid(entry)
  let a_off_f   = ir_push_const(entry, 0.0)
  let b_off_f   = ir_push_const(entry, 1.0)
  let dst_off_f = ir_push_const(entry, 2.0)
  let cnt_f     = ir_push_const(entry, 3.0)
  let cnt_u     = ir_ftou(entry, cnt_f)
  // Skip thread if gid >= count
  let oob       = ir_ugte(entry, gid, cnt_u)
  let _sm       = ir_selection_merge(entry, exit_block)
  let _br       = ir_term_cond_branch(entry, oob, exit_block, body)

  // ── Body: load a, load b, add, store ────────────────────────────────
  let a_off_u   = ir_ftou(body, a_off_f)
  let b_off_u   = ir_ftou(body, b_off_f)
  let dst_off_u = ir_ftou(body, dst_off_f)
  let a_idx     = ir_iadd(body, a_off_u, gid)
  let b_idx     = ir_iadd(body, b_off_u, gid)
  let dst_idx   = ir_iadd(body, dst_off_u, gid)
  let a_val     = ir_load_input_at(body, 0.0, a_idx)
  let b_val     = ir_load_input_at(body, 0.0, b_idx)
  let result    = ir_fadd(body, a_val, b_val)
  let _s        = ir_buf_store_f(body, 0.0, dst_idx, result)
  let _br2      = ir_term_branch(body, exit_block)

  // ── Exit ─────────────────────────────────────────────────────────────
  let _ret = ir_term_return(exit_block)

  ir_emit_spirv(out_path)
  return 0.0
end

let out = "stdlib/loom/kernels/ops/vm_add.spv"
let _r = emit_vm_add(out)
print("Emitted: {out}")
