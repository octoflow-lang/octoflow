// Composite GPU Functions
// Batch 7: High-level wrappers combining primitives

// Statistical summary
fn gpu_describe(arr)
    let mut result = map()
    map_set(result, "mean", gpu_mean(arr))
    map_set(result, "std", gpu_std(arr))
    map_set(result, "min", gpu_min(arr))
    map_set(result, "q25", gpu_percentile(arr, 25.0))
    map_set(result, "median", gpu_median(arr))
    map_set(result, "q75", gpu_percentile(arr, 75.0))
    map_set(result, "max", gpu_max(arr))
    map_set(result, "count", len(arr))
    return result
end

// Outlier detection using z-score
fn gpu_outlier_detection(arr, threshold_std)
    let zscores = gpu_zscore(arr)
    let n = len(zscores)

    let mut outliers = []
    let mut i = 0.0
    while i < n
        if abs(zscores[i]) > threshold_std
            push(outliers, 1.0)
        else
            push(outliers, 0.0)
        end
        i = i + 1.0
    end

    return outliers
end

// Standardize: (x - mean) / std
fn gpu_standardize(arr)
    return gpu_zscore(arr)
end

// Min-max scaling: (x - min) / (max - min)
fn gpu_minmax_scale(arr)
    let min_val = gpu_min(arr)
    let max_val = gpu_max(arr)

    let range = max_val - min_val
    if range == 0.0
        let n = len(arr)
        let mut zeros = []
        let mut i = 0.0
        while i < n
            push(zeros, 0.0)
            i = i + 1.0
        end
        return zeros
    end

    let n = len(arr)
    let mut result = []
    let mut i = 0.0
    while i < n
        push(result, (arr[i] - min_val) / range)
        i = i + 1.0
    end

    return result
end

// Rank: ordinal position in sorted order
fn gpu_rank(arr)
    // Simple rank: sort and find positions
    // For now, CPU implementation
    let n = len(arr)
    let mut ranks = []

    let mut i = 0.0
    while i < n
        let mut rank = 1.0
        let mut j = 0.0
        while j < n
            if arr[j] < arr[i]
                rank = rank + 1.0
            end
            j = j + 1.0
        end
        push(ranks, rank)
        i = i + 1.0
    end

    return ranks
end

// Argsort: indices that would sort array
fn gpu_argsort(arr)
    let n = len(arr)
    let mut indices = []

    // Create index array
    let mut i = 0.0
    while i < n
        push(indices, i)
        i = i + 1.0
    end

    // Bubble sort on indices by array values
    let mut i = 0.0
    while i < n
        let mut j = 0.0
        while j < n - 1.0
            let idx1 = indices[j]
            let idx2 = indices[j + 1.0]

            if arr[idx1] > arr[idx2]
                let temp = indices[j]
                indices[j] = indices[j + 1.0]
                indices[j + 1.0] = temp
            end

            j = j + 1.0
        end
        i = i + 1.0
    end

    return indices
end

// Binary search in sorted array
fn gpu_searchsorted(sorted_arr, values)
    let n = len(sorted_arr)
    let m = len(values)

    let mut positions = []
    let mut i = 0.0
    while i < m
        let val = values[i]

        // Binary search
        let mut left = 0.0
        let mut right = n

        while left < right
            let mid = floor((left + right) / 2.0)
            if sorted_arr[mid] < val
                left = mid + 1.0
            else
                right = mid
            end
        end

        push(positions, left)
        i = i + 1.0
    end

    return positions
end

// Linear interpolation
fn gpu_interpolate_linear(x_old, y_old, x_new)
    let n_old = len(x_old)
    let n_new = len(x_new)

    let mut y_new = []
    let mut i = 0.0
    while i < n_new
        let x = x_new[i]

        // Find surrounding points
        let mut j = 0.0
        let mut found = 0.0
        while j < n_old - 1.0
            if x >= x_old[j]
              if x <= x_old[j + 1.0]
                // Interpolate
                let x0 = x_old[j]
                let x1 = x_old[j + 1.0]
                let y0 = y_old[j]
                let y1 = y_old[j + 1.0]

                let t = (x - x0) / (x1 - x0)
                let y = y0 + t * (y1 - y0)

                push(y_new, y)
                found = 1.0
                j = n_old  // Break
              end
            end
            j = j + 1.0
        end

        if found == 0.0
            // Extrapolate
            if x < x_old[0.0]
                push(y_new, y_old[0.0])
            else
                push(y_new, y_old[n_old - 1.0])
            end
        end

        i = i + 1.0
    end

    return y_new
end

// Resample array to new length
fn gpu_resample(arr, new_length)
    let n = len(arr)
    if new_length == n
        return arr
    end

    // Create index arrays
    let mut old_indices = []
    let mut i = 0.0
    while i < n
        push(old_indices, i)
        i = i + 1.0
    end

    let mut new_indices = []
    let mut i = 0.0
    while i < new_length
        push(new_indices, i * (n - 1.0) / (new_length - 1.0))
        i = i + 1.0
    end

    // Interpolate
    return gpu_interpolate_linear(old_indices, arr, new_indices)
end

// Percentage change between elements
fn gpu_pct_change(arr)
    let n = len(arr)
    if n < 2.0
        return []
    end

    let mut result = []
    let mut i = 1.0
    while i < n
        if arr[i - 1.0] != 0.0
            push(result, (arr[i] - arr[i - 1.0]) / arr[i - 1.0] * 100.0)
        else
            push(result, 0.0)
        end
        i = i + 1.0
    end

    return result
end

// Covariance matrix
fn gpu_covariance_matrix(data, n_features, n_samples)
    // data is flattened: [f0_s0, f0_s1, ..., f1_s0, ...]
    // Returns n_features x n_features covariance matrix

    let mut cov_matrix = []

    let mut i = 0.0
    while i < n_features
        let mut j = 0.0
        while j < n_features
            // Extract features i and j
            let mut feat_i = []
            let mut feat_j = []

            let mut k = 0.0
            while k < n_samples
                let idx_i = i * n_samples + k
                let idx_j = j * n_samples + k

                push(feat_i, data[idx_i])
                push(feat_j, data[idx_j])

                k = k + 1.0
            end

            // Compute covariance
            let mean_i = gpu_mean(feat_i)
            let mean_j = gpu_mean(feat_j)

            let mut cov = 0.0
            let mut k = 0.0
            while k < n_samples
                cov = cov + (feat_i[k] - mean_i) * (feat_j[k] - mean_j)
                k = k + 1.0
            end

            cov = cov / (n_samples - 1.0)
            push(cov_matrix, cov)

            j = j + 1.0
        end
        i = i + 1.0
    end

    return cov_matrix
end

// Clip array to range
fn gpu_clip(arr, min_val, max_val)
    return gpu_clamp(arr, min_val, max_val)
end

// Count non-zero elements
fn gpu_count_nonzero(arr)
    let n = len(arr)
    let mut count = 0.0

    let mut i = 0.0
    while i < n
        if arr[i] != 0.0
            count = count + 1.0
        end
        i = i + 1.0
    end

    return count
end

// All elements satisfy condition
fn gpu_all(arr, threshold, op)
    let n = len(arr)

    let mut i = 0.0
    while i < n
        let mut passes = 0.0

        if op == "gt"
            passes = arr[i] > threshold
        elif op == "lt"
            passes = arr[i] < threshold
        elif op == "eq"
            passes = arr[i] == threshold
        elif op == "gte"
            passes = arr[i] >= threshold
        elif op == "lte"
            passes = arr[i] <= threshold
        end

        if passes == 0.0
            return 0.0
        end

        i = i + 1.0
    end

    return 1.0
end

// Any element satisfies condition
fn gpu_any(arr, threshold, op)
    let n = len(arr)

    let mut i = 0.0
    while i < n
        let mut passes = 0.0

        if op == "gt"
            passes = arr[i] > threshold
        elif op == "lt"
            passes = arr[i] < threshold
        elif op == "eq"
            passes = arr[i] == threshold
        elif op == "gte"
            passes = arr[i] >= threshold
        elif op == "lte"
            passes = arr[i] <= threshold
        end

        if passes == 1.0
            return 1.0
        end

        i = i + 1.0
    end

    return 0.0
end

// Cumulative product
fn gpu_cumprod(arr)
    let n = len(arr)
    if n == 0.0
        return []
    end

    let mut result = []
    let mut prod = 1.0

    let mut i = 0.0
    while i < n
        prod = prod * arr[i]
        push(result, prod)
        i = i + 1.0
    end

    return result
end

// Cumulative max
fn gpu_cummax(arr)
    let n = len(arr)
    if n == 0.0
        return []
    end

    let mut result = []
    let mut max_so_far = arr[0.0]

    let mut i = 0.0
    while i < n
        if arr[i] > max_so_far
            max_so_far = arr[i]
        end
        push(result, max_so_far)
        i = i + 1.0
    end

    return result
end

// Cumulative min
fn gpu_cummin(arr)
    let n = len(arr)
    if n == 0.0
        return []
    end

    let mut result = []
    let mut min_so_far = arr[0.0]

    let mut i = 0.0
    while i < n
        if arr[i] < min_so_far
            min_so_far = arr[i]
        end
        push(result, min_so_far)
        i = i + 1.0
    end

    return result
end

// Log returns: log(x[i] / x[i-1])
fn gpu_log_returns(arr)
    let n = len(arr)
    if n < 2.0
        return []
    end

    let mut result = []
    let mut i = 1.0
    while i < n
        let mut do_log = 0.0
        if arr[i - 1.0] > 0.0
            if arr[i] > 0.0
                do_log = 1.0
            end
        end
        if do_log > 0.5
            push(result, log(arr[i] / arr[i - 1.0]))
        else
            push(result, 0.0)
        end
        i = i + 1.0
    end

    return result
end

// Sign function: -1, 0, or 1
fn gpu_sign(arr)
    let n = len(arr)
    let mut result = []

    let mut i = 0.0
    while i < n
        if arr[i] > 0.0
            push(result, 1.0)
        elif arr[i] < 0.0
            push(result, 0.0 - 1.0)
        else
            push(result, 0.0)
        end
        i = i + 1.0
    end

    return result
end

// Clip to percentile range
fn gpu_clip_percentile(arr, lower_pct, upper_pct)
    let lower = gpu_percentile(arr, lower_pct)
    let upper = gpu_percentile(arr, upper_pct)

    return gpu_clamp(arr, lower, upper)
end

// Winsorize: clip outliers to percentiles
fn gpu_winsorize(arr, lower_pct, upper_pct)
    return gpu_clip_percentile(arr, lower_pct, upper_pct)
end

// Z-score normalization with threshold
fn gpu_robust_zscore(arr, cap_std)
    let zscores = gpu_zscore(arr)
    return gpu_clamp(zscores, 0.0 - cap_std, cap_std)
end

// Moving average (simple)
fn gpu_sma(arr, window)
    return gpu_rolling_mean(arr, window)
end

// Exponentially weighted moving average
fn gpu_ewma(arr, alpha)
    return gpu_ema(arr, alpha)
end

// Difference of moving averages
fn gpu_ma_diff(arr, window1, window2)
    let ma1 = gpu_rolling_mean(arr, window1)
    let ma2 = gpu_rolling_mean(arr, window2)

    let mut n = len(ma1)
    if len(ma2) < n
        n = len(ma2)
    end

    let mut result = []
    let mut i = 0.0
    while i < n
        push(result, ma1[i] - ma2[i])
        i = i + 1.0
    end

    return result
end

// Bollinger bands
fn gpu_bollinger_bands(arr, window, num_std)
    let ma = gpu_rolling_mean(arr, window)
    let n = len(arr)

    // Rolling std
    let mut rolling_std = []
    let mut i = 0.0
    while i < n - window + 1.0
        let mut window_data = []
        let mut j = 0.0
        while j < window
            push(window_data, arr[i + j])
            j = j + 1.0
        end

        push(rolling_std, gpu_std(window_data))
        i = i + 1.0
    end

    // Compute bands
    let mut upper = []
    let mut lower = []
    let mut i = 0.0
    while i < len(ma)
        if i < len(rolling_std)
            push(upper, ma[i] + num_std * rolling_std[i])
            push(lower, ma[i] - num_std * rolling_std[i])
        else
            push(upper, ma[i])
            push(lower, ma[i])
        end
        i = i + 1.0
    end

    let mut bands = map()
    map_set(bands, "upper", upper)
    map_set(bands, "middle", ma)
    map_set(bands, "lower", lower)

    return bands
end

// Rate of change
fn gpu_roc(arr, period)
    let n = len(arr)
    if period >= n
        return []
    end

    let mut result = []
    let mut i = period
    while i < n
        if arr[i - period] != 0.0
            push(result, (arr[i] - arr[i - period]) / arr[i - period] * 100.0)
        else
            push(result, 0.0)
        end
        i = i + 1.0
    end

    return result
end

// Momentum
fn gpu_momentum(arr, period)
    let n = len(arr)
    if period >= n
        return []
    end

    let mut result = []
    let mut i = period
    while i < n
        push(result, arr[i] - arr[i - period])
        i = i + 1.0
    end

    return result
end

// True range (for ATR calculation)
fn gpu_true_range(high, low, close)
    let n = len(high)
    if n != len(low)
        print("Error: arrays must have same length")
        return []
    end
    if n != len(close)
        print("Error: arrays must have same length")
        return []
    end

    let mut tr = []
    let mut i = 1.0
    while i < n
        let h_l = high[i] - low[i]
        let h_c = abs(high[i] - close[i - 1.0])
        let l_c = abs(low[i] - close[i - 1.0])

        let mut max_tr = h_l
        if h_c > max_tr
            max_tr = h_c
        end
        if l_c > max_tr
            max_tr = l_c
        end

        push(tr, max_tr)
        i = i + 1.0
    end

    return tr
end

// Average True Range
fn gpu_atr(high, low, close, period)
    let tr = gpu_true_range(high, low, close)
    return gpu_rolling_mean(tr, period)
end
