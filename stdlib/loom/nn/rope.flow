// stdlib/loom/rope.flow — GPU RoPE dispatch (buffer-handle API)
//
// Two modes:
//   gpu_rope(x, pos, d_head) → result array  (convenience)
//   gpu_rope_buf(buf_in, buf_out, pos, d_head) → 0.0  (zero-copy)

use "runtime"

fn gpu_rope_buf(buf_in, buf_out, pos, d_head)
  let pipe = rt_load_pipeline("stdlib/loom/kernels/nn/rope.spv", 2.0, 8.0)
  let _cb = rt_chain_begin(1.0, 2.0)
  let mut pc = []
  push(pc, pos)
  push(pc, d_head)
  let _pc = rt_chain_push_constants(pipe, pc)
  let mut bufs = []
  push(bufs, buf_in)
  push(bufs, buf_out)
  let _d = rt_chain_dispatch(pipe, bufs, 1.0)
  let _ce = rt_chain_end()
  let _sw = rt_chain_submit_wait()
  return 0.0
end

fn gpu_rope(x, pos, d_head)
  let n = len(x)
  let buf_in = rt_create_buffer(n * 4.0)
  let buf_out = rt_create_buffer(n * 4.0)
  let _u = rt_upload(buf_in, x)
  let _d = gpu_rope_buf(buf_in, buf_out, pos, d_head)
  let _dl = rt_download(buf_out, n)
  let mut result = []
  let mut i = 0.0
  while i < n
    push(result, rt_result[int(i)])
    i = i + 1.0
  end
  return result
end
