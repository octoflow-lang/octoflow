// stdlib/loom/rmsnorm.flow — GPU RMSNorm dispatch (buffer-handle API)
//
// Two modes:
//   gpu_rmsnorm(hidden, weight) → result array  (convenience)
//   gpu_rmsnorm_buf(buf_x, buf_w, buf_out, n) → 0.0  (zero-copy)

use "runtime"

fn gpu_rmsnorm_buf(buf_x, buf_w, buf_out, n)
  let pipe = rt_load_pipeline("stdlib/loom/kernels/nn/rmsnorm.spv", 3.0, 4.0)
  let _cb = rt_chain_begin(1.0, 3.0)
  let mut pc = []
  push(pc, n)
  let _pc = rt_chain_push_constants(pipe, pc)
  let mut bufs = []
  push(bufs, buf_x)
  push(bufs, buf_w)
  push(bufs, buf_out)
  let _d = rt_chain_dispatch(pipe, bufs, 1.0)
  let _ce = rt_chain_end()
  let _sw = rt_chain_submit_wait()
  return 0.0
end

fn gpu_rmsnorm(hidden, weight)
  let n = len(hidden)
  // Pad to 256
  let mut x_padded = []
  let mut w_padded = []
  let mut i = 0.0
  while i < 256.0
    if i < n
      push(x_padded, hidden[int(i)])
      push(w_padded, weight[int(i)])
    else
      push(x_padded, 0.0)
      push(w_padded, 0.0)
    end
    i = i + 1.0
  end
  let buf_x = rt_create_buffer(1024.0)
  let buf_w = rt_create_buffer(1024.0)
  let buf_o = rt_create_buffer(1024.0)
  let _u1 = rt_upload(buf_x, x_padded)
  let _u2 = rt_upload(buf_w, w_padded)
  let _d = gpu_rmsnorm_buf(buf_x, buf_w, buf_o, n)
  let _dl = rt_download(buf_o, n)
  let mut result = []
  let mut j = 0.0
  while j < n
    push(result, rt_result[int(j)])
    j = j + 1.0
  end
  return result
end
