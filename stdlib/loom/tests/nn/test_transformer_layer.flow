// test_transformer_layer.flow — End-to-end GPU transformer layer test
// Uses 16-dim hidden, identity weights → output should be predictable
// Run: octoflow run test_transformer_layer.flow --allow-read --allow-write --allow-exec --allow-ffi

use "../build_kernels"
use "../runtime"
use "../rmsnorm"
use "../matmul_tiled"

let mut counters = [0.0, 0.0]

fn check_near(counters, label, got, expected, tol)
  let d = abs(got - expected)
  if d < tol
    counters[0] = counters[0] + 1.0
    return 1.0
  end
  counters[1] = counters[1] + 1.0
  print("  FAIL: {label} — got {got}, expected {expected}, diff={d}")
  return 0.0
end

print("=== TRANSFORMER LAYER TEST ===")
print(" ")

// Build kernels
let _b = build_all_kernels()
let _init = rt_init()

let n_embd = 16.0

// ── Test 1: RMSNorm → identity matmul chain ──────────────────────────
print("--- Test 1: RMSNorm + matmul (identity weights) ---")

// Create simple hidden state: [1,1,1,...,1]
let mut hidden = []
let mut hi = 0.0
while hi < n_embd
  push(hidden, 1.0)
  hi = hi + 1.0
end

// Weight = all ones for RMSNorm
let mut norm_w = []
let mut wi = 0.0
while wi < n_embd
  push(norm_w, 1.0)
  wi = wi + 1.0
end

// RMSNorm([1,1,...,1], [1,1,...,1])
// RMS = sqrt(mean(1^2 * 16) + eps) = sqrt(1 + eps) ≈ 1.0
// output = (1/1) * 1 = 1.0 for each element
let normed = gpu_rmsnorm(hidden, norm_w)
let _c1 = check_near(counters, "rmsnorm[0]~1.0", normed[0], 1.0, 0.02)
let _c2 = check_near(counters, "rmsnorm[7]~1.0", normed[7], 1.0, 0.02)

// ── Test 2: Identity matmul ──────────────────────────────────────────
print("--- Test 2: Matmul with identity matrix ---")

// Create 16×16 identity matrix
let mut id_mat = []
let mut mi = 0.0
while mi < 256.0
  let row = floor(mi / 16.0)
  let col = mi - row * 16.0
  if row == col
    push(id_mat, 1.0)
  else
    push(id_mat, 0.0)
  end
  mi = mi + 1.0
end

// Pad normed to 16 rows
let mut h_padded = []
let mut pi = 0.0
while pi < 256.0
  if pi < n_embd
    push(h_padded, normed[int(pi)])
  else
    push(h_padded, 0.0)
  end
  pi = pi + 1.0
end

// [1,1,...,1] @ Identity = [1,1,...,1]
let mm_out = gpu_matmul_tiled(h_padded, id_mat, 16.0, 16.0, 16.0)
let _c3 = check_near(counters, "mm I*v [0]~1.0", mm_out[0], 1.0, 0.1)
let _c4 = check_near(counters, "mm I*v [15]~1.0", mm_out[15], 1.0, 0.1)

// ── Test 3: Residual add ─────────────────────────────────────────────
print("--- Test 3: Residual connection ---")
let mut residual = []
let mut ri = 0.0
while ri < n_embd
  let r = hidden[int(ri)] + mm_out[int(ri)]
  push(residual, r)
  ri = ri + 1.0
end
// 1.0 + 1.0 = 2.0
let _c5 = check_near(counters, "residual[0]=2.0", residual[0], 2.0, 0.1)

// ── Test 4: Full pipeline smoke test ─────────────────────────────────
print("--- Test 4: RMSNorm → matmul → residual → RMSNorm ---")
// Second RMSNorm on [2,2,...,2]
let normed2 = gpu_rmsnorm(residual, norm_w)
// RMS = sqrt(mean(4*16)/16 + eps) = sqrt(4) = 2.0
// output = (2/2) * 1 = 1.0
let _c6 = check_near(counters, "rmsnorm2[0]~1.0", normed2[0], 1.0, 0.02)

// ── Summary ──────────────────────────────────────────────────────────
print(" ")
let pass = counters[0]
let fail = counters[1]
let total = pass + fail
print("=== RESULTS: {pass}/{total} passed ===")
