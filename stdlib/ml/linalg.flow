// stdlib/ml/linalg.flow â€” Linear algebra operations
// Matrices stored as flat arrays in row-major order

fn mat_create(rows, cols, fill_val)
  let n = rows * cols
  let mut m = []
  let mut i = 0.0
  while i < n
    push(m, fill_val)
    i = i + 1.0
  end
  return m
end

fn mat_identity(n)
  let total = n * n
  let mut m = []
  let mut i = 0.0
  while i < total
    push(m, 0.0)
    i = i + 1.0
  end
  i = 0.0
  while i < n
    m[i * n + i] = 1.0
    i = i + 1.0
  end
  return m
end

fn mat_get(m, rows, cols, r, c)
  return m[r * cols + c]
end

fn mat_set(m, rows, cols, r, c, val)
  m[r * cols + c] = val
  return 0.0
end

fn mat_mul(a, b, m, n, k)
  // a: m x k, b: k x n, result: m x n (matches gpu_matmul convention)
  let mut result = []
  let total = m * n
  let mut i = 0.0
  while i < total
    push(result, 0.0)
    i = i + 1.0
  end
  i = 0.0
  while i < m
    let mut j = 0.0
    while j < n
      let mut sum = 0.0
      let mut p = 0.0
      while p < k
        sum = sum + a[i * k + p] * b[p * n + j]
        p = p + 1.0
      end
      result[i * n + j] = sum
      j = j + 1.0
    end
    i = i + 1.0
  end
  return result
end

fn mat_transpose(a, rows, cols)
  let mut result = []
  let total = rows * cols
  let mut i = 0.0
  while i < total
    push(result, 0.0)
    i = i + 1.0
  end
  i = 0.0
  while i < rows
    let mut j = 0.0
    while j < cols
      result[j * rows + i] = a[i * cols + j]
      j = j + 1.0
    end
    i = i + 1.0
  end
  return result
end

fn mat_add(a, b)
  let n = len(a)
  let mut result = []
  let mut i = 0.0
  while i < n
    push(result, a[i] + b[i])
    i = i + 1.0
  end
  return result
end

fn mat_scale(a, scalar)
  let n = len(a)
  let mut result = []
  for x in a
    push(result, x * scalar)
  end
  return result
end

fn mat_det_2x2(a)
  return a[0] * a[3] - a[1] * a[2]
end

fn mat_det_3x3(a)
  return a[0] * (a[4] * a[8] - a[5] * a[7]) - a[1] * (a[3] * a[8] - a[5] * a[6]) + a[2] * (a[3] * a[7] - a[4] * a[6])
end

fn mat_inverse_2x2(a)
  let det = mat_det_2x2(a)
  if abs(det) < 0.000001
    return a
  end
  let inv_det = 1.0 / det
  let mut result = []
  push(result, a[3] * inv_det)
  push(result, -1.0 * a[1] * inv_det)
  push(result, -1.0 * a[2] * inv_det)
  push(result, a[0] * inv_det)
  return result
end

fn outer_product(a, b)
  let m = len(a)
  let n = len(b)
  let mut result = []
  let mut i = 0.0
  while i < m
    let mut j = 0.0
    while j < n
      push(result, a[i] * b[j])
      j = j + 1.0
    end
    i = i + 1.0
  end
  return result
end

fn mat_trace(a, n)
  let mut sum = 0.0
  let mut i = 0.0
  while i < n
    sum = sum + a[i * n + i]
    i = i + 1.0
  end
  return sum
end

fn solve_2x2(a, b)
  // Solve Ax = b for 2x2 system using Cramer's rule
  let det = a[0] * a[3] - a[1] * a[2]
  if abs(det) < 0.000001
    let mut result = []
    push(result, 0.0)
    push(result, 0.0)
    return result
  end
  let x1 = (b[0] * a[3] - b[1] * a[1]) / det
  let x2 = (a[0] * b[1] - a[2] * b[0]) / det
  let mut result = []
  push(result, x1)
  push(result, x2)
  return result
end
