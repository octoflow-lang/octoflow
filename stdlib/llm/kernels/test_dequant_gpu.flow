// test_dequant_gpu.flow — GPU Dequant Kernel Tests
//
// Tests Q4_K and Q6_K GPU kernels against CPU reference.
// Uses known block data to verify correctness.
//
// Run from C:\FlowGPU:
//   octoflow run stdlib/llm/kernels/test_dequant_gpu.flow --allow-read --allow-write --allow-ffi --allow-exec

use "dequant"
use "emit_dequant_q4k"
use "emit_dequant_q6k"

let mut counters = [0.0, 0.0]

fn check(counters, label, got, expected)
  if got == expected
    counters[0] = counters[0] + 1.0
    return 1.0
  end
  counters[1] = counters[1] + 1.0
  print("  FAIL: {label} — got {got}, expected {expected}")
  return 0.0
end

fn check_near(counters, label, got, expected, tol)
  let d = abs(got - expected)
  if d < tol
    counters[0] = counters[0] + 1.0
    return 1.0
  end
  counters[1] = counters[1] + 1.0
  print("  FAIL: {label} — got {got}, expected {expected}, diff={d}")
  return 0.0
end

print("=== GPU DEQUANT KERNEL TESTS ===")
print(" ")

// ── Test 1: Q4_K emitter produces valid SPIR-V ──
print("--- Test 1: Q4_K SPIR-V emission ---")
let _e1 = emit_dequant_q4k("stdlib/llm/kernels/dequant_q4k.spv")
let v1 = exec("spirv-val", "stdlib/llm/kernels/dequant_q4k.spv")
let _c = check(counters, "Q4K spirv-val", v1.ok, 1.0)

// ── Test 2: Q6_K emitter produces valid SPIR-V ──
print("--- Test 2: Q6_K SPIR-V emission ---")
let _e2 = emit_dequant_q6k("stdlib/llm/kernels/dequant_q6k.spv")
let v2 = exec("spirv-val", "stdlib/llm/kernels/dequant_q6k.spv")
let _c2 = check(counters, "Q6K spirv-val", v2.ok, 1.0)

// ── Test 3: Q4_K CPU param preparation ──
print("--- Test 3: Q4_K param prep ---")

// Build a synthetic Q4_K block (144 bytes)
// d = 1.0 (f16: 0x3C00 → bytes: 0x00, 0x3C)
// dmin = 0.5 (f16: 0x3800 → bytes: 0x00, 0x38)
// scales[12] = all 1
// qs[128] = all 0x33 = 51 (lo=3, hi=3)
let mut q4_block = []
push(q4_block, 0.0)
push(q4_block, 60.0)
push(q4_block, 0.0)
push(q4_block, 56.0)
let mut si = 0.0
while si < 12.0
  push(q4_block, 1.0)
  si = si + 1.0
end
let mut qi = 0.0
while qi < 128.0
  push(q4_block, 51.0)
  qi = qi + 1.0
end
let _c3 = check(counters, "Q4K block size", len(q4_block), 144.0)

let prep4 = prepare_q4k_block(q4_block)
// prep4 = [128 qs bytes + 16 params] = 144 elements
let _c4 = check(counters, "Q4K prep size", len(prep4), 144.0)
// params start at index 128
// params[0] = d * sc0 = 1.0 * 1 = 1.0 (sub-block 0, j=0 < 4: sc = scales[0] & 63 = 1)
let _c5 = check_near(counters, "Q4K param d*sc0", prep4[128], 1.0, 0.01)
// params[1] = dmin * mn0 = 0.5 * 1 = 0.5
let _c6 = check_near(counters, "Q4K param dmin*mn0", prep4[129], 0.5, 0.01)
// params[8] = d * sc4 (j=4 ≥ 4: complex decode, sc=1 with all-1 scales)
let _c6b = check_near(counters, "Q4K param d*sc4", prep4[136], 1.0, 0.01)
// params[9] = dmin * mn4 (j=4 ≥ 4: min = floor(1/16)=0 → 0.5*0 = 0)
let _c6c = check_near(counters, "Q4K param dmin*mn4", prep4[137], 0.0, 0.01)

// ── Test 4: Q4_K CPU reference dequant expectations ──
print("--- Test 4: Q4_K expected values ---")
// Sub-blocks 0-3 (j < 4): d*sc=1, dmin*mn=0.5 → 1*3 - 0.5 = 2.5
// Sub-blocks 4-7 (j >= 4): d*sc=1, dmin*mn=0 → 1*3 - 0 = 3.0
// gid 0-63: sub-blocks 0,1 → 2.5
// gid 64-127: sub-blocks 2,3 → 2.5
// gid 128-191: sub-blocks 4,5 → 3.0
// gid 192-255: sub-blocks 6,7 → 3.0

// ── Test 5: Q6_K CPU param preparation ──
print("--- Test 5: Q6_K param prep ---")

// Build synthetic Q6_K block (210 bytes)
// ql[128]: all 85 (0x55) → lo nibble=5, hi nibble=5
// qh[64]: all 0 → all q_hi bits=0
// sc[16]: all 2 (positive signed int8)
// d: f16 0.25 = 0x3400 → bytes: 0x00, 0x34
let mut q6_block = []
let mut qli = 0.0
while qli < 128.0
  push(q6_block, 85.0)
  qli = qli + 1.0
end
let mut qhi = 0.0
while qhi < 64.0
  push(q6_block, 0.0)
  qhi = qhi + 1.0
end
let mut sci = 0.0
while sci < 16.0
  push(q6_block, 2.0)
  sci = sci + 1.0
end
push(q6_block, 0.0)
push(q6_block, 52.0)
let _c7 = check(counters, "Q6K block size", len(q6_block), 210.0)

let prep6 = prepare_q6k_block(q6_block)
// prep6 = [192 raw bytes + 16 params] = 208 elements
let _c8 = check(counters, "Q6K prep size", len(prep6), 208.0)
// params[0] = d * sc[0] = 0.25 * 2 = 0.5
let _c9 = check_near(counters, "Q6K param d*sc0", prep6[192], 0.5, 0.01)

// ── Test 6: Q6_K expected values ──
print("--- Test 6: Q6_K expected values ---")
// For sub_pos=0: q_lo = 85%16=5, q_hi = 0%4=0, q6=5, val=0.5*(5-32)=0.5*(-27)=-13.5
// For sub_pos=1: q_lo = 85%16=5, q_hi = 0, same → -13.5
// For sub_pos=2: q_lo = floor(85/16)=5, q_hi = 0, same → -13.5
// For sub_pos=3: q_lo = floor(85/16)=5, q_hi = 0, same → -13.5

// ── Test 7: GPU Q4_K dispatch ──
print("--- Test 7: GPU Q4_K dequant ---")

// Split prep4 into qs_bytes and params
let mut qs_bytes = []
let mut ci1 = 0.0
while ci1 < 128.0
  push(qs_bytes, prep4[int(ci1)])
  ci1 = ci1 + 1.0
end
let mut params_q4 = []
let mut ci2 = 0.0
while ci2 < 16.0
  push(params_q4, prep4[int(128.0 + ci2)])
  ci2 = ci2 + 1.0
end

// Init GPU runtime
let _ri = rt_init()

let gpu_q4 = gpu_dequant_q4k(qs_bytes, params_q4, 256.0)
let _c10 = check(counters, "GPU Q4K output len", len(gpu_q4), 256.0)

// Sub-blocks 0-3 (gid 0-127): d*sc=1, dmin*mn=0.5, nibble=3 → 2.5
let _c11 = check_near(counters, "GPU Q4K[0]", gpu_q4[0], 2.5, 0.1)
let _c12 = check_near(counters, "GPU Q4K[63]", gpu_q4[63], 2.5, 0.1)
// Sub-blocks 4-7 (gid 128-255): d*sc=1, dmin*mn=0, nibble=3 → 3.0
let _c13 = check_near(counters, "GPU Q4K[128]", gpu_q4[128], 3.0, 0.1)
let _c14 = check_near(counters, "GPU Q4K[255]", gpu_q4[255], 3.0, 0.1)

// ── Test 8: GPU Q6_K dispatch ──
print("--- Test 8: GPU Q6_K dequant ---")

let mut raw_bytes = []
let mut ci3 = 0.0
while ci3 < 192.0
  push(raw_bytes, prep6[int(ci3)])
  ci3 = ci3 + 1.0
end
let mut params_q6 = []
let mut ci4 = 0.0
while ci4 < 16.0
  push(params_q6, prep6[int(192.0 + ci4)])
  ci4 = ci4 + 1.0
end

let gpu_q6 = gpu_dequant_q6k(raw_bytes, params_q6, 256.0)
let _c15 = check(counters, "GPU Q6K output len", len(gpu_q6), 256.0)

// All sub-blocks: d*sc=0.5, q6=5, val = 0.5*(5-32) = -13.5
let _c16 = check_near(counters, "GPU Q6K[0]", gpu_q6[0], -13.5, 0.5)
let _c17 = check_near(counters, "GPU Q6K[32]", gpu_q6[32], -13.5, 0.5)
let _c18 = check_near(counters, "GPU Q6K[128]", gpu_q6[128], -13.5, 0.5)
let _c19 = check_near(counters, "GPU Q6K[255]", gpu_q6[255], -13.5, 0.5)

// ── SUMMARY ──
let pass = counters[0]
let fail = counters[1]
let total = pass + fail
print(" ")
print("=== RESULTS: {pass}/{total} passed ===")
if fail > 0.0
  print("FAILURES DETECTED")
end
