// test_image_transform.flow — Tests for stdlib/media/image_transform.flow
use "image_transform"

fn check(name, cond)
    if cond
        print("PASS: {name}")
    else
        print("FAIL: {name}")
        assert(0.0 == 1.0, name)
    end
    return 0.0
end

fn approx(a, b)
    if abs(a - b) < 1.5
        return 1.0
    end
    return 0.0
end

// Helper: create 4x4 test image with distinct pixel values
fn make_4x4(r, g, b)
    let mut i = 0.0
    while i < 16.0
        push(r, i * 16.0)
        push(g, 255.0 - i * 16.0)
        push(b, 128.0)
        i = i + 1.0
    end
    return 0.0
end

// ── Resize nearest ─────────────────────────────────────

fn test_resize_nearest()
    let mut sr = []  let mut sg = []  let mut sb = []
    let _m = make_4x4(sr, sg, sb)
    let mut dr = []  let mut dg = []  let mut db = []
    let n = img_resize_nearest(sr, sg, sb, 4.0, 4.0, dr, dg, db, 2.0, 2.0)
    check("nn size", n == 4.0)
    check("nn len", len(dr) == 4.0)
    // (0,0) of dst maps to (0,0) of src
    check("nn origin", approx(dr[0], sr[0]) == 1.0)
    // Scale up
    let mut dr2 = []  let mut dg2 = []  let mut db2 = []
    let n2 = img_resize_nearest(sr, sg, sb, 4.0, 4.0, dr2, dg2, db2, 8.0, 8.0)
    check("nn up", n2 == 64.0)
    check("nn up len", len(dr2) == 64.0)
    return 0.0
end

// ── Resize bilinear ────────────────────────────────────

fn test_resize_bilinear()
    let mut sr = []  let mut sg = []  let mut sb = []
    let _m = make_4x4(sr, sg, sb)
    let mut dr = []  let mut dg = []  let mut db = []
    let n = img_resize_bilinear(sr, sg, sb, 4.0, 4.0, dr, dg, db, 2.0, 2.0)
    check("bl size", n == 4.0)
    check("bl len", len(dr) == 4.0)
    // Scale up — should interpolate smoothly
    let mut dr2 = []  let mut dg2 = []  let mut db2 = []
    let n2 = img_resize_bilinear(sr, sg, sb, 4.0, 4.0, dr2, dg2, db2, 8.0, 8.0)
    check("bl up", n2 == 64.0)
    // Origin should approximately match
    check("bl origin", approx(dr2[0], sr[0]) == 1.0)
    return 0.0
end

// ── Rotate 90° ─────────────────────────────────────────

fn test_rotate_90()
    // 2x3 image → 3x2 after 90° CW
    let mut sr = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
    let mut sg = [10.0, 20.0, 30.0, 40.0, 50.0, 60.0]
    let mut sb = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    let mut dr = []  let mut dg = []  let mut db = []
    let new_w = img_rotate_90(sr, sg, sb, 2.0, 3.0, dr, dg, db)
    check("r90 w", new_w == 3.0)
    check("r90 len", len(dr) == 6.0)
    // Top-left of rotated = bottom-left of original
    // Original (0,2)=5 → rotated (0,0)
    check("r90 tl", dr[0] == 5.0)
    return 0.0
end

// ── Rotate 180° ────────────────────────────────────────

fn test_rotate_180()
    let mut sr = [1.0, 2.0, 3.0, 4.0]
    let mut sg = [10.0, 20.0, 30.0, 40.0]
    let mut sb = [0.0, 0.0, 0.0, 0.0]
    let mut dr = []  let mut dg = []  let mut db = []
    let w = img_rotate_180(sr, sg, sb, 2.0, 2.0, dr, dg, db)
    check("r180 w", w == 2.0)
    // (0,0) → src(1,1) = 4
    check("r180 tl", dr[0] == 4.0)
    // (1,1) → src(0,0) = 1
    check("r180 br", dr[3] == 1.0)
    return 0.0
end

// ── Rotate 270° ────────────────────────────────────────

fn test_rotate_270()
    let mut sr = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
    let mut sg = [10.0, 20.0, 30.0, 40.0, 50.0, 60.0]
    let mut sb = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    let mut dr = []  let mut dg = []  let mut db = []
    let new_w = img_rotate_270(sr, sg, sb, 2.0, 3.0, dr, dg, db)
    check("r270 w", new_w == 3.0)
    check("r270 len", len(dr) == 6.0)
    // Top-left of rotated = top-right of original
    // Original (1,0)=2 → rotated (0,0)
    check("r270 tl", dr[0] == 2.0)
    return 0.0
end

// ── Arbitrary rotation ─────────────────────────────────

fn test_rotate()
    let mut sr = []  let mut sg = []  let mut sb = []
    let _m = make_4x4(sr, sg, sb)
    let mut dr = []  let mut dg = []  let mut db = []
    let n = img_rotate(sr, sg, sb, 4.0, 4.0, dr, dg, db, 45.0, 0.0, 0.0, 0.0)
    check("rot size", n == 16.0)
    check("rot len", len(dr) == 16.0)
    // Center pixel should be approximately preserved
    // Center = (2,2) in 4x4 → idx 10
    check("rot center", dr[10] > 0.0)
    // 0° rotation should preserve image exactly
    let mut dr2 = []  let mut dg2 = []  let mut db2 = []
    let _n2 = img_rotate(sr, sg, sb, 4.0, 4.0, dr2, dg2, db2, 0.0, 0.0, 0.0, 0.0)
    check("rot 0deg", approx(dr2[0], sr[0]) == 1.0)
    check("rot 0last", approx(dr2[15], sr[15]) == 1.0)
    return 0.0
end

// ── Scale ──────────────────────────────────────────────

fn test_scale()
    let mut sr = []  let mut sg = []  let mut sb = []
    let _m = make_4x4(sr, sg, sb)
    let mut dr = []  let mut dg = []  let mut db = []
    // 2x zoom: center pixel magnified
    let n = img_scale(sr, sg, sb, 4.0, 4.0, dr, dg, db, 2.0, 2.0, 0.0, 0.0, 0.0)
    check("scale size", n == 16.0)
    // 0.5x zoom: entire image fits in center
    let mut dr2 = []  let mut dg2 = []  let mut db2 = []
    let _n2 = img_scale(sr, sg, sb, 4.0, 4.0, dr2, dg2, db2, 0.5, 0.5, 99.0, 99.0, 99.0)
    check("scale out", len(dr2) == 16.0)
    // Bad scale
    let mut dr3 = []  let mut dg3 = []  let mut db3 = []
    let n3 = img_scale(sr, sg, sb, 4.0, 4.0, dr3, dg3, db3, 0.0, 1.0, 0.0, 0.0, 0.0)
    check("scale zero", n3 == 0.0)
    return 0.0
end

// ── Translate ──────────────────────────────────────────

fn test_translate()
    let mut sr = [100.0, 200.0, 50.0, 150.0]
    let mut sg = [100.0, 200.0, 50.0, 150.0]
    let mut sb = [100.0, 200.0, 50.0, 150.0]
    let mut dr = []  let mut dg = []  let mut db = []
    let n = img_translate(sr, sg, sb, 2.0, 2.0, dr, dg, db, 1.0, 0.0, 0.0, 0.0, 0.0)
    check("trans size", n == 4.0)
    // (0,0) in dst comes from (-1,0) in src → background
    check("trans bg", dr[0] == 0.0)
    // (1,0) in dst comes from (0,0) in src → 100
    check("trans shift", approx(dr[1], 100.0) == 1.0)
    return 0.0
end

// ── Edge cases ─────────────────────────────────────────

fn test_edges()
    let mut sr = []  let mut sg = []  let mut sb = []
    let mut dr = []  let mut dg = []  let mut db = []
    // Zero dimensions
    let n1 = img_resize_nearest(sr, sg, sb, 0.0, 0.0, dr, dg, db, 4.0, 4.0)
    check("edge zero src", n1 == 0.0)
    let n2 = img_resize_nearest(sr, sg, sb, 4.0, 4.0, dr, dg, db, 0.0, 4.0)
    check("edge zero dst", n2 == 0.0)
    // Empty source arrays
    let n3 = img_rotate_90(sr, sg, sb, 4.0, 4.0, dr, dg, db)
    check("edge empty", n3 == 0.0)
    // Rotate with zero dimensions
    let n4 = img_rotate(sr, sg, sb, 0.0, 0.0, dr, dg, db, 45.0, 0.0, 0.0, 0.0)
    check("edge rot zero", n4 == 0.0)
    return 0.0
end

// ── 1x1 image ──────────────────────────────────────────

fn test_1x1()
    let mut sr = [128.0]
    let mut sg = [64.0]
    let mut sb = [32.0]
    let mut dr = []  let mut dg = []  let mut db = []
    let n = img_resize_nearest(sr, sg, sb, 1.0, 1.0, dr, dg, db, 4.0, 4.0)
    check("1x1 up", n == 16.0)
    // All pixels should be 128
    check("1x1 val", dr[0] == 128.0)
    check("1x1 last", dr[15] == 128.0)
    return 0.0
end

// ── Run all ────────────────────────────────────────────

test_resize_nearest()
test_resize_bilinear()
test_rotate_90()
test_rotate_180()
test_rotate_270()
test_rotate()
test_scale()
test_translate()
test_edges()
test_1x1()
print("")
print("All image_transform tests passed (10 tests)")
