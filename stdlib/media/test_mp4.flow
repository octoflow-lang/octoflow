// test_mp4.flow — Tests for stdlib/media/mp4.flow
// Tests MP4/ISO BMFF parsing: helpers, box walking, sample table
// Run: octoflow run stdlib/media/test_mp4.flow --allow-read

let mut pass = 0.0
let mut fail = 0.0

use mp4

// ─── Test big-endian helpers ───────────────────────────────────
let mut tb = [0.0, 1.0, 0.0, 255.0, 1.0, 0.0, 0.0, 1.0]

let v16a = mp4_u16be(tb, 0.0)
if v16a == 1.0
  pass = pass + 1.0
else
  print("FAIL u16be(0,1) expected 1, got {v16a}")
  fail = fail + 1.0
end

let v16b = mp4_u16be(tb, 2.0)
if v16b == 255.0
  pass = pass + 1.0
else
  print("FAIL u16be(0,255) expected 255, got {v16b}")
  fail = fail + 1.0
end

let v32a = mp4_u32be(tb, 0.0)
// bytes: 0, 1, 0, 255 → 0*16M + 1*65536 + 0*256 + 255 = 65791
if v32a == 65791.0
  pass = pass + 1.0
else
  print("FAIL u32be expected 65791, got {v32a}")
  fail = fail + 1.0
end

let v32b = mp4_u32be(tb, 4.0)
// bytes: 1, 0, 0, 1 → 16777216 + 1 = 16777217
if v32b == 16777217.0
  pass = pass + 1.0
else
  print("FAIL u32be expected 16777217, got {v32b}")
  fail = fail + 1.0
end

// ─── Test fourcc ───────────────────────────────────────────────
// "ftyp" = 102, 116, 121, 112
let mut fcc = [102.0, 116.0, 121.0, 112.0]
let fcc1 = mp4_fourcc(fcc, 0.0)
if fcc1 == "ftyp"
  pass = pass + 1.0
else
  print("FAIL fourcc expected ftyp, got {fcc1}")
  fail = fail + 1.0
end

// ─── Build minimal MP4 and test full parse ─────────────────────
// Helper: push 4-byte big-endian value
fn pb32(arr, val)
  let mut v = val
  let b3 = v - floor(v / 256.0) * 256.0
  v = floor(v / 256.0)
  let b2 = v - floor(v / 256.0) * 256.0
  v = floor(v / 256.0)
  let b1 = v - floor(v / 256.0) * 256.0
  v = floor(v / 256.0)
  let b0 = v
  push(arr, b0)
  push(arr, b1)
  push(arr, b2)
  push(arr, b3)
  return 0.0
end

fn pb16(arr, val)
  let hi = floor(val / 256.0)
  let lo = val - hi * 256.0
  push(arr, hi)
  push(arr, lo)
  return 0.0
end

fn pstr(arr, s)
  push(arr, ord(char_at(s, 0.0)))
  push(arr, ord(char_at(s, 1.0)))
  push(arr, ord(char_at(s, 2.0)))
  push(arr, ord(char_at(s, 3.0)))
  return 0.0
end

// Build a box: size(4) + type(4) + data
// Returns start position of the box
fn box_start(arr, tag)
  // Push 4 zero bytes (size placeholder) + 4 tag bytes
  push(arr, 0.0)
  push(arr, 0.0)
  push(arr, 0.0)
  push(arr, 0.0)
  push(arr, ord(char_at(tag, 0.0)))
  push(arr, ord(char_at(tag, 1.0)))
  push(arr, ord(char_at(tag, 2.0)))
  push(arr, ord(char_at(tag, 3.0)))
  // Compute start position after the fact (we added 8 bytes)
  let result = len(arr) - 8.0
  return result
end

fn box_end(arr, start)
  let size = len(arr) - start
  // Write size into the 4 bytes at start (big-endian)
  let mut v = size
  let b3 = v - floor(v / 256.0) * 256.0
  v = floor(v / 256.0)
  let b2 = v - floor(v / 256.0) * 256.0
  v = floor(v / 256.0)
  let b1 = v - floor(v / 256.0) * 256.0
  v = floor(v / 256.0)
  let b0 = v
  arr[int(start)] = b0
  arr[int(start + 1.0)] = b1
  arr[int(start + 2.0)] = b2
  arr[int(start + 3.0)] = b3
  return 0.0
end

let mut mp4 = []

// ── ftyp box ──
let ftyp_s = box_start(mp4, "ftyp")
pstr(mp4, "isom")     // major brand
pb32(mp4, 0.0)        // minor version
pstr(mp4, "isom")     // compatible brand
box_end(mp4, ftyp_s)

// ── mdat box (2 fake samples: 6 bytes + 4 bytes) ──
let mdat_s = box_start(mp4, "mdat")
// Sample 0: 6 bytes (fake H.264 NAL)
let sample0_off = len(mp4)
push(mp4, 0x65)  // NAL type 5 = IDR slice (nal_ref_idc=3, type=5)
push(mp4, 0xAA)
push(mp4, 0xBB)
push(mp4, 0xCC)
push(mp4, 0xDD)
push(mp4, 0xEE)
// Sample 1: 4 bytes (starts right after sample 0)
push(mp4, 0x41)  // NAL type 1 = non-IDR
push(mp4, 0x11)
push(mp4, 0x22)
push(mp4, 0x33)
box_end(mp4, mdat_s)

// ── moov box ──
let moov_s = box_start(mp4, "moov")

// mvhd (movie header)
let mvhd_s = box_start(mp4, "mvhd")
// FullBox: version=0, flags=0
pb32(mp4, 0.0)
// creation_time, modification_time
pb32(mp4, 0.0)
pb32(mp4, 0.0)
// timescale = 1000 (ms)
pb32(mp4, 1000.0)
// duration = 2000 (2 seconds)
pb32(mp4, 2000.0)
// rate (1.0 = 0x00010000)
pb32(mp4, 65536.0)
// volume (1.0 = 0x0100) + reserved
pb16(mp4, 256.0)
// reserved (10 bytes)
for i in range(0, 10)
  push(mp4, 0.0)
end
// matrix (36 bytes) + pre_defined (24 bytes) = 60 bytes
for i in range(0, 60)
  push(mp4, 0.0)
end
// next_track_id
pb32(mp4, 2.0)
box_end(mp4, mvhd_s)

// trak (video track)
let trak_s = box_start(mp4, "trak")

// tkhd (track header)
let tkhd_s = box_start(mp4, "tkhd")
pb32(mp4, 0.0)  // version+flags
pb32(mp4, 0.0)  // creation_time
pb32(mp4, 0.0)  // modification_time
pb32(mp4, 1.0)  // track_id
pb32(mp4, 0.0)  // reserved
pb32(mp4, 2000.0) // duration
// reserved(8) + layer(2) + alt_group(2) + volume(2) + reserved(2)
for i in range(0, 16)
  push(mp4, 0.0)
end
// matrix (36 bytes)
for i in range(0, 36)
  push(mp4, 0.0)
end
// width, height (16.16 fixed point)
pb32(mp4, 1310720.0)  // 20 << 16 = 1310720
pb32(mp4, 983040.0)   // 15 << 16 = 983040
box_end(mp4, tkhd_s)

// mdia
let mdia_s = box_start(mp4, "mdia")

// mdhd (media header)
let mdhd_s = box_start(mp4, "mdhd")
pb32(mp4, 0.0)     // version+flags
pb32(mp4, 0.0)     // creation_time
pb32(mp4, 0.0)     // modification_time
pb32(mp4, 30000.0) // timescale (30000 for 30fps * 1000)
pb32(mp4, 60000.0) // duration
pb32(mp4, 0.0)     // language + pre_defined
box_end(mp4, mdhd_s)

// hdlr (handler — marks this as video)
let hdlr_s = box_start(mp4, "hdlr")
pb32(mp4, 0.0)      // version+flags
pb32(mp4, 0.0)      // pre_defined
pstr(mp4, "vide")   // handler_type = video!
// reserved (12 bytes) + name (null-terminated)
for i in range(0, 12)
  push(mp4, 0.0)
end
push(mp4, 0.0)  // name terminator
box_end(mp4, hdlr_s)

// minf
let minf_s = box_start(mp4, "minf")

// vmhd (video media header)
let vmhd_s = box_start(mp4, "vmhd")
pb32(mp4, 1.0)  // version=0, flags=1
pb16(mp4, 0.0)  // graphicsmode
pb16(mp4, 0.0)  // opcolor[3]
pb16(mp4, 0.0)
pb16(mp4, 0.0)
box_end(mp4, vmhd_s)

// stbl (sample table)
let stbl_s = box_start(mp4, "stbl")

// stsd (sample description)
let stsd_s = box_start(mp4, "stsd")
pb32(mp4, 0.0)   // version+flags
pb32(mp4, 1.0)   // entry_count = 1
// Visual sample entry (avc1)
let avc1_s = box_start(mp4, "avc1")
// reserved(6) + data_ref_idx(2)
for i in range(0, 6)
  push(mp4, 0.0)
end
pb16(mp4, 1.0)   // data_reference_index
// pre_defined(2) + reserved(2) + pre_defined(12)
for i in range(0, 16)
  push(mp4, 0.0)
end
// width(2) + height(2)
pb16(mp4, 20.0)   // width = 20
pb16(mp4, 15.0)   // height = 15
// horiz_res(4) + vert_res(4) + reserved(4) + frame_count(2) + compressor(32) + depth(2) + pre_defined(2)
pb32(mp4, 4718592.0)  // 72.0 fixed 16.16
pb32(mp4, 4718592.0)
pb32(mp4, 0.0)
pb16(mp4, 1.0)   // frame_count
for i in range(0, 32)
  push(mp4, 0.0)  // compressor name
end
pb16(mp4, 24.0)  // depth
pb16(mp4, 65535.0) // pre_defined = -1

// avcC box (AVC decoder configuration)
let avcc_s = box_start(mp4, "avcC")
push(mp4, 1.0)    // configurationVersion
push(mp4, 66.0)   // AVCProfileIndication (Baseline)
push(mp4, 0.0)    // profile_compatibility
push(mp4, 30.0)   // AVCLevelIndication (3.0)
push(mp4, 255.0)  // 0xFF: lengthSizeMinusOne=3 (4 bytes) + reserved 6 bits
// SPS
push(mp4, 225.0)  // 0xE1: numOfSPS=1 + reserved 3 bits
pb16(mp4, 3.0)    // sps_length = 3
push(mp4, 0x67)   // SPS NAL byte 0
push(mp4, 0x42)   // SPS byte 1
push(mp4, 0x00)   // SPS byte 2
// PPS
push(mp4, 1.0)    // numOfPPS=1
pb16(mp4, 2.0)    // pps_length = 2
push(mp4, 0x68)   // PPS NAL byte 0
push(mp4, 0xCE)   // PPS byte 1
box_end(mp4, avcc_s)
box_end(mp4, avc1_s)
box_end(mp4, stsd_s)

// stts (time-to-sample: 2 samples, each 1000 timescale units)
let stts_s = box_start(mp4, "stts")
pb32(mp4, 0.0)    // version+flags
pb32(mp4, 1.0)    // entry_count
pb32(mp4, 2.0)    // sample_count
pb32(mp4, 1000.0) // sample_delta
box_end(mp4, stts_s)

// stsc (sample-to-chunk: 1 chunk contains 2 samples)
let stsc_s = box_start(mp4, "stsc")
pb32(mp4, 0.0)    // version+flags
pb32(mp4, 1.0)    // entry_count
pb32(mp4, 1.0)    // first_chunk (1-based)
pb32(mp4, 2.0)    // samples_per_chunk
pb32(mp4, 1.0)    // sample_description_index
box_end(mp4, stsc_s)

// stsz (sample sizes: 6 and 4 bytes)
let stsz_s = box_start(mp4, "stsz")
pb32(mp4, 0.0)    // version+flags
pb32(mp4, 0.0)    // sample_size=0 (variable)
pb32(mp4, 2.0)    // sample_count
pb32(mp4, 6.0)    // sample 0 size
pb32(mp4, 4.0)    // sample 1 size
box_end(mp4, stsz_s)

// stco (chunk offsets: 1 chunk at sample0_off)
let stco_s = box_start(mp4, "stco")
pb32(mp4, 0.0)    // version+flags
pb32(mp4, 1.0)    // entry_count
pb32(mp4, sample0_off) // chunk 0 offset
box_end(mp4, stco_s)

box_end(mp4, stbl_s)  // end stbl
box_end(mp4, minf_s)  // end minf
box_end(mp4, mdia_s)  // end mdia
box_end(mp4, trak_s)  // end trak
box_end(mp4, moov_s)  // end moov

// ─── Parse and verify ──────────────────────────────────────────
let info = mp4_parse(mp4)

let mok = info["ok"]
if mok == 1.0
  pass = pass + 1.0
else
  let merr = info["error"]
  print("FAIL mp4_parse ok expected 1, got error: {merr}")
  fail = fail + 1.0
end

let mw = info["width"]
if mw == 20.0
  pass = pass + 1.0
else
  print("FAIL mp4 width expected 20, got {mw}")
  fail = fail + 1.0
end

let mh = info["height"]
if mh == 15.0
  pass = pass + 1.0
else
  print("FAIL mp4 height expected 15, got {mh}")
  fail = fail + 1.0
end

let mfc = info["frame_count"]
if mfc == 2.0
  pass = pass + 1.0
else
  print("FAIL mp4 frame_count expected 2, got {mfc}")
  fail = fail + 1.0
end

let mnls = info["nal_length_size"]
if mnls == 4.0
  pass = pass + 1.0
else
  print("FAIL nal_length_size expected 4, got {mnls}")
  fail = fail + 1.0
end

// Check SPS extraction
let sps_len = len(mp4_sps)
if sps_len == 3.0
  pass = pass + 1.0
else
  print("FAIL mp4_sps length expected 3, got {sps_len}")
  fail = fail + 1.0
end

if sps_len >= 1.0
  let sps0 = mp4_sps[0]
  if sps0 == 103.0
    pass = pass + 1.0
  else
    print("FAIL sps[0] expected 103 (0x67), got {sps0}")
    fail = fail + 1.0
  end
end

// Check PPS extraction
let pps_len = len(mp4_pps)
if pps_len == 2.0
  pass = pass + 1.0
else
  print("FAIL mp4_pps length expected 2, got {pps_len}")
  fail = fail + 1.0
end

// Check frame offset table
let off_count = len(mp4_offsets)
if off_count == 4.0
  pass = pass + 1.0
else
  print("FAIL mp4_offsets expected 4 (2 frames * 2), got {off_count}")
  fail = fail + 1.0
end

// Verify sample 0 extraction
let s0 = mp4_get_sample(mp4, 0.0)
let s0len = len(s0)
if s0len == 6.0
  pass = pass + 1.0
else
  print("FAIL sample 0 length expected 6, got {s0len}")
  fail = fail + 1.0
end

if s0len >= 1.0
  let s0b0 = s0[0]
  if s0b0 == 101.0
    pass = pass + 1.0
  else
    print("FAIL sample 0 byte 0 expected 101 (0x65), got {s0b0}")
    fail = fail + 1.0
  end
end

// Verify sample 1 extraction
let s1 = mp4_get_sample(mp4, 1.0)
let s1len = len(s1)
if s1len == 4.0
  pass = pass + 1.0
else
  print("FAIL sample 1 length expected 4, got {s1len}")
  fail = fail + 1.0
end

// Error handling: empty file
let mut empty = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
let bad = mp4_parse(empty)
let bok = bad["ok"]
if bok == 0.0
  pass = pass + 1.0
else
  print("FAIL bad file should return ok=0")
  fail = fail + 1.0
end

// ─── Summary ─────────────────────────────────────────────────
let total = pass + fail
print("")
print("mp4.flow tests: {pass}/{total} passed")
if fail > 0.0
  print("FAILURES: {fail}")
end
