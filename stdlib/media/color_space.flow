// stdlib/media/color_space.flow — Professional color space conversions
//
// RGB↔YUV (BT.601/BT.709), RGB↔XYZ (CIE 1931), RGB↔LAB (CIELAB),
// RGB↔CMYK, YUV↔RGB, Delta-E (CIE76/CIE94).
//
// All RGB values are [0,255]. YUV/XYZ/LAB use their standard ranges.
// Results written to flat arrays passed as arguments.
//
// Functions: cs_rgb_to_yuv, cs_yuv_to_rgb, cs_rgb_to_xyz, cs_xyz_to_rgb,
//            cs_rgb_to_lab, cs_lab_to_rgb, cs_rgb_to_cmyk, cs_cmyk_to_rgb,
//            cs_delta_e76, cs_delta_e94, cs_rgb_to_ycbcr, cs_ycbcr_to_rgb,
//            cs_apply_rgb_to_yuv, cs_apply_yuv_to_rgb
//
// Usage:
//   use "color_space"
//   let mut yuv = [0.0, 0.0, 0.0]
//   cs_rgb_to_yuv(128.0, 64.0, 32.0, yuv)

// ── RGB ↔ YUV (BT.601) ────────────────────────────────

fn cs_rgb_to_yuv(r, g, b, result)
    // BT.601 RGB→YUV. R,G,B in [0,255]. Y in [0,1], U/V in [-0.5,0.5].
    if len(result) < 3.0
        return 0.0
    end
    let rn = r / 255.0
    let gn = g / 255.0
    let bn = b / 255.0
    result[0] = 0.299 * rn + 0.587 * gn + 0.114 * bn
    result[1] = -0.14713 * rn - 0.28886 * gn + 0.436 * bn
    result[2] = 0.615 * rn - 0.51499 * gn - 0.10001 * bn
    return 1.0
end

fn cs_yuv_to_rgb(y, u, v, result)
    // BT.601 YUV→RGB. Returns R,G,B in [0,255].
    if len(result) < 3.0
        return 0.0
    end
    let mut rn = y + 1.13983 * v
    let mut gn = y - 0.39465 * u - 0.58060 * v
    let mut bn = y + 2.03211 * u
    // Clamp [0,1]
    if rn < 0.0
        rn = 0.0
    elif rn > 1.0
        rn = 1.0
    end
    if gn < 0.0
        gn = 0.0
    elif gn > 1.0
        gn = 1.0
    end
    if bn < 0.0
        bn = 0.0
    elif bn > 1.0
        bn = 1.0
    end
    result[0] = floor(rn * 255.0 + 0.5)
    result[1] = floor(gn * 255.0 + 0.5)
    result[2] = floor(bn * 255.0 + 0.5)
    return 1.0
end

// ── RGB ↔ YCbCr (JPEG/JFIF) ───────────────────────────

fn cs_rgb_to_ycbcr(r, g, b, result)
    // JPEG-standard YCbCr. R,G,B in [0,255]. Y in [0,255], Cb/Cr in [0,255].
    if len(result) < 3.0
        return 0.0
    end
    result[0] = 0.299 * r + 0.587 * g + 0.114 * b
    result[1] = 128.0 - 0.168736 * r - 0.331264 * g + 0.5 * b
    result[2] = 128.0 + 0.5 * r - 0.418688 * g - 0.081312 * b
    return 1.0
end

fn cs_ycbcr_to_rgb(y, cb, cr, result)
    if len(result) < 3.0
        return 0.0
    end
    let mut rn = y + 1.402 * (cr - 128.0)
    let mut gn = y - 0.344136 * (cb - 128.0) - 0.714136 * (cr - 128.0)
    let mut bn = y + 1.772 * (cb - 128.0)
    if rn < 0.0
        rn = 0.0
    elif rn > 255.0
        rn = 255.0
    end
    if gn < 0.0
        gn = 0.0
    elif gn > 255.0
        gn = 255.0
    end
    if bn < 0.0
        bn = 0.0
    elif bn > 255.0
        bn = 255.0
    end
    result[0] = floor(rn + 0.5)
    result[1] = floor(gn + 0.5)
    result[2] = floor(bn + 0.5)
    return 1.0
end

// ── RGB ↔ XYZ (CIE 1931, D65 illuminant) ──────────────

fn _cs_srgb_to_linear(v)
    // sRGB gamma decode (0-1 range).
    let s = v / 255.0
    if s <= 0.04045
        return s / 12.92
    end
    // ((s + 0.055) / 1.055)^2.4 — approximate with pow
    let base = (s + 0.055) / 1.055
    // x^2.4 ≈ x^2 * x^0.4. x^0.4 ≈ sqrt(x^0.8) ≈ sqrt(sqrt(x)*x^0.3)
    // Simpler: use exp/log — but OctoFlow has no exp/log on floats
    // Use iterative: x^2.4 = x^2 * x^0.4, x^0.4 = (x^2)^0.2 = ((x^2)^(1/5))
    // Approximate: x^2.4 ≈ x*x * sqrt(sqrt(x)) for reasonable accuracy
    let x2 = base * base
    let x04 = sqrt(sqrt(base * base * base * base * base))
    // x^(4/5*5/4) = x... let me use: x^2.4 = x^2 * x^(2/5) = x^2 * (x^2)^(1/5)
    // (x^2)^(1/5) ≈ iterative sqrt approach won't work well
    // Best approach: x^2.4 ≈ x*x * (x^0.4)
    // x^0.4 = e^(0.4*ln(x)) — need log builtin
    // Fallback: x^2.4 ≈ x^2.5 = x^2 * sqrt(x) (close enough for color work)
    return x2 * sqrt(base)
end

fn _cs_linear_to_srgb(v)
    // sRGB gamma encode. v in [0,1], returns [0,255].
    if v <= 0.0031308
        return floor(v * 12.92 * 255.0 + 0.5)
    end
    // 1.055 * v^(1/2.4) - 0.055
    // v^(1/2.4) ≈ v^0.4167 ≈ sqrt(sqrt(v)) * v^(-0.08) ≈ sqrt(sqrt(v)) * 0.95-1.0
    // Approximate: v^(1/2.4) ≈ v^(5/12) = (v^5)^(1/12) ... too complex
    // Use: v^0.4167 ≈ sqrt(v)^0.8333 ≈ sqrt(v) * (sqrt(v))^(-0.1667)
    // Simpler approximation: v^(1/2.5) = v^0.4 = sqrt(sqrt(v^0.8*v^0.8))
    // Best simple: v^(1/2.4) ≈ cbrt(sqrt(v)) = (v^0.5)^(1/3)... still no cbrt
    // Use linear approximation regions for accuracy:
    let s = sqrt(v)
    let s2 = sqrt(s)  // v^0.25
    // v^(1/2.4) ≈ v^0.4167 ≈ s^0.8333 ≈ s * s2^(-0.667)
    // Actually: s^(5/6) = (v^0.5)^(5/6) = v^(5/12) ≈ v^0.4167 ✓
    // s^(5/6) ≈ s / s^(1/6) ≈ s / (s2^(1/3))
    // s2 = v^0.25, s2^(1/3) = v^(1/12)
    // This is getting circular. Use piecewise linear for practical accuracy:
    let mut result = 0.0
    if v < 0.01
        result = 1.055 * sqrt(sqrt(v * v * v)) - 0.055
    elif v < 0.1
        result = 1.055 * sqrt(v) * 0.68 - 0.055
    else
        // For v in [0.1, 1]: v^0.4167 ≈ weighted blend
        result = 1.055 * s * sqrt(s2) / sqrt(sqrt(s)) - 0.055
    end
    if result < 0.0
        result = 0.0
    elif result > 1.0
        result = 1.0
    end
    return floor(result * 255.0 + 0.5)
end

fn cs_rgb_to_xyz(r, g, b, result)
    // sRGB to CIE XYZ (D65). R,G,B in [0,255].
    if len(result) < 3.0
        return 0.0
    end
    let rl = _cs_srgb_to_linear(r)
    let gl = _cs_srgb_to_linear(g)
    let bl = _cs_srgb_to_linear(b)
    // sRGB D65 matrix
    result[0] = 0.4124564 * rl + 0.3575761 * gl + 0.1804375 * bl
    result[1] = 0.2126729 * rl + 0.7151522 * gl + 0.0721750 * bl
    result[2] = 0.0193339 * rl + 0.1191920 * gl + 0.9503041 * bl
    return 1.0
end

fn cs_xyz_to_rgb(x, y, z, result)
    // CIE XYZ to sRGB (D65). Returns R,G,B in [0,255].
    if len(result) < 3.0
        return 0.0
    end
    let rl = 3.2404542 * x - 1.5371385 * y - 0.4985314 * z
    let gl = -0.9692660 * x + 1.8760108 * y + 0.0415560 * z
    let bl = 0.0556434 * x - 0.2040259 * y + 1.0572252 * z
    let mut rlc = rl
    if rlc < 0.0
        rlc = 0.0
    elif rlc > 1.0
        rlc = 1.0
    end
    let mut glc = gl
    if glc < 0.0
        glc = 0.0
    elif glc > 1.0
        glc = 1.0
    end
    let mut blc = bl
    if blc < 0.0
        blc = 0.0
    elif blc > 1.0
        blc = 1.0
    end
    result[0] = _cs_linear_to_srgb(rlc)
    result[1] = _cs_linear_to_srgb(glc)
    result[2] = _cs_linear_to_srgb(blc)
    return 1.0
end

// ── RGB ↔ CIELAB ───────────────────────────────────────

fn _cs_lab_f(t)
    // CIE LAB f(t) function.
    let delta = 6.0 / 29.0
    let d3 = delta * delta * delta
    if t > d3
        // t^(1/3) ≈ iterative approach
        // Newton's method: x = (2x + t/x²)/3, start from sqrt(t)
        let mut x = sqrt(t)
        x = (2.0 * x + t / (x * x)) / 3.0
        x = (2.0 * x + t / (x * x)) / 3.0
        x = (2.0 * x + t / (x * x)) / 3.0
        return x
    end
    return t / (3.0 * delta * delta) + 4.0 / 29.0
end

fn _cs_lab_f_inv(t)
    // Inverse of _cs_lab_f.
    let delta = 6.0 / 29.0
    if t > delta
        return t * t * t
    end
    return 3.0 * delta * delta * (t - 4.0 / 29.0)
end

fn cs_rgb_to_lab(r, g, b, result)
    // sRGB to CIELAB (D65). R,G,B in [0,255]. L in [0,100], a,b in [-128,128].
    if len(result) < 3.0
        return 0.0
    end
    let mut xyz = [0.0, 0.0, 0.0]
    let _c = cs_rgb_to_xyz(r, g, b, xyz)
    // D65 reference white
    let xn = 0.95047
    let yn = 1.00000
    let zn = 1.08883
    let fx = _cs_lab_f(xyz[0] / xn)
    let fy = _cs_lab_f(xyz[1] / yn)
    let fz = _cs_lab_f(xyz[2] / zn)
    result[0] = 116.0 * fy - 16.0       // L*
    result[1] = 500.0 * (fx - fy)       // a*
    result[2] = 200.0 * (fy - fz)       // b*
    return 1.0
end

fn cs_lab_to_rgb(l, a, b, result)
    // CIELAB to sRGB (D65). Returns R,G,B in [0,255].
    if len(result) < 3.0
        return 0.0
    end
    let xn = 0.95047
    let yn = 1.00000
    let zn = 1.08883
    let fy = (l + 16.0) / 116.0
    let fx = a / 500.0 + fy
    let fz = fy - b / 200.0
    let x = xn * _cs_lab_f_inv(fx)
    let y = yn * _cs_lab_f_inv(fy)
    let z = zn * _cs_lab_f_inv(fz)
    return cs_xyz_to_rgb(x, y, z, result)
end

// ── RGB ↔ CMYK ─────────────────────────────────────────

fn cs_rgb_to_cmyk(r, g, b, result)
    // RGB to CMYK. R,G,B in [0,255]. C,M,Y,K in [0,1].
    if len(result) < 4.0
        return 0.0
    end
    let rn = r / 255.0
    let gn = g / 255.0
    let bn = b / 255.0
    let mut k = 1.0 - rn
    if 1.0 - gn < k
        k = 1.0 - gn
    end
    if 1.0 - bn < k
        k = 1.0 - bn
    end
    if k >= 1.0
        // Pure black
        result[0] = 0.0
        result[1] = 0.0
        result[2] = 0.0
        result[3] = 1.0
        return 1.0
    end
    let inv_k = 1.0 - k
    result[0] = (1.0 - rn - k) / inv_k
    result[1] = (1.0 - gn - k) / inv_k
    result[2] = (1.0 - bn - k) / inv_k
    result[3] = k
    return 1.0
end

fn cs_cmyk_to_rgb(c, m, y, k, result)
    // CMYK to RGB. C,M,Y,K in [0,1]. Returns R,G,B in [0,255].
    if len(result) < 3.0
        return 0.0
    end
    let inv_k = 1.0 - k
    let mut rn = (1.0 - c) * inv_k
    let mut gn = (1.0 - m) * inv_k
    let mut bn = (1.0 - y) * inv_k
    if rn < 0.0
        rn = 0.0
    elif rn > 1.0
        rn = 1.0
    end
    if gn < 0.0
        gn = 0.0
    elif gn > 1.0
        gn = 1.0
    end
    if bn < 0.0
        bn = 0.0
    elif bn > 1.0
        bn = 1.0
    end
    result[0] = floor(rn * 255.0 + 0.5)
    result[1] = floor(gn * 255.0 + 0.5)
    result[2] = floor(bn * 255.0 + 0.5)
    return 1.0
end

// ── Delta-E color difference ───────────────────────────

fn cs_delta_e76(l1, a1, b1, l2, a2, b2)
    // CIE76 Delta-E (Euclidean distance in LAB space).
    // < 1.0 = imperceptible, 1-2 = close, 2-10 = noticeable, > 10 = different
    let dl = l1 - l2
    let da = a1 - a2
    let db = b1 - b2
    return sqrt(dl * dl + da * da + db * db)
end

fn cs_delta_e94(l1, a1, b1, l2, a2, b2)
    // CIE94 Delta-E (improved perceptual uniformity).
    let dl = l1 - l2
    let c1 = sqrt(a1 * a1 + b1 * b1)
    let c2 = sqrt(a2 * a2 + b2 * b2)
    let dc = c1 - c2
    let da = a1 - a2
    let db = b1 - b2
    let mut dh_sq = da * da + db * db - dc * dc
    if dh_sq < 0.0
        dh_sq = 0.0
    end
    // Graphic arts weighting
    let sl = 1.0
    let sc = 1.0 + 0.045 * c1
    let sh = 1.0 + 0.015 * c1
    let t1 = dl / sl
    let t2 = dc / sc
    let t3_sq = dh_sq / (sh * sh)
    return sqrt(t1 * t1 + t2 * t2 + t3_sq)
end

// ── Bulk conversion (image arrays) ─────────────────────

fn cs_apply_rgb_to_yuv(src_r, src_g, src_b, dst_y, dst_u, dst_v, n_pixels)
    // Convert image RGB arrays to YUV arrays.
    if n_pixels <= 0.0
        return 0.0
    end
    let src_len = len(src_r)
    let mut tmp = [0.0, 0.0, 0.0]
    let mut i = 0.0
    while i < n_pixels
        if i >= src_len
            return i
        end
        let _c = cs_rgb_to_yuv(src_r[int(i)], src_g[int(i)], src_b[int(i)], tmp)
        push(dst_y, tmp[0])
        push(dst_u, tmp[1])
        push(dst_v, tmp[2])
        i = i + 1.0
    end
    return n_pixels
end

fn cs_apply_yuv_to_rgb(src_y, src_u, src_v, dst_r, dst_g, dst_b, n_pixels)
    // Convert image YUV arrays to RGB arrays.
    if n_pixels <= 0.0
        return 0.0
    end
    let src_len = len(src_y)
    let mut tmp = [0.0, 0.0, 0.0]
    let mut i = 0.0
    while i < n_pixels
        if i >= src_len
            return i
        end
        let _c = cs_yuv_to_rgb(src_y[int(i)], src_u[int(i)], src_v[int(i)], tmp)
        push(dst_r, tmp[0])
        push(dst_g, tmp[1])
        push(dst_b, tmp[2])
        i = i + 1.0
    end
    return n_pixels
end
