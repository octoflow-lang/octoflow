// stdlib/encoding/hex.flow â€” Pure .flow hex encoder/decoder (byte-array level)
//
// Functions: hex_nibble, hex_val, bytes_to_hex, hex_to_bytes
//
// Lowercase hex output. All byte values are f32 floats in range 0-255.
// Note: OctoFlow has built-in hex_encode/hex_decode for string-to-string.
// These functions work at byte-array level: bytes_to_hex / hex_to_bytes.

// Helper: nibble value (0-15) to hex character (lowercase)
fn hex_nibble(n)
  if n < 10.0
    // 0-9 -> '0'-'9' (ASCII 48-57)
    return chr(48.0 + n)
  end
  // 10-15 -> 'a'-'f' (ASCII 97-102)
  return chr(97.0 + n - 10.0)
end

// Helper: hex character to nibble value (0-15), -1 for invalid
fn hex_val(c)
  let code = ord(c)
  // '0'-'9' (48-57) -> 0-9
  if code >= 48.0 && code <= 57.0
    return code - 48.0
  end
  // 'a'-'f' (97-102) -> 10-15
  if code >= 97.0 && code <= 102.0
    return code - 97.0 + 10.0
  end
  // 'A'-'F' (65-70) -> 10-15
  if code >= 65.0 && code <= 70.0
    return code - 65.0 + 10.0
  end
  return -1.0
end

// Encode array of byte values (0-255 floats) to lowercase hex string
fn bytes_to_hex(data)
  let n = len(data)
  if n == 0.0
    return ""
  end
  let mut result = ""
  let mut i = 0.0
  while i < n
    let byte = int(data[i])
    let hi = bit_shr(byte, 4.0)
    let lo = bit_and(byte, 15.0)
    result = result + hex_nibble(hi)
    result = result + hex_nibble(lo)
    i = i + 1.0
  end
  return result
end

// Decode hex string to array of byte values (0-255 floats)
// Requires even-length input; odd-length strings return empty array.
fn hex_to_bytes(s)
  let mut out = []
  let n = len(s)
  if n == 0.0
    return out
  end
  // Reject odd-length hex strings
  if int(n) % 2 != 0
    return out
  end
  let mut i = 0.0
  while i < n
    let hi = hex_val(char_at(s, i))
    let lo = hex_val(char_at(s, i + 1.0))
    let byte = bit_or(bit_shl(hi, 4.0), lo)
    push(out, byte)
    i = i + 2.0
  end
  return out
end
