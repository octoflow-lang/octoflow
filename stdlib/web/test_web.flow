// test_web.flow — Tests for stdlib/web/json_util.flow and stdlib/web/url.flow
// Functions tested:
//   json_util: json_pretty, json_merge, json_get, json_flatten
//   url:       url_parse, build_url, url_encode, query_string
use "json_util"
use "url"

// ── json_pretty tests ─────────────────────────────────────

fn test_json_pretty_basic()
  let mut m = map()
  map_set(m, "name", "octo")
  let out = json_pretty(m)
  assert(contains(out, "name") == 1.0, "json_pretty contains key")
  assert(contains(out, "octo") == 1.0, "json_pretty contains value")
  print("PASS: test_json_pretty_basic")
  return 0.0
end

fn test_json_pretty_empty_map()
  let mut m = map()
  let out = json_pretty(m)
  assert(len(out) >= 0.0, "json_pretty empty map returns string")
  print("PASS: test_json_pretty_empty_map")
  return 0.0
end

// ── json_merge tests ──────────────────────────────────────

fn test_json_merge_basic()
  let mut a = map()
  map_set(a, "x", "1")
  map_set(a, "y", "2")
  let mut b = map()
  map_set(b, "y", "99")
  map_set(b, "z", "3")
  let merged = json_merge(a, b)
  assert(map_get(merged, "x") == "1", "merge keeps a.x")
  assert(map_get(merged, "y") == "99", "merge b overrides a.y")
  assert(map_get(merged, "z") == "3", "merge keeps b.z")
  print("PASS: test_json_merge_basic")
  return 0.0
end

fn test_json_merge_empty_a()
  let mut a = map()
  let mut b = map()
  map_set(b, "only", "b")
  let merged = json_merge(a, b)
  assert(map_get(merged, "only") == "b", "merge empty a uses b")
  print("PASS: test_json_merge_empty_a")
  return 0.0
end

fn test_json_merge_empty_b()
  let mut a = map()
  map_set(a, "only", "a")
  let mut b = map()
  let merged = json_merge(a, b)
  assert(map_get(merged, "only") == "a", "merge empty b uses a")
  print("PASS: test_json_merge_empty_b")
  return 0.0
end

fn test_json_merge_no_clobber()
  let mut a = map()
  map_set(a, "keep", "original")
  let mut b = map()
  map_set(b, "new", "added")
  let merged = json_merge(a, b)
  assert(map_get(merged, "keep") == "original", "merge preserves non-overlapping a")
  assert(map_get(merged, "new") == "added", "merge adds b key")
  print("PASS: test_json_merge_no_clobber")
  return 0.0
end

// ── json_get tests ────────────────────────────────────────

fn test_json_get_exists()
  let mut m = map()
  map_set(m, "color", "red")
  let val = json_get(m, "color", "blue")
  assert(val == "red", "json_get returns existing value")
  print("PASS: test_json_get_exists")
  return 0.0
end

fn test_json_get_missing()
  let mut m = map()
  let val = json_get(m, "missing", "fallback")
  assert(val == "fallback", "json_get returns default for missing")
  print("PASS: test_json_get_missing")
  return 0.0
end

fn test_json_get_empty_default()
  let mut m = map()
  let val = json_get(m, "nope", "")
  assert(val == "", "json_get returns empty default")
  print("PASS: test_json_get_empty_default")
  return 0.0
end

// ── json_flatten tests ────────────────────────────────────

fn test_json_flatten_basic()
  let mut m = map()
  map_set(m, "name", "flow")
  map_set(m, "ver", "1")
  let flat = json_flatten(m, "app.")
  assert(map_get(flat, "app.name") == "flow", "flatten prefixes name")
  assert(map_get(flat, "app.ver") == "1", "flatten prefixes ver")
  print("PASS: test_json_flatten_basic")
  return 0.0
end

fn test_json_flatten_empty_prefix()
  let mut m = map()
  map_set(m, "key", "val")
  let flat = json_flatten(m, "")
  assert(map_get(flat, "key") == "val", "flatten empty prefix keeps key")
  print("PASS: test_json_flatten_empty_prefix")
  return 0.0
end

fn test_json_flatten_single_key()
  let mut m = map()
  map_set(m, "x", "42")
  let flat = json_flatten(m, "ns_")
  assert(map_get(flat, "ns_x") == "42", "flatten single key")
  print("PASS: test_json_flatten_single_key")
  return 0.0
end

// ── url_parse tests ───────────────────────────────────────

fn test_url_parse_full()
  let r = url_parse("https://example.com/path/to/page?q=hello")
  assert(map_get(r, "protocol") == "https", "parse full protocol")
  assert(map_get(r, "host") == "example.com", "parse full host")
  assert(map_get(r, "path") == "/path/to/page", "parse full path")
  assert(map_get(r, "query") == "q=hello", "parse full query")
  print("PASS: test_url_parse_full")
  return 0.0
end

fn test_url_parse_no_query()
  let r = url_parse("http://localhost/index")
  assert(map_get(r, "protocol") == "http", "parse no-query protocol")
  assert(map_get(r, "host") == "localhost", "parse no-query host")
  assert(map_get(r, "path") == "/index", "parse no-query path")
  print("PASS: test_url_parse_no_query")
  return 0.0
end

fn test_url_parse_no_path()
  let r = url_parse("https://api.example.com")
  assert(map_get(r, "protocol") == "https", "parse no-path protocol")
  assert(map_get(r, "host") == "api.example.com", "parse no-path host")
  assert(map_get(r, "path") == "/", "parse no-path defaults to /")
  print("PASS: test_url_parse_no_path")
  return 0.0
end

fn test_url_parse_no_protocol()
  let r = url_parse("just-a-host")
  assert(map_get(r, "protocol") == "", "parse no-protocol empty")
  assert(map_get(r, "host") == "just-a-host", "parse no-protocol host")
  assert(map_get(r, "path") == "/", "parse no-protocol path /")
  print("PASS: test_url_parse_no_protocol")
  return 0.0
end

fn test_url_parse_with_port()
  let r = url_parse("http://localhost:8080/api/v1")
  assert(map_get(r, "host") == "localhost:8080", "parse with port host")
  assert(map_get(r, "path") == "/api/v1", "parse with port path")
  print("PASS: test_url_parse_with_port")
  return 0.0
end

// ── build_url tests ───────────────────────────────────────

fn test_build_url_full()
  let u = build_url("https", "example.com", "/search", "q=test")
  assert(u == "https://example.com/search?q=test", "build full URL")
  print("PASS: test_build_url_full")
  return 0.0
end

fn test_build_url_no_query()
  let u = build_url("http", "localhost", "/index", "")
  assert(u == "http://localhost/index", "build URL no query")
  print("PASS: test_build_url_no_query")
  return 0.0
end

fn test_build_url_root()
  let u = build_url("https", "api.test.io", "/", "")
  assert(u == "https://api.test.io/", "build URL root path")
  print("PASS: test_build_url_root")
  return 0.0
end

// ── url_encode tests ──────────────────────────────────────

fn test_url_encode_plain()
  assert(url_encode("hello") == "hello", "url_encode plain text")
  print("PASS: test_url_encode_plain")
  return 0.0
end

fn test_url_encode_spaces()
  assert(url_encode("hello world") == "hello%20world", "url_encode spaces")
  print("PASS: test_url_encode_spaces")
  return 0.0
end

fn test_url_encode_empty()
  assert(url_encode("") == "", "url_encode empty string")
  print("PASS: test_url_encode_empty")
  return 0.0
end

fn test_url_encode_unreserved()
  assert(url_encode("Az09-_.~") == "Az09-_.~", "url_encode unreserved chars pass through")
  print("PASS: test_url_encode_unreserved")
  return 0.0
end

// ── query_string tests ────────────────────────────────────

fn test_query_string_single()
  let mut p = map()
  map_set(p, "key", "value")
  let qs = query_string(p)
  assert(qs == "key=value", "query_string single param")
  print("PASS: test_query_string_single")
  return 0.0
end

fn test_query_string_encodes_values()
  let mut p = map()
  map_set(p, "q", "hello world")
  let qs = query_string(p)
  assert(qs == "q=hello%20world", "query_string encodes spaces")
  print("PASS: test_query_string_encodes_values")
  return 0.0
end

// ── roundtrip tests ───────────────────────────────────────

fn test_roundtrip_url()
  let original = build_url("https", "example.com", "/api/data", "page=1")
  let parsed = url_parse(original)
  let rebuilt = build_url(map_get(parsed, "protocol"), map_get(parsed, "host"), map_get(parsed, "path"), map_get(parsed, "query"))
  assert(rebuilt == original, "build -> parse -> build roundtrip")
  print("PASS: test_roundtrip_url")
  return 0.0
end

fn test_merge_then_flatten()
  let mut a = map()
  map_set(a, "x", "1")
  let mut b = map()
  map_set(b, "y", "2")
  let merged = json_merge(a, b)
  let flat = json_flatten(merged, "cfg.")
  assert(map_get(flat, "cfg.x") == "1", "merge then flatten x")
  assert(map_get(flat, "cfg.y") == "2", "merge then flatten y")
  print("PASS: test_merge_then_flatten")
  return 0.0
end
