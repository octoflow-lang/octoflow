// stdlib/array_utils.flow — Array utility functions
//
// Functions: arr_contains, arr_index_of, arr_sum, arr_avg, arr_min, arr_max,
//            arr_swap, arr_reverse, arr_fill, arr_search, arr_sort, arr_slice,
//            arr_unique, arr_flatten, arr_zip, arr_count
//
// Legacy aliases kept for compatibility: index_of, swap, reverse, fill, binary_search

fn arr_contains(arr, val)
  for x in arr
    if x == val
      return 1.0
    end
  end
  return 0.0
end

fn index_of(arr, val)
  let mut i = 0.0
  for x in arr
    if x == val
      return i
    end
    i = i + 1.0
  end
  return -1.0
end

fn arr_sum(arr)
  let mut total = 0.0
  for x in arr
    total = total + x
  end
  return total
end

fn arr_avg(arr)
  let mut total = 0.0
  for x in arr
    total = total + x
  end
  return total / len(arr)
end

fn arr_min(arr)
  let mut result = arr[0]
  for x in arr
    if x < result
      result = x
    end
  end
  return result
end

fn arr_max(arr)
  let mut result = arr[0]
  for x in arr
    if x > result
      result = x
    end
  end
  return result
end

fn swap(arr, i, j)
  let tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
  return 0.0
end

fn reverse(arr)
  let n = len(arr)
  let half = floor(n / 2.0)
  for i in range(0, half)
    let j = n - 1.0 - i
    let tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
  end
  return 0.0
end

fn fill(arr, val)
  let n = len(arr)
  for i in range(0, n)
    arr[i] = val
  end
  return 0.0
end

fn binary_search(arr, target)
  let mut lo = 0.0
  let mut hi = len(arr) - 1.0
  for i in range(0, 30)
    if lo > hi
      return -1.0
    end
    let mid = floor((lo + hi) / 2.0)
    if arr[mid] == target
      return mid
    end
    if arr[mid] < target
      lo = mid + 1.0
    end
    if arr[mid] > target
      hi = mid - 1.0
    end
  end
  return -1.0
end

fn arr_sort(arr)
  // In-place insertion sort (convenience wrapper)
  let n = len(arr)
  let mut i = 1.0
  while i < n
    let key = arr[i]
    let mut j = i - 1.0
    while j >= 0.0
      if arr[j] > key
        arr[j + 1.0] = arr[j]
        j = j - 1.0
      else
        break
      end
    end
    arr[j + 1.0] = key
    i = i + 1.0
  end
  return arr
end

fn arr_slice(arr, start, stop)
  let n = len(arr)
  let mut s = start
  let mut e = stop
  if s < 0.0
    s = 0.0
  end
  if e > n
    e = n
  end
  let mut result = []
  let mut i = s
  while i < e
    push(result, arr[i])
    i = i + 1.0
  end
  return result
end

fn arr_unique(arr)
  let mut seen = map()
  let mut result = []
  for x in arr
    let key = str(x)
    if map_has(seen, key) == 0.0
      map_set(seen, key, "1")
      push(result, x)
    end
  end
  return result
end

fn arr_flatten(arr)
  // Flatten one level: [[1,2],[3,4]] -> [1,2,3,4]
  // In OctoFlow arrays can't nest, so this flattens a "list of arrays"
  // passed as a single array with a separator convention.
  // For practical use: concatenate multiple arrays into one.
  // Usage: let flat = arr_flatten(combined) where combined has all elements
  let mut result = []
  for x in arr
    push(result, x)
  end
  return result
end

fn arr_zip(a, b)
  // Interleave two arrays: [1,2,3] + [4,5,6] -> [1,4,2,5,3,6]
  let n = len(a)
  let m = len(b)
  let mut mn = n
  if m < mn
    mn = m
  end
  let mut result = []
  let mut i = 0.0
  while i < mn
    push(result, a[i])
    push(result, b[i])
    i = i + 1.0
  end
  return result
end

fn arr_count(arr, val)
  let mut c = 0.0
  for x in arr
    if x == val
      c = c + 1.0
    end
  end
  return c
end

// ── Prefixed aliases (preferred over bare names) ────────────
fn arr_index_of(arr, val)
  return index_of(arr, val)
end

fn arr_swap(arr, i, j)
  return swap(arr, i, j)
end

fn arr_reverse(arr)
  return reverse(arr)
end

fn arr_fill(arr, val)
  return fill(arr, val)
end

fn arr_search(arr, target)
  return binary_search(arr, target)
end
