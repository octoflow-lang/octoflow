// boot_once.flow — Boot Once GPU Runtime: Loom API
//
// 200 sequential GPU doublings via the Loom VM.
// Each dispatch reads the previous output — sequential dependency.
//
// Verification is BIT-EXACT: 2^(-100) is an exact IEEE 754 value (power of 2,
// no mantissa rounding). Each multiply-by-2 increments the exponent — zero
// floating-point ambiguity. 2^100 fits within f32 range.
//
// Architecture:
//   Language → IR → SPIR-V      (compute)
//   Language → Loom VM           (scheduling)
//   = GPU orchestration via Loom.
//
// Run: octoflow run examples/boot_once.flow --allow-ffi --allow-read

let N = 256.0
let NUM_DISPATCHES = 200.0

// Boot GPU (single init)
let vm = loom_boot(1.0, 2.0, N)
loom_prefetch("tests/gpu_shaders/01_double.spv")

// Start value: 2^(-100) — exact in IEEE 754 (power of 2, no mantissa rounding)
let start_val = pow(2.0, -100.0)
let mut data = []
let mut i = 0.0
while i < N
  push(data, start_val)
  i = i + 1.0
end
vm_write_register(vm, 0.0, 0.0, data)

let mut zeros = []
let mut i = 0.0
while i < N
  push(zeros, 0.0)
  i = i + 1.0
end
vm_write_register(vm, 0.0, 1.0, zeros)

// ── 200 sequential dispatches (ping-pong) ─────────────────────────
let t0 = time()

let mut d = 0.0
while d < NUM_DISPATCHES
  loom_dispatch(vm, "tests/gpu_shaders/01_double.spv", [], 1.0)
  let prog = loom_build(vm)
  loom_run(prog)
  loom_free(prog)

  // Ping-pong: read output (register 1), write back to input (register 0)
  let result = loom_read(vm, 0.0, 1.0, N)
  vm_write_register(vm, 0.0, 0.0, result)

  d = d + 1.0
end

let t1 = time()
let total_ms = (t1 - t0) * 1000.0

// ── Verify result (bit-exact) ─────────────────────────────────────
// 200 dispatches: 2^(-100) * 2^200 = 2^100 — exact in IEEE 754
let final_data = loom_read(vm, 0.0, 0.0, N)
let expected = pow(2.0, 100.0)
let actual = final_data[0]

print("")
print("OctoFlow GPU — Boot Once (Loom API)")
print("  Dispatches:  {NUM_DISPATCHES} (sequential, each depends on previous)")
print("  Total time:  {total_ms} ms")
print("  Input:       2^(-100) = {start_val}")
print("  Expected:    2^(100)  = {expected}")
print("  Actual:      {actual}")

if actual == expected
  print("  EXACT MATCH")
else
  let diff = abs(actual - expected)
  let rel = diff / expected
  print("  MISMATCH: relative error = {rel}")
end

print("")
loom_shutdown(vm)
