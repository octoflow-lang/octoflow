// gpu_scan.flow — GPU Prefix Sum (Multi-Pass Scan)
//
// "65536 elements. Inclusive prefix sum. 3-pass pipeline. 0 CPU additions."
//
// Multi-pass Blelloch scan:
//   Pass 1: Scan each 512-element block independently (128 workgroups)
//   Pass 2: Extract & scan the 128 block totals (1 workgroup)
//   Pass 3: Add scanned block totals back to each block (fixup)
//
// Run: octoflow run examples/gpu_scan.flow --allow-ffi --allow-read

let N = 65536.0
let BLOCK = 512.0
let N_BLOCKS = N / BLOCK

let vm = loom_boot(1.0, 2.0, N)
loom_prefetch("tests/gpu_shaders/32_scan_sum.spv")
loom_prefetch("tests/gpu_shaders/33_scan_add_offset.spv")

// ── Input: [1, 1, 1, ..., 1] — prefix sum should give [1, 2, 3, ..., N] ──
let mut input = []
let mut i = 0.0
while i < N
  push(input, 1.0)
  i = i + 1.0
end
vm_write_register(vm, 0.0, 0.0, input)

let mut zeros = []
let mut i = 0.0
while i < N
  push(zeros, 0.0)
  i = i + 1.0
end
vm_write_register(vm, 0.0, 1.0, zeros)

// ── Pass 1: Scan each block independently ────────────────────────────
let t0 = time()

loom_dispatch(vm, "tests/gpu_shaders/32_scan_sum.spv", [N], N_BLOCKS)
let prog1 = loom_build(vm)
loom_run(prog1)
loom_free(prog1)

// ── Extract block totals (last element of each scanned block) ────────
let scanned = loom_read(vm, 0.0, 1.0, N)

let mut totals = []
let mut k = 0.0
while k < N_BLOCKS
  let idx = k * BLOCK + BLOCK - 1.0
  push(totals, scanned[int(idx)])
  k = k + 1.0
end

// Pad totals to BLOCK size
let mut i = N_BLOCKS
while i < BLOCK
  push(totals, 0.0)
  i = i + 1.0
end

// ── Pass 2: Scan the block totals ────────────────────────────────────
let vm2 = loom_boot(1.0, 2.0, BLOCK)
vm_write_register(vm2, 0.0, 0.0, totals)

let mut zeros_small = []
let mut i = 0.0
while i < BLOCK
  push(zeros_small, 0.0)
  i = i + 1.0
end
vm_write_register(vm2, 0.0, 1.0, zeros_small)

loom_dispatch(vm2, "tests/gpu_shaders/32_scan_sum.spv", [N_BLOCKS], 1.0)
let prog2 = loom_build(vm2)
loom_run(prog2)
loom_free(prog2)

let scanned_totals = loom_read(vm2, 0.0, 1.0, BLOCK)
loom_shutdown(vm2)

// ── Pass 3: Add scanned totals back to each block ────────────────────
// Write scanned_totals into register 0 of a fixup VM, scanned data in register 1
// But the fixup shader reads from binding 0 (scanned data) and binding 1 (totals)
let vm3 = loom_boot(1.0, 2.0, N)
vm_write_register(vm3, 0.0, 0.0, scanned)
// Pad scanned_totals to N size (each block reads its total)
let mut totals_expanded = []
let mut bi = 0.0
while bi < N
  let block_idx = floor(bi / BLOCK)
  push(totals_expanded, scanned_totals[int(block_idx)])
  bi = bi + 1.0
end
vm_write_register(vm3, 0.0, 1.0, totals_expanded)

loom_dispatch(vm3, "tests/gpu_shaders/33_scan_add_offset.spv", [N], N / 256.0)
let prog3 = loom_build(vm3)
loom_run(prog3)
loom_free(prog3)

let t1 = time()
let total_ms = (t1 - t0) * 1000.0

// ── Verify ───────────────────────────────────────────────────────────
// Read from register 0 (fixup overwrites in-place on binding 0)
let final_scan = loom_read(vm3, 0.0, 0.0, N)
loom_shutdown(vm3)

let v0 = final_scan[0]
let v511 = final_scan[511]
let v512 = final_scan[512]
let v1023 = final_scan[1023]
let vlast = final_scan[int(N - 1.0)]

let mut pass = 1.0

if v0 != 1.0
  print("FAIL: element 0 = {v0}, expected 1")
  pass = 0.0
end
if v511 != 512.0
  print("FAIL: element 511 = {v511}, expected 512")
  pass = 0.0
end
if v512 != 513.0
  print("FAIL: element 512 = {v512}, expected 513")
  pass = 0.0
end
if v1023 != 1024.0
  print("FAIL: element 1023 = {v1023}, expected 1024")
  pass = 0.0
end
if vlast != N
  print("FAIL: element {N}-1 = {vlast}, expected {N}")
  pass = 0.0
end

// Spot check: every 1000th element
let mut spot_pass = 1.0
let mut i = 0.0
while i < N
  let got = final_scan[int(i)]
  let exp = i + 1.0
  if got != exp
    spot_pass = 0.0
  end
  i = i + 1000.0
end

// ── Report ───────────────────────────────────────────────────────────
print("")
print("OctoFlow GPU Prefix Sum (Multi-Pass Scan)")
print("  Elements: {N}")
print("  Block size: {BLOCK}")
print("  Blocks: {N_BLOCKS}")
print("  Passes: 3 (block scan + total scan + fixup)")
print("  CPU additions: 0")
print("  Total time: {total_ms} ms")
print("")
print("  Verification:")
print("    scan[0] = {v0} (expected 1)")
print("    scan[511] = {v511} (expected 512)")
print("    scan[512] = {v512} (expected 513)")
print("    scan[1023] = {v1023} (expected 1024)")
print("    scan[65535] = {vlast} (expected 65536)")
print("    Spot check (every 1000): {spot_pass}")

if pass == 1.0
  if spot_pass == 1.0
    print("  PASS: {N}-element multi-pass prefix sum BIT EXACT")
  else
    print("  FAIL: spot check failed")
  end
else
  print("  FAIL: boundary check failed")
end

print("")
loom_shutdown(vm)
