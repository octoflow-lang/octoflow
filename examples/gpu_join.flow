// gpu_join.flow — GPU Broadcast Join: Dimension Table Lookup
//
// "Two tables. Zero CPU row iteration."
//
// 65,536 employees joined with 8-row department table on GPU.
// Broadcast join + reduce for aggregate computation.
//
// SQL equivalent:
//   SELECT SUM(e.salary + d.bonus) AS total_comp
//   FROM employees e
//   JOIN departments d ON e.dept_id = d.dept_id
//
// GPU broadcast join:
//   For each dept d with bonus_d:
//     [eq_scalar: dept==d → mask] → [fma_scalar: bonus_col += mask * bonus_d]
//   [add_ab: salary + bonus_col → total_comp]
//   [reduce: SUM(total_comp)]
//
// Run: octoflow run examples/gpu_join.flow --allow-ffi --allow-read

let N = 65536.0
let K = 8.0
let GROUP_SIZE = N / K
let WG_SIZE = 256.0
let NUM_WG = N / WG_SIZE

// ── Boot VMs for each shader type ────────────────────────────────────
// eq_scalar: 2 bindings (dept, mask), 1 push constant
let vm_eq = loom_boot(1.0, 2.0, N)
// fma_scalar: 2 bindings (mask, bonus), 1 push constant
let vm_fma = loom_boot(1.0, 2.0, N)
// add_ab: 3 bindings (salary, bonus, total)
let vm_add = loom_boot(1.0, 3.0, N)
// reduce pass 1: 2 bindings (total, partial)
let vm_r1 = loom_boot(1.0, 2.0, N)
// reduce pass 2: 2 bindings (partial, result)
let vm_r2 = loom_boot(1.0, 2.0, NUM_WG)

loom_prefetch("tests/gpu_shaders/17_eq_scalar.spv")
loom_prefetch("tests/gpu_shaders/21_fma_scalar.spv")
loom_prefetch("tests/gpu_shaders/20_add_ab.spv")
loom_prefetch("stdlib/loom/kernels/reduce/reduce_sum.spv")

// Upload employee data: dept[i] = floor(i/8192), salary[i] = i + 1
let mut depts = []
let mut salaries = []
let mut i = 0.0
while i < N
  push(depts, floor(i / GROUP_SIZE))
  push(salaries, i + 1.0)
  i = i + 1.0
end
vm_write_register(vm_eq, 0.0, 0.0, depts)
vm_write_register(vm_add, 0.0, 0.0, salaries)

// Zero working arrays
let mut zeros = []
let mut i = 0.0
while i < N
  push(zeros, 0.0)
  i = i + 1.0
end

// Initialize bonus accumulator
let mut bonus_col = []
let mut i = 0.0
while i < N
  push(bonus_col, 0.0)
  i = i + 1.0
end

// Department dimension table (8 departments)
let mut bonuses = [500.0, 1000.0, 1500.0, 2000.0, 2500.0, 3000.0, 3500.0, 4000.0]

// ── Broadcast join: eq + fma for each department ─────────────────────
let t0 = time()

let mut g = 0.0
while g < K
  // eq_scalar: dept == g → mask
  vm_write_register(vm_eq, 0.0, 1.0, zeros)
  loom_dispatch(vm_eq, "tests/gpu_shaders/17_eq_scalar.spv", [g], NUM_WG)
  let p_eq = loom_build(vm_eq)
  loom_run(p_eq)
  loom_free(p_eq)
  let mask = loom_read(vm_eq, 0.0, 1.0, N)

  // fma_scalar: bonus_col += mask * bonus_d
  let bonus_d = bonuses[int(g)]
  vm_write_register(vm_fma, 0.0, 0.0, mask)
  vm_write_register(vm_fma, 0.0, 1.0, bonus_col)
  loom_dispatch(vm_fma, "tests/gpu_shaders/21_fma_scalar.spv", [bonus_d], NUM_WG)
  let p_fma = loom_build(vm_fma)
  loom_run(p_fma)
  loom_free(p_fma)
  // Read updated bonus_col back — need fresh let each iteration
  let bc = loom_read(vm_fma, 0.0, 1.0, N)
  // Copy to bonus_col for next iteration — but can't reassign array...
  // Instead, write updated bonus_col back to vm_fma reg 1 for next fma
  // and also keep a reference for the add step
  vm_write_register(vm_fma, 0.0, 1.0, bc)

  g = g + 1.0
end

// Read final bonus_col
let final_bonus = loom_read(vm_fma, 0.0, 1.0, N)

// ── Combine: total_comp = salary + bonus ─────────────────────────────
vm_write_register(vm_add, 0.0, 1.0, final_bonus)
vm_write_register(vm_add, 0.0, 2.0, zeros)
loom_dispatch(vm_add, "tests/gpu_shaders/20_add_ab.spv", [], NUM_WG)
let p_add = loom_build(vm_add)
loom_run(p_add)
loom_free(p_add)
let total_comp = loom_read(vm_add, 0.0, 2.0, N)

// ── Reduce: SUM(total_comp) ──────────────────────────────────────────
vm_write_register(vm_r1, 0.0, 0.0, total_comp)
let mut pz = []
let mut i = 0.0
while i < NUM_WG
  push(pz, 0.0)
  i = i + 1.0
end
vm_write_register(vm_r1, 0.0, 1.0, pz)

loom_dispatch(vm_r1, "stdlib/loom/kernels/reduce/reduce_sum.spv", [], NUM_WG)
let p_r1 = loom_build(vm_r1)
loom_run(p_r1)
loom_free(p_r1)
let partial = loom_read(vm_r1, 0.0, 1.0, NUM_WG)

vm_write_register(vm_r2, 0.0, 0.0, partial)
let mut rz = [0.0]
vm_write_register(vm_r2, 0.0, 1.0, rz)

loom_dispatch(vm_r2, "stdlib/loom/kernels/reduce/reduce_sum.spv", [], 1.0)
let p_r2 = loom_build(vm_r2)
loom_run(p_r2)
loom_free(p_r2)

let t1 = time()
let total_ms = (t1 - t0) * 1000.0

// ── Download result ──────────────────────────────────────────────────
let gpu_result = loom_read(vm_r2, 0.0, 1.0, 1.0)
let gpu_total = gpu_result[0]

// CPU verification
let exp_salary_sum = N * (N + 1.0) / 2.0
let bonus_sum_scalar = 500.0 + 1000.0 + 1500.0 + 2000.0 + 2500.0 + 3000.0 + 3500.0 + 4000.0
let exp_bonus_sum = GROUP_SIZE * bonus_sum_scalar
let exp_total = exp_salary_sum + exp_bonus_sum
let avg_comp = gpu_total / N

let rel_err = abs(gpu_total - exp_total) / exp_total

print("")
print("OctoFlow GPU Broadcast Join")
print("  Fact table:      {N} employees (dept_id, salary)")
print("  Dimension table: {K} departments (dept_id, bonus)")
print("  Query: SELECT SUM(salary + bonus) FROM employees JOIN departments")
print("  CPU row iterations: 0")
print("  Total time: {total_ms} ms")
print("")
print("  SUM(total_comp): {gpu_total}")
print("  Expected:        {exp_total}")
print("  AVG(total_comp): {avg_comp}")
print("  Relative error:  {rel_err}")

if rel_err < 0.001
  print("  MATCH (within 0.1%)")
else
  print("  MISMATCH")
end

print("")
loom_shutdown(vm_eq)
loom_shutdown(vm_fma)
loom_shutdown(vm_add)
loom_shutdown(vm_r1)
loom_shutdown(vm_r2)
