// gpu_argminmax.flow — GPU Argmin/Argmax (65536 elements, 2-pass reduction)
//
// "65536 elements. Find min and max with indices. 4 dispatches. 0 CPU comparisons."
//
// Multi-pass reduction: Pass 1 reduces 65536→256 partial results,
// Pass 2 reduces 256→1. Tracks both value and index.
//
// Run: octoflow run examples/gpu_argminmax.flow --allow-ffi --allow-read

use "../stdlib/loom/ops/runtime"

let N = 65536.0

rt_init()

let pipe_argmin = rt_load_pipeline("tests/gpu_shaders/37_argmin.spv", 3.0, 4.0)
let pipe_argmax = rt_load_pipeline("tests/gpu_shaders/38_argmax.spv", 3.0, 4.0)

// ── Input: [N, N-1, ..., 2, 1] — min=1.0 at index N-1, max=N at index 0 ──
let mut input = []
let mut i = 0.0
while i < N
  push(input, N - i)
  i = i + 1.0
end

let buf_in = rt_create_buffer(N * 4.0)
rt_upload(buf_in, input)

let n_wgs1 = int((N + 255.0) / 256.0)
let n_wgs2 = 1.0

// Intermediate buffers for pass 1 (256 partial results)
let buf_min_val1 = rt_create_buffer(n_wgs1 * 4.0)
let buf_min_idx1 = rt_create_buffer(n_wgs1 * 4.0)
let buf_max_val1 = rt_create_buffer(n_wgs1 * 4.0)
let buf_max_idx1 = rt_create_buffer(n_wgs1 * 4.0)

// Final result buffers (1 value each)
let buf_min_val2 = rt_create_buffer(4.0)
let buf_min_idx2 = rt_create_buffer(4.0)
let buf_max_val2 = rt_create_buffer(4.0)
let buf_max_idx2 = rt_create_buffer(4.0)

// ── Pass 1: Reduce 65536 → 256 partial results ────────────────────
let t0 = time()

rt_chain_begin(2.0, 3.0)
let mut pc1 = [N]
rt_chain_push_constants(pipe_argmin, pc1)
let mut bufs_min1 = [buf_in, buf_min_val1, buf_min_idx1]
rt_chain_dispatch(pipe_argmin, bufs_min1, n_wgs1)
rt_chain_push_constants(pipe_argmax, pc1)
let mut bufs_max1 = [buf_in, buf_max_val1, buf_max_idx1]
rt_chain_dispatch(pipe_argmax, bufs_max1, n_wgs1)
rt_chain_end()
rt_chain_submit_wait()

// ── Pass 2: Reduce 256 → 1 final result ───────────────────────────
rt_chain_begin(2.0, 3.0)
let mut pc2 = [n_wgs1]
rt_chain_push_constants(pipe_argmin, pc2)
let mut bufs_min2 = [buf_min_val1, buf_min_val2, buf_min_idx2]
rt_chain_dispatch(pipe_argmin, bufs_min2, n_wgs2)
rt_chain_push_constants(pipe_argmax, pc2)
let mut bufs_max2 = [buf_max_val1, buf_max_val2, buf_max_idx2]
rt_chain_dispatch(pipe_argmax, bufs_max2, n_wgs2)
rt_chain_end()
rt_chain_submit_wait()

let t1 = time()
let total_ms = (t1 - t0) * 1000.0

// ── Download results ───────────────────────────────────────────────
rt_download(buf_min_val2, 1.0)
let min_val = rt_result[0]
rt_download(buf_min_idx2, 1.0)
let min_idx_raw = rt_result[0]
rt_download(buf_max_val2, 1.0)
let max_val = rt_result[0]
rt_download(buf_max_idx2, 1.0)
let max_idx_raw = rt_result[0]

// Pass 2 operates on the 256 partial values/indices from pass 1.
// The argmin pass 2 input is buf_min_val1 (the 256 partial minimums).
// Its output index is the INDEX within those 256 partials (0-255),
// not the original global index. We need to look up the original index.
// Download the partial indices from pass 1 at the position found by pass 2.
rt_download(buf_min_idx1, n_wgs1)
let min_idx = rt_result[int(min_idx_raw)]
rt_download(buf_max_idx1, n_wgs1)
let max_idx = rt_result[int(max_idx_raw)]

// ── Verify ─────────────────────────────────────────────────────────
let mut pass = 1.0
let exp_min_val = 1.0
let exp_min_idx = N - 1.0
let exp_max_val = N
let exp_max_idx = 0.0

if min_val != exp_min_val
  print("FAIL: min_val={min_val}, expected {exp_min_val}")
  pass = 0.0
end
if min_idx != exp_min_idx
  print("FAIL: min_idx={min_idx}, expected {exp_min_idx}")
  pass = 0.0
end
if max_val != exp_max_val
  print("FAIL: max_val={max_val}, expected {exp_max_val}")
  pass = 0.0
end
if max_idx != exp_max_idx
  print("FAIL: max_idx={max_idx}, expected {exp_max_idx}")
  pass = 0.0
end

// ── Report ─────────────────────────────────────────────────────────
print("")
print("OctoFlow GPU Argmin/Argmax")
print("  Elements: {N}")
print("  Passes: 2 (65536 -> 256 -> 1)")
print("  Dispatches: 4 (2×argmin + 2×argmax)")
print("  Submissions: 2")
print("  CPU comparisons: 0")
print("  Total time: {total_ms} ms")
print("")
print("  Results:")
print("    min_value = {min_val} at index {min_idx}")
print("    max_value = {max_val} at index {max_idx}")

if pass == 1.0
  print("  PASS: {N}-element argmin/argmax BIT EXACT")
else
  print("  FAIL: see errors above")
end

print("")
rt_cleanup()
