// indirect_dispatch.flow — GPU Self-Scheduling Demo
//
// Two-phase pipeline:
//   Phase 1: GPU reads data, computes workgroup count, writes to output.
//   Phase 2: GPU doubles all elements with the computed workgroup count.
//
// Verification is BIT-EXACT: input [1, 2, 3, ..., 256] doubled = [2, 4, 6, ..., 512].
// Integer values within f32 range — zero floating-point ambiguity.
//
// Architecture:
//   Language → IR → SPIR-V (compute: what to do)
//   Language → Loom VM (scheduling: dispatch + build + run)
//
// Run: octoflow run examples/indirect_dispatch.flow --allow-ffi --allow-read

let N = 256.0

let vm_set = loom_boot(1.0, 2.0, N)
let vm_double = loom_boot(1.0, 2.0, N)
loom_prefetch("tests/gpu_shaders/12_set_dispatch.spv")
loom_prefetch("tests/gpu_shaders/01_double.spv")

// Upload data: [256.0, 2.0, 3.0, ..., 256.0]
// data[0] = 256.0 is the element count
let mut data = []
push(data, N)
let mut i = 1.0
while i < N
  push(data, i + 1.0)
  i = i + 1.0
end
vm_write_register(vm_set, 0.0, 0.0, data)
vm_write_register(vm_double, 0.0, 0.0, data)

// Zero output registers
let mut zeros = []
let mut i = 0.0
while i < N
  push(zeros, 0.0)
  i = i + 1.0
end
vm_write_register(vm_set, 0.0, 1.0, zeros)
vm_write_register(vm_double, 0.0, 1.0, zeros)

// ── Phase 1: Compute workgroup count ────────────────────────────────
let t0 = time()

loom_dispatch(vm_set, "tests/gpu_shaders/12_set_dispatch.spv", [], 1.0)
let p1 = loom_build(vm_set)
loom_run(p1)
loom_free(p1)

// Read computed workgroup count from output
let wg_result = loom_read(vm_set, 0.0, 1.0, 3.0)
let computed_wgs = wg_result[0]

// ── Phase 2: Double all elements using computed workgroup count ──────
loom_dispatch(vm_double, "tests/gpu_shaders/01_double.spv", [], computed_wgs)
let p2 = loom_build(vm_double)
loom_run(p2)
loom_free(p2)

let t1 = time()
let total_ms = (t1 - t0) * 1000.0

// ── Verify result (bit-exact) ────────────────────────────────────────
let result = loom_read(vm_double, 0.0, 1.0, 4.0)

// data = [256, 2, 3, 4, ...] → doubled = [512, 4, 6, 8, ...]
let expected_0 = N * 2.0
let expected_1 = 4.0
let expected_2 = 6.0
let expected_3 = 8.0

let v0 = result[0]
let v1 = result[1]
let v2 = result[2]
let v3 = result[3]

print("")
print("OctoFlow GPU Self-Scheduling Demo (Loom API)")
print("  Pipeline:")
print("    Phase 1: GPU analyzes data[0]=256 -> computes workgroup count = {computed_wgs}")
print("    Phase 2: GPU doubles all elements with computed workgroups")
print("  Total time: {total_ms} ms")
print("  Result[0..3]: [{v0}, {v1}, {v2}, {v3}]")
print("  Expected:     [{expected_0}, {expected_1}, {expected_2}, {expected_3}]")

if v0 == expected_0
  if v1 == expected_1
    if v2 == expected_2
      if v3 == expected_3
        print("  EXACT MATCH")
      else
        print("  MISMATCH: v3 got {v3}, expected {expected_3}")
      end
    else
      print("  MISMATCH: v2 got {v2}, expected {expected_2}")
    end
  else
    print("  MISMATCH: v1 got {v1}, expected {expected_1}")
  end
else
  print("  MISMATCH: v0 got {v0}, expected {expected_0}")
end

print("")
loom_shutdown(vm_set)
loom_shutdown(vm_double)
