// ====================================================================
//  GPU VM STRESS TEST — Find maximum simultaneous VMs
//  Ramps up VM count: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024
//  Each VM: boot → write → dispatch(scale×2) → build → execute → read → verify → shutdown
//  Stops at first failure. Reports max working count.
// ====================================================================

print("")
print("====================================================================")
print("  GPU VM STRESS TEST — Maximum Simultaneous VMs")
print("====================================================================")
print("")
print("  Each VM: 1024-float register, scale×2 kernel, verify result")
print("  GPU: GTX 1660 SUPER (6GB VRAM)")
print("")

let kernel = "stdlib/loom/kernels/ops/vm_scale.spv"
let reg_size = 1024.0
let wg = floor((reg_size + 255.0) / 256.0)
let scale_pc = [0.0, 2.0, reg_size]

// Test data: [1.0, 2.0, 3.0, ... 1024.0]
let mut test_data = []
let mut ti = 0.0
while ti < reg_size
  push(test_data, ti + 1.0)
  ti = ti + 1.0
end

// Levels to test
let levels = [1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0]
let mut max_ok = 0.0
let mut li = 0.0

while li < len(levels)
  let n = levels[li]
  print("  Testing {n:.0} VMs...")

  let t0 = now_ms()

  // ── Phase 1: Boot all VMs ─────────────────────────────────────
  let mut vm_ids = []
  let mut boot_ok = 1.0
  let mut bi = 0.0
  while bi < n
    let r = try(vm_boot(1.0, reg_size, 1.0))
    if r.ok > 0.5
      push(vm_ids, r.value)
    else
      print("    BOOT FAILED at VM #{bi:.0}: {r.error}")
      boot_ok = 0.0
      bi = n
    end
    bi = bi + 1.0
  end

  if boot_ok < 0.5
    print("    Max before boot failure: {max_ok:.0}")
    // Shutdown any VMs that did boot
    let mut si = 0.0
    while si < len(vm_ids)
      let _s = vm_shutdown(vm_ids[si])
      si = si + 1.0
    end
    li = len(levels)
  else
    let t_boot = now_ms() - t0

    // ── Phase 2: Write data to all VMs ────────────────────────────
    let mut wi = 0.0
    while wi < n
      let _w = vm_write_register(vm_ids[wi], 0.0, 0.0, test_data)
      wi = wi + 1.0
    end
    let t_write = now_ms() - t0

    // ── Phase 3: Dispatch + Build all VMs ─────────────────────────
    let mut prog_ids = []
    let mut di = 0.0
    while di < n
      let _d = vm_dispatch(vm_ids[di], kernel, scale_pc, wg)
      let p = vm_build(vm_ids[di])
      push(prog_ids, p)
      di = di + 1.0
    end
    let t_build = now_ms() - t0

    // ── Phase 4: Execute all VMs ──────────────────────────────────
    let mut ei = 0.0
    while ei < n
      let _e = vm_execute(prog_ids[ei])
      ei = ei + 1.0
    end
    let t_exec = now_ms() - t0

    // ── Phase 5: Read + Verify all VMs ────────────────────────────
    let mut verify_ok = 1.0
    let mut mismatches = 0.0
    let mut ri = 0.0
    while ri < n
      let result = vm_read_register(vm_ids[ri], 0.0, 0.0, reg_size)
      // Spot-check first 4 values: expect [2, 4, 6, 8]
      if result[0] < 1.99 || result[0] > 2.01
        mismatches = mismatches + 1.0
        verify_ok = 0.0
      end
      if result[1] < 3.99 || result[1] > 4.01
        mismatches = mismatches + 1.0
        verify_ok = 0.0
      end
      if result[2] < 5.99 || result[2] > 6.01
        mismatches = mismatches + 1.0
        verify_ok = 0.0
      end
      if result[3] < 7.99 || result[3] > 8.01
        mismatches = mismatches + 1.0
        verify_ok = 0.0
      end
      ri = ri + 1.0
    end
    let t_verify = now_ms() - t0

    // ── Phase 6: Shutdown all VMs ─────────────────────────────────
    let mut si = 0.0
    while si < n
      let _s = vm_shutdown(vm_ids[si])
      si = si + 1.0
    end
    let t_total = now_ms() - t0

    if verify_ok > 0.5
      max_ok = n
      // Memory per VM: 32 regs × 1024 floats × 4 bytes = 128KB
      let mem_mb = n * 32.0 * reg_size * 4.0 / 1048576.0
      print("    PASS  {n:.0} VMs  |  {t_total:.0}ms total  |  boot:{t_boot:.0}ms  exec:{t_exec:.0}ms  |  ~{mem_mb:.0}MB VRAM")
    else
      print("    VERIFY FAILED  {mismatches:.0} mismatches across {n:.0} VMs")
      print("    Max verified: {max_ok:.0}")
      li = len(levels)
    end
  end

  li = li + 1.0
end

print("")
print("  ════════════════════════════════════════════")
print("  RESULT: Maximum simultaneous VMs = {max_ok:.0}")
print("  ════════════════════════════════════════════")
print("")

// ── Bonus: Chain depth test on single VM ──────────────────────────
print("  BONUS: Max dispatch chain depth (single VM, scale×2 repeated)")
print("")

let chain_levels = [10.0, 50.0, 100.0, 500.0, 1000.0, 2000.0, 5000.0]
let mut max_chain = 0.0
let mut ci = 0.0

while ci < len(chain_levels)
  let depth = chain_levels[ci]
  let t0c = now_ms()

  let vm = vm_boot(1.0, reg_size, 1.0)

  // Write [1.0, 1.0, 1.0, ...] — scale×2 repeated N times = 2^N
  let mut ones = []
  let mut oi = 0.0
  while oi < reg_size
    push(ones, 1.0)
    oi = oi + 1.0
  end
  let _w = vm_write_register(vm, 0.0, 0.0, ones)

  // Chain N dispatches
  let mut di = 0.0
  while di < depth
    let _d = vm_dispatch(vm, kernel, scale_pc, wg)
    di = di + 1.0
  end

  let prog = vm_build(vm)
  let r2 = try(vm_execute(prog))

  if r2.ok > 0.5
    let chain_result = vm_read_register(vm, 0.0, 0.0, 4.0)
    let _s = vm_shutdown(vm)
    let t_chain = now_ms() - t0c
    let val = chain_result[0]
    max_chain = depth
    print("    {depth:.0} dispatches → val={val:.0}  |  {t_chain:.0}ms  |  1 submit")
  else
    let _s = vm_shutdown(vm)
    print("    {depth:.0} dispatches → FAILED: {r2.error}")
    ci = len(chain_levels)
  end

  ci = ci + 1.0
end

print("")
print("  ════════════════════════════════════════════")
print("  RESULT: Maximum chain depth = {max_chain:.0} dispatches")
print("  ════════════════════════════════════════════")
print("")
