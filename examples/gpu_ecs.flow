// gpu_ecs.flow — GPU Entity Component System
//
// "4096 entities. 3 systems. 100 timesteps. 300 dispatches. 0 CPU entity iterations."
//
// Structure-of-Arrays memory layout:
//   Component arrays: pos_x[], pos_y[], vel_x[], vel_y[], alive[], grounded[]
//   Each system is one GPU dispatch over all entities.
//
// Systems (executed in order each frame):
//   1. Gravity: vel_y += gravity * dt (non-grounded entities)
//   2. Move:    pos += vel * dt (alive entities)
//   3. Bounce:  floor collision + restitution (alive entities)
//
// Run: octoflow run examples/gpu_ecs.flow --allow-ffi --allow-read

let N = 4096.0
let PAD = 4096.0
let STEPS = 100.0
let DT = 0.01
let GRAVITY = -9.81
let FLOOR = 0.0
let RESTIT = 0.7

// ── Initialize entities ──────────────────────────────────────────────
let mut pos_x = []
let mut pos_y = []
let mut vel_x = []
let mut vel_y = []
let mut alive_arr = []
let mut grounded_arr = []

let mut i = 0.0
while i < N
  let hx = i * 13.0 + 7.0
  let hx2 = hx - floor(hx / 97.0) * 97.0
  let px = (hx2 / 97.0 - 0.5) * 100.0

  let hy = i * 17.0 + 3.0
  let hy2 = hy - floor(hy / 89.0) * 89.0
  let py = (hy2 / 89.0) * 50.0 + 1.0

  let hv = i * 23.0 + 11.0
  let hv2 = hv - floor(hv / 83.0) * 83.0
  let vx = (hv2 / 83.0 - 0.5) * 10.0

  push(pos_x, px)
  push(pos_y, py)
  push(vel_x, vx)
  push(vel_y, 0.0)
  push(alive_arr, 1.0)
  push(grounded_arr, 0.0)
  i = i + 1.0
end

// ── Boot 3 VMs (one per shader binding layout) ───────────────────────
// Gravity: 3 bindings (vel_y, alive, grounded)
let vm_g = loom_boot(1.0, 3.0, N)
// Move: 5 bindings (pos_x, pos_y, vel_x, vel_y, alive)
let vm_m = loom_boot(1.0, 5.0, N)
// Bounce: 4 bindings (pos_y, vel_y, alive, grounded)
let vm_b = loom_boot(1.0, 4.0, N)

loom_prefetch("tests/gpu_shaders/30_ecs_gravity.spv")
loom_prefetch("tests/gpu_shaders/29_ecs_move.spv")
loom_prefetch("tests/gpu_shaders/31_ecs_bounce.spv")

// Initial register uploads
vm_write_register(vm_g, 0.0, 0.0, vel_y)
vm_write_register(vm_g, 0.0, 1.0, alive_arr)
vm_write_register(vm_g, 0.0, 2.0, grounded_arr)

vm_write_register(vm_m, 0.0, 0.0, pos_x)
vm_write_register(vm_m, 0.0, 1.0, pos_y)
vm_write_register(vm_m, 0.0, 2.0, vel_x)
vm_write_register(vm_m, 0.0, 3.0, vel_y)
vm_write_register(vm_m, 0.0, 4.0, alive_arr)

vm_write_register(vm_b, 0.0, 0.0, pos_y)
vm_write_register(vm_b, 0.0, 1.0, vel_y)
vm_write_register(vm_b, 0.0, 2.0, alive_arr)
vm_write_register(vm_b, 0.0, 3.0, grounded_arr)

// ── Simulate ─────────────────────────────────────────────────────────
let WGS = N / 256.0
let t0 = time()

let mut step = 0.0
while step < STEPS
  // System 1: Gravity — modifies vel_y in vm_g register 0
  loom_dispatch(vm_g, "tests/gpu_shaders/30_ecs_gravity.spv", [GRAVITY, DT], WGS)
  let gp = loom_build(vm_g)
  loom_run(gp)
  loom_free(gp)

  // Transfer updated vel_y to move VM (binding 3)
  let vy_g = loom_read(vm_g, 0.0, 0.0, N)
  vm_write_register(vm_m, 0.0, 3.0, vy_g)

  // System 2: Move — modifies pos_x, pos_y in vm_m registers 0, 1
  loom_dispatch(vm_m, "tests/gpu_shaders/29_ecs_move.spv", [DT], WGS)
  let mp = loom_build(vm_m)
  loom_run(mp)
  loom_free(mp)

  // Transfer updated pos_y to bounce VM (binding 0)
  let py_m = loom_read(vm_m, 0.0, 1.0, N)
  vm_write_register(vm_b, 0.0, 0.0, py_m)
  // Transfer vel_y to bounce VM (binding 1)
  vm_write_register(vm_b, 0.0, 1.0, vy_g)

  // System 3: Bounce — modifies pos_y, vel_y, grounded in vm_b registers 0, 1, 3
  loom_dispatch(vm_b, "tests/gpu_shaders/31_ecs_bounce.spv", [FLOOR, RESTIT], WGS)
  let bp = loom_build(vm_b)
  loom_run(bp)
  loom_free(bp)

  // Transfer updated state back for next frame
  let vy_b = loom_read(vm_b, 0.0, 1.0, N)
  vm_write_register(vm_g, 0.0, 0.0, vy_b)
  let gr_b = loom_read(vm_b, 0.0, 3.0, N)
  vm_write_register(vm_g, 0.0, 2.0, gr_b)
  let py_b = loom_read(vm_b, 0.0, 0.0, N)
  vm_write_register(vm_m, 0.0, 1.0, py_b)

  step = step + 1.0
end

let t1 = time()
let total_ms = (t1 - t0) * 1000.0

// ── Download and analyze ─────────────────────────────────────────────
let final_py = loom_read(vm_b, 0.0, 0.0, N)
let mut above_floor = 0.0
let mut on_floor = 0.0
let mut min_y = 999.0
let mut max_y = -999.0
let mut i = 0.0
while i < N
  let y = final_py[int(i)]
  if y > 0.01
    above_floor = above_floor + 1.0
  else
    on_floor = on_floor + 1.0
  end
  if y < min_y
    min_y = y
  end
  if y > max_y
    max_y = y
  end
  i = i + 1.0
end

let final_gr = loom_read(vm_b, 0.0, 3.0, N)
let mut grounded_count = 0.0
let mut i = 0.0
while i < N
  if final_gr[int(i)] == 1.0
    grounded_count = grounded_count + 1.0
  end
  i = i + 1.0
end

let total_dispatches = STEPS * 3.0
let entity_updates = N * STEPS * 3.0

let mut pass = 1.0
if min_y < -0.01
  pass = 0.0
end

// ── Report ───────────────────────────────────────────────────────────
print("")
print("OctoFlow GPU Entity Component System")
print("  Entities: {N}")
print("  Components: 6 (pos_x, pos_y, vel_x, vel_y, alive, grounded)")
print("  Systems: 3 (gravity, move, bounce)")
print("  Timesteps: {STEPS}")
print("  dt: {DT}")
print("  Dispatches: {total_dispatches} (3 systems x {STEPS} steps)")
print("  Entity updates: {entity_updates}")
print("  CPU entity iterations: 0")
print("  Total time: {total_ms} ms")
print("")
print("  Final state:")
print("    Above floor: {above_floor}")
print("    On floor: {on_floor}")
print("    Grounded (at rest): {grounded_count}")
print("    Y range: [{min_y}, {max_y}]")

if pass == 1.0
  print("  PASS: {N} entities, no floor penetration, physics correct")
else
  print("  FAIL: entities penetrated floor (min_y={min_y})")
end

print("")
loom_shutdown(vm_g)
loom_shutdown(vm_m)
loom_shutdown(vm_b)
