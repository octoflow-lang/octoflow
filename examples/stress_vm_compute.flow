// ====================================================================
//  GPU VM COMPUTE LOAD — Single VM throughput + chain depth
//  Run separately from parallel VM test (clean VRAM state)
// ====================================================================

print("")
print("====================================================================")
print("  GPU VM COMPUTE LOAD — GTX 1660 SUPER (6GB, 1408 CUDA cores)")
print("  Safety ceiling: 85% VRAM = 5.1GB max")
print("====================================================================")

let kernel = "stdlib/loom/kernels/ops/vm_scale.spv"

// ════════════════════════════════════════════════════════════════════
//  PART A: Single VM register size (how much data per VM?)
//  reg_size = elements per register. 32 registers total.
//  VRAM per VM = 32 × reg_size × 4 bytes
// ════════════════════════════════════════════════════════════════════
print("")
print("  PART A: Max register size (1 VM, 10 chained dispatches)")
print("  ────────────────────────────────────────────────────────")
print("")

let reg_tests = [1024.0, 4096.0, 16384.0, 65536.0, 131072.0, 262144.0, 524288.0, 1048576.0]
let mut max_reg = 0.0
let mut ai = 0.0

while ai < len(reg_tests)
  let sz = reg_tests[ai]
  let sz_k = sz / 1024.0
  let wg = floor((sz + 255.0) / 256.0)
  let pc = [0.0, 2.0, sz]
  let mem_mb = 32.0 * sz * 4.0 / 1048576.0

  // Build test data
  let mut data = []
  let mut di = 0.0
  while di < sz
    push(data, 1.0)
    di = di + 1.0
  end

  let r = try(vm_boot(1.0, sz, 1.0))
  if r.ok < 0.5
    print("    {sz_k:.0}K floats ({mem_mb:.0}MB) — BOOT FAILED: {r.error}")
    ai = len(reg_tests)
  else
    let vm = r.value
    let _w = vm_write_register(vm, 0.0, 0.0, data)

    // 10 chained dispatches
    let mut ci = 0.0
    while ci < 10.0
      let _d = vm_dispatch(vm, kernel, pc, wg)
      ci = ci + 1.0
    end
    let prog = vm_build(vm)

    let t0 = now_ms()
    let r2 = try(vm_execute(prog))
    let t_exec = now_ms() - t0

    if r2.ok > 0.5
      let result = vm_read_register(vm, 0.0, 0.0, 4.0)
      let _s = vm_shutdown(vm)
      max_reg = sz
      let val = result[0]
      let total_ops = 10.0 * sz * 2.0
      let gflops = total_ops / (t_exec * 1000000.0)
      print("    {sz_k:.0}K floats ({mem_mb:.0}MB) |  10 dispatch  |  exec: {t_exec:.0}ms  |  {gflops:.1} GFLOP/s  |  val={val:.0}")
    else
      let _s = vm_shutdown(vm)
      print("    {sz_k:.0}K floats ({mem_mb:.0}MB) — EXEC FAILED: {r2.error}")
      ai = len(reg_tests)
    end
  end

  ai = ai + 1.0
end

print("")
print("  ► MAX REGISTER SIZE = {max_reg:.0} floats")

// ════════════════════════════════════════════════════════════════════
//  PART B: Chain depth at different register sizes
// ════════════════════════════════════════════════════════════════════
print("")
print("  PART B: Chain depth scaling")
print("  ───────────────────────────")
print("")

// Test at 64K floats (sweet spot)
let test_sz = 65536.0
let test_wg = floor((test_sz + 255.0) / 256.0)
let test_pc = [0.0, 2.0, test_sz]
let test_mem = 32.0 * test_sz * 4.0 / 1048576.0

print("  Register: {test_sz:.0} floats ({test_mem:.0}MB VRAM)")
print("")

let chain_tests = [10.0, 50.0, 100.0, 500.0, 1000.0, 2000.0, 5000.0, 10000.0, 20000.0]
let mut max_chain = 0.0
let mut bi = 0.0

while bi < len(chain_tests)
  let depth = chain_tests[bi]

  let mut ones = []
  let mut oi = 0.0
  while oi < test_sz
    push(ones, 1.0)
    oi = oi + 1.0
  end

  let r = try(vm_boot(1.0, test_sz, 1.0))
  if r.ok < 0.5
    print("    {depth:.0} dispatches — BOOT FAILED")
    bi = len(chain_tests)
  else
    let vm = r.value
    let _w = vm_write_register(vm, 0.0, 0.0, ones)

    let t0_rec = now_ms()
    let mut di = 0.0
    while di < depth
      let _d = vm_dispatch(vm, kernel, test_pc, test_wg)
      di = di + 1.0
    end
    let t_record = now_ms() - t0_rec

    let prog = vm_build(vm)
    let t0_exec = now_ms()
    let r2 = try(vm_execute(prog))
    let t_exec = now_ms() - t0_exec

    if r2.ok > 0.5
      let _s = vm_shutdown(vm)
      max_chain = depth
      let total_ops = depth * test_sz * 2.0
      let gflops = total_ops / (t_exec * 1000000.0)
      let ops_per_ms = depth / t_exec
      print("    {depth:.0} dispatches  |  record: {t_record:.0}ms  |  exec: {t_exec:.0}ms  |  {gflops:.1} GFLOP/s  |  {ops_per_ms:.1} dispatch/ms")
    else
      let _s = vm_shutdown(vm)
      print("    {depth:.0} dispatches — EXEC FAILED: {r2.error}")
      bi = len(chain_tests)
    end
  end

  bi = bi + 1.0
end

// ════════════════════════════════════════════════════════════════════
//  PART C: Parallel VMs × chain (the real capacity)
//  N VMs each running M chained dispatches
// ════════════════════════════════════════════════════════════════════
print("")
print("  PART C: Parallel VMs × chain depth (reg=1024, sieve planning)")
print("  ──────────────────────────────────────────────────────────────")
print("")

let sieve_reg = 1024.0
let sieve_wg = floor((sieve_reg + 255.0) / 256.0)
let sieve_pc = [0.0, 2.0, sieve_reg]

let mut sieve_data = []
let mut si = 0.0
while si < sieve_reg
  push(sieve_data, 1.0)
  si = si + 1.0
end

// Test combos: VMs × chain
let vm_counts = [4.0, 16.0, 64.0, 256.0, 1024.0]
let chain_count = 500.0

let mut ci = 0.0
while ci < len(vm_counts)
  let nv = vm_counts[ci]
  let total_dispatches = nv * chain_count
  let mem_mb = nv * 32.0 * sieve_reg * 4.0 / 1048576.0

  let t0 = now_ms()

  // Boot all
  let mut vms = []
  let mut boot_ok = 1.0
  let mut bj = 0.0
  while bj < nv
    let r = try(vm_boot(1.0, sieve_reg, 1.0))
    if r.ok > 0.5
      push(vms, r.value)
    else
      boot_ok = 0.0
      bj = nv
    end
    bj = bj + 1.0
  end

  if boot_ok < 0.5
    let mut sj = 0.0
    while sj < len(vms)
      let _s = vm_shutdown(vms[sj])
      sj = sj + 1.0
    end
    print("    {nv:.0} VMs × {chain_count:.0} chain — BOOT FAILED")
    ci = len(vm_counts)
  else
    // Write + chain dispatches + build all
    let mut progs = []
    let mut wj = 0.0
    while wj < nv
      let _w = vm_write_register(vms[wj], 0.0, 0.0, sieve_data)
      let mut dj = 0.0
      while dj < chain_count
        let _d = vm_dispatch(vms[wj], kernel, sieve_pc, sieve_wg)
        dj = dj + 1.0
      end
      let p = vm_build(vms[wj])
      push(progs, p)
      wj = wj + 1.0
    end
    let t_setup = now_ms() - t0

    // Execute all
    let t0e = now_ms()
    let mut ej = 0.0
    while ej < nv
      let _e = vm_execute(progs[ej])
      ej = ej + 1.0
    end
    let t_exec = now_ms() - t0e

    // Shutdown all
    let mut sj = 0.0
    while sj < nv
      let _s = vm_shutdown(vms[sj])
      sj = sj + 1.0
    end
    let t_total = now_ms() - t0

    print("    {nv:.0} VMs × {chain_count:.0} chain = {total_dispatches:.0} dispatches  |  setup: {t_setup:.0}ms  exec: {t_exec:.0}ms  total: {t_total:.0}ms  |  {mem_mb:.0}MB")
  end

  ci = ci + 1.0
end

print("")
print("====================================================================")
print("")
