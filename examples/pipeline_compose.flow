// pipeline_compose.flow — Heterogeneous GPU Pipeline Composition
//
// FOUR dispatches using TWO different shaders in sequence.
// Each dispatch has its own push constant value. This is how real GPU
// workloads compose: normalize → transform → reduce → postprocess.
//
// Pipeline: scale(5) → offset(100) → scale(2) → offset(-50)
// Math: ((x * 5) + 100) * 2 - 50 = 10x + 150
// Input [1, 2, 3, 4] → [160, 170, 180, 190]
//
// Run: octoflow run examples/pipeline_compose.flow --allow-ffi --allow-read

let N = 256.0

let vm = loom_boot(1.0, 2.0, N)
loom_prefetch("tests/gpu_shaders/13_scale.spv")
loom_prefetch("tests/gpu_shaders/14_offset.spv")

// Upload data: [1, 2, 3, ..., 256]
let mut data = []
let mut i = 0.0
while i < N
  push(data, i + 1.0)
  i = i + 1.0
end
vm_write_register(vm, 0.0, 0.0, data)

let mut zeros = []
let mut i = 0.0
while i < N
  push(zeros, 0.0)
  i = i + 1.0
end
vm_write_register(vm, 0.0, 1.0, zeros)

// ── 4-stage pipeline ──────────────────────────────────────────────────
let t0 = time()

// Stage 1: scale(5.0): reg0 → reg1
loom_dispatch(vm, "tests/gpu_shaders/13_scale.spv", [5.0], 1.0)
let p1 = loom_build(vm)
loom_run(p1)
loom_free(p1)
let r1 = loom_read(vm, 0.0, 1.0, N)

// Stage 2: offset(100.0): write r1 to reg0 → dispatch → reg1
vm_write_register(vm, 0.0, 0.0, r1)
loom_dispatch(vm, "tests/gpu_shaders/14_offset.spv", [100.0], 1.0)
let p2 = loom_build(vm)
loom_run(p2)
loom_free(p2)
let r2 = loom_read(vm, 0.0, 1.0, N)

// Stage 3: scale(2.0): write r2 to reg0 → dispatch → reg1
vm_write_register(vm, 0.0, 0.0, r2)
loom_dispatch(vm, "tests/gpu_shaders/13_scale.spv", [2.0], 1.0)
let p3 = loom_build(vm)
loom_run(p3)
loom_free(p3)
let r3 = loom_read(vm, 0.0, 1.0, N)

// Stage 4: offset(-50.0): write r3 to reg0 → dispatch → reg1
vm_write_register(vm, 0.0, 0.0, r3)
loom_dispatch(vm, "tests/gpu_shaders/14_offset.spv", [0.0 - 50.0], 1.0)
let p4 = loom_build(vm)
loom_run(p4)
loom_free(p4)

let t1 = time()
let total_ms = (t1 - t0) * 1000.0

// ── Verify result (bit-exact) ────────────────────────────────────────
// Result: ((x * 5) + 100) * 2 - 50 = 10x + 150
let result = loom_read(vm, 0.0, 1.0, 4.0)

let expected_0 = 160.0
let expected_1 = 170.0
let expected_2 = 180.0
let expected_3 = 190.0

let v0 = result[0]
let v1 = result[1]
let v2 = result[2]
let v3 = result[3]

print("")
print("OctoFlow Pipeline Composition Demo")
print("  Shaders: 13_scale.spv (multiply), 14_offset.spv (add)")
print("  Pipeline: scale(5) -> offset(100) -> scale(2) -> offset(-50)")
print("  Math: ((x * 5) + 100) * 2 - 50 = 10x + 150")
print("  Dispatches: 4 (2 scale + 2 offset)")
print("  Pipelines: 2 (heterogeneous)")
print("  Push constants: 4 (one per dispatch)")
print("  Total time: {total_ms} ms")
print("  Result[0..3]: [{v0}, {v1}, {v2}, {v3}]")
print("  Expected:     [{expected_0}, {expected_1}, {expected_2}, {expected_3}]")

if v0 == expected_0
  if v1 == expected_1
    if v2 == expected_2
      if v3 == expected_3
        print("  EXACT MATCH")
      else
        print("  MISMATCH: v3 got {v3}, expected {expected_3}")
      end
    else
      print("  MISMATCH: v2 got {v2}, expected {expected_2}")
    end
  else
    print("  MISMATCH: v1 got {v1}, expected {expected_1}")
  end
else
  print("  MISMATCH: v0 got {v0}, expected {expected_0}")
end

print("")
loom_shutdown(vm)
