// pipeline_compose.flow — Heterogeneous GPU Pipeline Composition
//
// FOUR dispatches using TWO different shaders in a single command buffer.
// Each dispatch has its own push constant value. This is how real GPU
// workloads compose: normalize → transform → reduce → postprocess.
//
// Pipeline: scale(5) → offset(100) → scale(2) → offset(-50)
// Math: ((x * 5) + 100) * 2 - 50 = 10x + 150
// Input [1, 2, 3, 4] → [160, 170, 180, 190]
//
// Buffer reuse with barriers:
//   scale(5):     A → B
//   offset(100):  B → C
//   scale(2):     C → B  (safe: barrier ensures offset completed)
//   offset(-50):  B → A  (safe: barrier ensures scale completed)
//   Result in A.
//
// Run: octoflow run examples/pipeline_compose.flow --allow-ffi --allow-read

use "../stdlib/loom/ops/runtime"

let N = 256.0
let BUF_BYTES = N * 4.0

// Boot GPU
rt_init()

// Load two pipelines
let pipe_scale = rt_load_pipeline("tests/gpu_shaders/13_scale.spv", 2.0, 4.0)
let pipe_offset = rt_load_pipeline("tests/gpu_shaders/14_offset.spv", 2.0, 4.0)

// Create 3 buffers (reused across 4 stages)
let buf_a = rt_create_buffer(BUF_BYTES)
let buf_b = rt_create_buffer(BUF_BYTES)
let buf_c = rt_create_buffer(BUF_BYTES)

// Upload data: [1, 2, 3, ..., 256]
let mut data = []
let mut i = 0.0
while i < N
  push(data, i + 1.0)
  i = i + 1.0
end
rt_upload(buf_a, data)

// Zero working buffers
let mut zeros = []
let mut i = 0.0
while i < N
  push(zeros, 0.0)
  i = i + 1.0
end
rt_upload(buf_b, zeros)
rt_upload(buf_c, zeros)

// ── Record 4-stage pipeline ──────────────────────────────────────────
let t0 = time()

rt_chain_begin(4.0, 2.0)

// Stage 1: scale(5.0): A → B
let mut pc1 = [5.0]
rt_chain_push_constants(pipe_scale, pc1)
let mut bufs1 = [buf_a, buf_b]
rt_chain_dispatch(pipe_scale, bufs1, 1.0)

// Stage 2: offset(100.0): B → C
let mut pc2 = [100.0]
rt_chain_push_constants(pipe_offset, pc2)
let mut bufs2 = [buf_b, buf_c]
rt_chain_dispatch(pipe_offset, bufs2, 1.0)

// Stage 3: scale(2.0): C → B (reuse B, safe after barrier)
let mut pc3 = [2.0]
rt_chain_push_constants(pipe_scale, pc3)
let mut bufs3 = [buf_c, buf_b]
rt_chain_dispatch(pipe_scale, bufs3, 1.0)

// Stage 4: offset(-50.0): B → A (reuse A, safe after barrier)
let mut pc4 = [0.0 - 50.0]
rt_chain_push_constants(pipe_offset, pc4)
let mut bufs4 = [buf_b, buf_a]
rt_chain_dispatch(pipe_offset, bufs4, 1.0)

rt_chain_end()
let t1 = time()
let record_ms = (t1 - t0) * 1000.0

// ── Single submit — GPU runs all 4 stages ────────────────────────────
let t2 = time()
rt_chain_submit_wait()
let t3 = time()
let gpu_ms = (t3 - t2) * 1000.0

// ── Verify result (bit-exact) ────────────────────────────────────────
// Result in A: ((x * 5) + 100) * 2 - 50 = 10x + 150
rt_download(buf_a, 4.0)

let expected_0 = 160.0
let expected_1 = 170.0
let expected_2 = 180.0
let expected_3 = 190.0

let v0 = rt_result[0]
let v1 = rt_result[1]
let v2 = rt_result[2]
let v3 = rt_result[3]

print("")
print("OctoFlow Pipeline Composition Demo")
print("  Shaders: 13_scale.spv (multiply), 14_offset.spv (add)")
print("  Pipeline: scale(5) -> offset(100) -> scale(2) -> offset(-50)")
print("  Math: ((x * 5) + 100) * 2 - 50 = 10x + 150")
print("  Dispatches: 4 (2 scale + 2 offset)")
print("  Pipelines: 2 (heterogeneous)")
print("  Push constants: 4 (one per dispatch)")
print("  Submissions: 1")
print("  Buffers: 3 (reused across stages)")
print("  Record time: {record_ms} ms")
print("  GPU time:    {gpu_ms} ms")
print("  Result[0..3]: [{v0}, {v1}, {v2}, {v3}]")
print("  Expected:     [{expected_0}, {expected_1}, {expected_2}, {expected_3}]")

if v0 == expected_0 && v1 == expected_1 && v2 == expected_2 && v3 == expected_3
  print("  EXACT MATCH")
else
  print("  MISMATCH")
  if v0 != expected_0
    print("    v0: got {v0}, expected {expected_0}")
  end
  if v1 != expected_1
    print("    v1: got {v1}, expected {expected_1}")
  end
end

print("")
rt_cleanup()
