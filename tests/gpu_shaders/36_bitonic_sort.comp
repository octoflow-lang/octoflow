#version 450
// bitonic_sort â€” One step of the bitonic merge sort network (XOR formulation)
//
// Standard bitonic sort: each dispatch performs one compare-and-swap step.
// Host dispatches with varying (k, j) to walk the sorting network:
//   for k = 2, 4, 8, ..., N:
//     for j = k/2, k/4, ..., 1:
//       dispatch(k, j, N)
//
// Each thread: partner = gid XOR j. Lower-indexed thread swaps if needed.
// Direction: ascending if (gid AND k) == 0, descending otherwise.
//
// In-place sort on a single float buffer.
// 1 binding (data), 3 push constants (k, j, N) = 12 bytes
layout(local_size_x = 256) in;

layout(set=0, binding=0) buffer Data { float data[]; } arr;
layout(push_constant) uniform PC {
    float step_size;    // k: outer loop variable (power of 2)
    float substep_size; // j: inner loop variable (power of 2)
    float n_elements;   // N: array size
} pc;

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint k = uint(pc.step_size);
    uint j = uint(pc.substep_size);
    uint N = uint(pc.n_elements);

    if (gid >= N) return;

    uint partner = gid ^ j;

    // Only the lower-indexed thread of each pair does the swap
    if (partner <= gid || partner >= N) return;

    bool ascending = ((gid & k) == 0u);
    float a = arr.data[gid];
    float b = arr.data[partner];

    if ((ascending && a > b) || (!ascending && a < b)) {
        arr.data[gid] = b;
        arr.data[partner] = a;
    }
}
