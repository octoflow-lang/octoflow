#version 450
// lz4_decompress â€” LZ4 block decompression (one thread per block)
//
// LZ4 frame format (simplified):
//   Each block is a sequence of (literal_length, literals, match_length, match_offset) sequences.
//   Token byte: high nibble = literal length, low nibble = match length (+ 4 minimum)
//
// Input: compressed blocks as byte-per-float
//   Layout: [block_offset_0, block_offset_1, ..., block_offset_N, compressed_data...]
//   First N+1 floats are offsets into the compressed data (relative to data start)
//
// Output: decompressed bytes as byte-per-float
//   Layout: [decompressed_data...] (fixed output size per block)
//
// 2 bindings, 2 push constants (n_blocks, output_block_size)
layout(local_size_x = 256) in;

layout(set=0, binding=0) buffer Input  { float data[]; } inp;
layout(set=0, binding=1) buffer Output { float data[]; } out_;
layout(push_constant) uniform PC {
    float n_blocks;
    float out_block_size;
} pc;

void main() {
    uint tid = gl_GlobalInvocationID.x;
    uint N = uint(pc.n_blocks);
    uint OUT_SZ = uint(pc.out_block_size);

    if (tid >= N) return;

    // Block offsets are stored at the beginning of input
    // Data starts at offset N+1
    uint data_base = N + 1u;
    uint src_start = uint(inp.data[tid]) + data_base;
    uint src_end   = uint(inp.data[tid + 1u]) + data_base;
    uint dst_base  = tid * OUT_SZ;

    uint src = src_start;
    uint dst = 0u;

    while (src < src_end && dst < OUT_SZ) {
        // Read token
        uint token = uint(inp.data[src]);
        src++;

        // Literal length
        uint lit_len = token >> 4u;
        if (lit_len == 15u) {
            // Extended literal length
            while (src < src_end) {
                uint extra = uint(inp.data[src]);
                src++;
                lit_len += extra;
                if (extra != 255u) break;
            }
        }

        // Copy literals
        for (uint i = 0u; i < lit_len && dst < OUT_SZ; i++) {
            out_.data[dst_base + dst] = inp.data[src];
            src++;
            dst++;
        }

        // If we've consumed all input, no match follows
        if (src >= src_end) break;

        // Match offset (2 bytes, little-endian)
        uint offset = uint(inp.data[src]) + uint(inp.data[src + 1u]) * 256u;
        src += 2u;

        // Match length (minimum 4)
        uint match_len = (token & 0xFu) + 4u;
        if ((token & 0xFu) == 15u) {
            while (src < src_end) {
                uint extra = uint(inp.data[src]);
                src++;
                match_len += extra;
                if (extra != 255u) break;
            }
        }

        // Copy match (from already-decompressed output, may overlap)
        uint match_src = dst - offset;
        for (uint i = 0u; i < match_len && dst < OUT_SZ; i++) {
            out_.data[dst_base + dst] = out_.data[dst_base + match_src + i];
            dst++;
        }
    }
}
