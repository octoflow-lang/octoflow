#version 450
// palette_quantize â€” Convert RGB pixels to palette indices (nearest color)
//
// Each thread processes one pixel: finds nearest palette entry via
// Euclidean distance in RGB space. Fully parallel across all pixels.
//
// Input: RGB888 pixels as 3 separate float buffers (r[], g[], b[])
// Output: Palette indices as float buffer
// Push constants: n_pixels, n_colors (8 bytes)
//
// Palette stored in 3 separate bindings (palette_r[], palette_g[], palette_b[])
// Total: 6 bindings, 2 push constants
layout(local_size_x = 256) in;

layout(set=0, binding=0) buffer PixelsR   { float data[]; } pix_r;
layout(set=0, binding=1) buffer PixelsG   { float data[]; } pix_g;
layout(set=0, binding=2) buffer PixelsB   { float data[]; } pix_b;
layout(set=0, binding=3) buffer PaletteR  { float data[]; } pal_r;
layout(set=0, binding=4) buffer PaletteG  { float data[]; } pal_g;
layout(set=0, binding=5) buffer PaletteB  { float data[]; } pal_b;
layout(set=0, binding=6) buffer Indices   { float data[]; } out_idx;

layout(push_constant) uniform PC {
    float n_pixels;
    float n_colors;
} pc;

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint N = uint(pc.n_pixels);
    uint C = uint(pc.n_colors);

    if (gid >= N) return;

    float r = pix_r.data[gid];
    float g = pix_g.data[gid];
    float b = pix_b.data[gid];

    // Find nearest palette entry
    float min_dist = 1e9;
    float best_idx = 0.0;

    for (uint i = 0u; i < C; i++) {
        float dr = r - pal_r.data[i];
        float dg = g - pal_g.data[i];
        float db = b - pal_b.data[i];
        float dist = dr*dr + dg*dg + db*db;

        if (dist < min_dist) {
            min_dist = dist;
            best_idx = float(i);
        }
    }

    out_idx.data[gid] = best_idx;
}
