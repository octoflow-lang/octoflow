#version 450
// argmin — Find index of minimum value via parallel reduction
//
// Each workgroup reduces its chunk to (min_value, min_index).
// Output: two arrays — values[wg_id] and indices[wg_id].
// For multi-pass: run again on the partial results.
//
// 3 bindings (input values, output values, output indices), 1 push constant (4B)
layout(local_size_x = 256) in;

layout(set=0, binding=0) buffer Input     { float data[]; } inp;
layout(set=0, binding=1) buffer OutValues { float data[]; } out_val;
layout(set=0, binding=2) buffer OutIndex  { float data[]; } out_idx;
layout(push_constant) uniform PC { float n_elements; } pc;

shared float s_val[256];
shared float s_idx[256];

void main() {
    uint tid = gl_LocalInvocationID.x;
    uint gid = gl_GlobalInvocationID.x;
    uint wid = gl_WorkGroupID.x;
    uint N = uint(pc.n_elements);

    // Load: each thread loads one element (or +infinity sentinel)
    if (gid < N) {
        s_val[tid] = inp.data[gid];
        s_idx[tid] = float(gid);
    } else {
        s_val[tid] = 1.0 / 0.0;  // +infinity
        s_idx[tid] = -1.0;
    }
    barrier();

    // Tree reduction: keep (value, index) of the minimum
    for (uint stride = 128u; stride > 0u; stride >>= 1u) {
        if (tid < stride) {
            if (s_val[tid + stride] < s_val[tid]) {
                s_val[tid] = s_val[tid + stride];
                s_idx[tid] = s_idx[tid + stride];
            }
        }
        barrier();
    }

    // Thread 0 writes the workgroup's result
    if (tid == 0u) {
        out_val.data[wid] = s_val[0];
        out_idx.data[wid] = s_idx[0];
    }
}
