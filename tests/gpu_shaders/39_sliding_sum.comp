#version 450
// sliding_sum — Compute sliding window sum for each element
//
// For each element i: out[i] = sum(inp[max(0, i-W+1) .. i])
// where W is the window size. This is a "trailing" or "causal" window.
//
// Simple O(N×W) approach — each thread sums its own window.
// For large W, a prefix-sum-based O(N) approach would be better:
//   out[i] = prefix[i+1] - prefix[i-W+1]
// But the direct approach is correct, simple, and sufficient for W ≤ 256.
//
// 2 bindings (input, output), 2 push constants (N, W) = 8 bytes
layout(local_size_x = 256) in;

layout(set=0, binding=0) buffer Input  { float data[]; } inp;
layout(set=0, binding=1) buffer Output { float data[]; } out_;
layout(push_constant) uniform PC {
    float n_elements;
    float window_size;
} pc;

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint N = uint(pc.n_elements);
    uint W = uint(pc.window_size);

    if (gid >= N) return;

    // Sum elements in the window [max(0, gid-W+1) .. gid]
    float sum = 0.0;
    uint start = (gid >= W - 1u) ? (gid - W + 1u) : 0u;
    for (uint j = start; j <= gid; j++) {
        sum += inp.data[j];
    }

    out_.data[gid] = sum;
}
