#version 450
// histogram — Per-element binning with shared-memory atomic accumulation
//
// Each workgroup builds a local histogram in shared memory using atomicAdd,
// then accumulates into the global output buffer (also uint atomicAdd).
// Output is uint[] — use 35_uint_to_float.comp to convert for OctoFlow.
//
// 2 bindings (input float[], output uint[]), 4 push constants (16 bytes)
// Supports up to 256 bins (limited by shared memory / workgroup size)
layout(local_size_x = 256) in;

layout(set=0, binding=0) buffer Input  { float data[]; } inp;
layout(set=0, binding=1) buffer Output { uint  bins[]; } out_;
layout(push_constant) uniform PC {
    float n_elements;
    float num_bins;
    float min_val;
    float bin_width;
} pc;

shared uint local_hist[256];

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint tid = gl_LocalInvocationID.x;
    uint N = uint(pc.n_elements);
    uint nbins = uint(pc.num_bins);

    // Zero local histogram (each thread zeros one slot)
    if (tid < nbins) {
        local_hist[tid] = 0u;
    }
    barrier();

    // Bin this element into local histogram
    if (gid < N) {
        float val = inp.data[gid];
        int bin = int(floor((val - pc.min_val) / pc.bin_width));
        if (bin < 0) bin = 0;
        if (bin >= int(nbins)) bin = int(nbins) - 1;
        atomicAdd(local_hist[uint(bin)], 1u);
    }
    barrier();

    // Accumulate local histogram into global output (atomic for multi-WG)
    if (tid < nbins) {
        atomicAdd(out_.bins[tid], local_hist[tid]);
    }
}
