#version 450
// argmax â€” Find index of maximum value via parallel reduction
//
// Same structure as argmin but tracks maximum.
// 3 bindings (input values, output values, output indices), 1 push constant (4B)
layout(local_size_x = 256) in;

layout(set=0, binding=0) buffer Input     { float data[]; } inp;
layout(set=0, binding=1) buffer OutValues { float data[]; } out_val;
layout(set=0, binding=2) buffer OutIndex  { float data[]; } out_idx;
layout(push_constant) uniform PC { float n_elements; } pc;

shared float s_val[256];
shared float s_idx[256];

void main() {
    uint tid = gl_LocalInvocationID.x;
    uint gid = gl_GlobalInvocationID.x;
    uint wid = gl_WorkGroupID.x;
    uint N = uint(pc.n_elements);

    if (gid < N) {
        s_val[tid] = inp.data[gid];
        s_idx[tid] = float(gid);
    } else {
        s_val[tid] = -1.0 / 0.0;  // -infinity
        s_idx[tid] = -1.0;
    }
    barrier();

    for (uint stride = 128u; stride > 0u; stride >>= 1u) {
        if (tid < stride) {
            if (s_val[tid + stride] > s_val[tid]) {
                s_val[tid] = s_val[tid + stride];
                s_idx[tid] = s_idx[tid + stride];
            }
        }
        barrier();
    }

    if (tid == 0u) {
        out_val.data[wid] = s_val[0];
        out_idx.data[wid] = s_idx[0];
    }
}
