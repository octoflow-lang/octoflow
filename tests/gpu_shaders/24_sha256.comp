#version 450
// sha256 — SHA-256 hash of N independent 64-byte (pre-padded) messages
// Input:  N×64 floats (byte-per-float, 0-255)
// Output: N×32 floats (byte-per-float, 0-255)
// Each thread hashes one message. Embarrassingly parallel.
// 2 bindings, 1 push constant (N = number of messages).
layout(local_size_x = 256) in;

layout(set=0, binding=0) buffer Input  { float data[]; } inp;
layout(set=0, binding=1) buffer Output { float data[]; } out_;
layout(push_constant) uniform PC { float n_messages; } pc;

// SHA-256 round constants (FIPS 180-4 Section 4.2.2)
const uint K[64] = uint[64](
    0x428a2f98u, 0x71374491u, 0xb5c0fbcfu, 0xe9b5dba5u,
    0x3956c25bu, 0x59f111f1u, 0x923f82a4u, 0xab1c5ed5u,
    0xd807aa98u, 0x12835b01u, 0x243185beu, 0x550c7dc3u,
    0x72be5d74u, 0x80deb1feu, 0x9bdc06a7u, 0xc19bf174u,
    0xe49b69c1u, 0xefbe4786u, 0x0fc19dc6u, 0x240ca1ccu,
    0x2de92c6fu, 0x4a7484aau, 0x5cb0a9dcu, 0x76f988dau,
    0x983e5152u, 0xa831c66du, 0xb00327c8u, 0xbf597fc7u,
    0xc6e00bf3u, 0xd5a79147u, 0x06ca6351u, 0x14292967u,
    0x27b70a85u, 0x2e1b2138u, 0x4d2c6dfcu, 0x53380d13u,
    0x650a7354u, 0x766a0abbu, 0x81c2c92eu, 0x92722c85u,
    0xa2bfe8a1u, 0xa81a664bu, 0xc24b8b70u, 0xc76c51a3u,
    0xd192e819u, 0xd6990624u, 0xf40e3585u, 0x106aa070u,
    0x19a4c116u, 0x1e376c08u, 0x2748774cu, 0x34b0bcb5u,
    0x391c0cb3u, 0x4ed8aa4au, 0x5b9cca4fu, 0x682e6ff3u,
    0x748f82eeu, 0x78a5636fu, 0x84c87814u, 0x8cc70208u,
    0x90befffau, 0xa4506cebu, 0xbef9a3f7u, 0xc67178f2u
);

uint rotr(uint x, uint n) { return (x >> n) | (x << (32u - n)); }
uint ch(uint x, uint y, uint z)  { return (x & y) ^ (~x & z); }
uint maj(uint x, uint y, uint z) { return (x & y) ^ (x & z) ^ (y & z); }
uint bsig0(uint x) { return rotr(x, 2u) ^ rotr(x, 13u) ^ rotr(x, 22u); }
uint bsig1(uint x) { return rotr(x, 6u) ^ rotr(x, 11u) ^ rotr(x, 25u); }
uint ssig0(uint x) { return rotr(x, 7u) ^ rotr(x, 18u) ^ (x >> 3u); }
uint ssig1(uint x) { return rotr(x, 17u) ^ rotr(x, 19u) ^ (x >> 10u); }

void main() {
    uint tid = gl_GlobalInvocationID.x;
    if (tid >= uint(pc.n_messages)) return;

    uint bi = tid * 64u;  // input base (64 floats per message)
    uint bo = tid * 32u;  // output base (32 floats per hash)

    // Load 64 bytes → 16 uint32 words (big-endian)
    uint w[16];
    for (uint i = 0u; i < 16u; i++) {
        uint off = bi + i * 4u;
        w[i] = (uint(inp.data[off]) << 24u)
             | (uint(inp.data[off + 1u]) << 16u)
             | (uint(inp.data[off + 2u]) << 8u)
             |  uint(inp.data[off + 3u]);
    }

    // Initial hash values (FIPS 180-4 Section 5.3.3)
    uint H0 = 0x6a09e667u, H1 = 0xbb67ae85u;
    uint H2 = 0x3c6ef372u, H3 = 0xa54ff53au;
    uint H4 = 0x510e527fu, H5 = 0x9b05688cu;
    uint H6 = 0x1f83d9abu, H7 = 0x5be0cd19u;

    uint a = H0, b = H1, c = H2, d = H3;
    uint e = H4, f = H5, g = H6, h = H7;

    // 64 compression rounds with rolling message schedule
    for (uint i = 0u; i < 64u; i++) {
        if (i >= 16u) {
            uint j = i & 0xFu;
            w[j] = ssig1(w[(j + 14u) & 0xFu]) + w[(j + 9u) & 0xFu]
                 + ssig0(w[(j + 1u) & 0xFu]) + w[j];
        }

        uint t1 = h + bsig1(e) + ch(e, f, g) + K[i] + w[i & 0xFu];
        uint t2 = bsig0(a) + maj(a, b, c);

        h = g; g = f; f = e; e = d + t1;
        d = c; c = b; b = a; a = t1 + t2;
    }

    H0 += a; H1 += b; H2 += c; H3 += d;
    H4 += e; H5 += f; H6 += g; H7 += h;

    // Write 8 hash words as 32 bytes (big-endian, byte-per-float)
    uint hv[8];
    hv[0] = H0; hv[1] = H1; hv[2] = H2; hv[3] = H3;
    hv[4] = H4; hv[5] = H5; hv[6] = H6; hv[7] = H7;
    for (uint i = 0u; i < 8u; i++) {
        uint v = hv[i];
        uint off = bo + i * 4u;
        out_.data[off]      = float((v >> 24u) & 0xFFu);
        out_.data[off + 1u] = float((v >> 16u) & 0xFFu);
        out_.data[off + 2u] = float((v >> 8u)  & 0xFFu);
        out_.data[off + 3u] = float(v & 0xFFu);
    }
}
