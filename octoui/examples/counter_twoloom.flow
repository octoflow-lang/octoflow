// counter_twoloom.flow — Loom Engine: Main + Support Loom
//
// Demonstrates the Loom Engine architecture:
//   Main Loom (RENDER): GPU-only compute. Shader dispatches, framebuffer.
//   Support Loom (STATE): CPU↔GPU I/O bridge. State log, undo/redo, persistence.
//
// Main Loom cannot boot without Support — I/O is required for VRAM allocation,
// initial data upload, and result presentation. This IS the Loom Engine.
//
// Architecture:
//   Click +/- → CPU updates counter → loom_write(Support) → GPU state log
//   Ctrl+Z    → loom_read_globals(Support) → CPU restore
//   Render    → loom_dispatch(Main) → loom_launch(Main) → GPU compute
//   Present   → loom_wait(Main) → loom_present(Main) → window (Support orchestrates)
//
// Run:
//   octoflow run octoui/examples/counter_twoloom.flow --allow-read --allow-write --allow-ffi --max-iters 1000000

use "../engine/tree"
use "../engine/layout"
use "../engine/pipeline"
use "../engine/dirty"
use "../themes/dark"
use "../widgets/core/box"
use "../widgets/core/text"
use "../widgets/input/button"
use "../widgets/layout/column"
use "../widgets/layout/row"
use "../state/reactive"
use "../platform/desktop/window_win32"
use "../platform/desktop/input"

// ── Window ────────────────────────────────────────────────────────
let _w = ui_window_open(400.0, 300.0, "Two-Loom Counter")

// ── Support Loom: State Log ──────────────────────────────────────
// GPU-resident state log. Each snapshot = 1 float (the counter value).
// globals layout: [snap_0, snap_1, snap_2, ..., snap_N]
// Capacity: 256 snapshots.
let STATE_CAPACITY = 256.0

// Support Loom — GPU-resident state log (CPU↔GPU I/O bridge)
// Globals buffer: [snap_0, snap_1, ..., snap_255]
// Array element holds VM ID (OctoFlow scalars don't propagate across functions).
// _sl: [0]=vm_id [1]=count [2]=cursor
let mut _sl = [0.0, 0.0, 0.0]

fn support_init()
  let vm = loom_boot(1.0, 0.0, STATE_CAPACITY)  // lightweight: globals only
  _sl[0] = vm
  _sl[1] = 0.0
  _sl[2] = 0.0
  return vm
end

// Write a snapshot to Support Loom (CPU → GPU)
fn support_push(value)
  // If cursor is behind count, we undid — discard forward history
  if _sl[2] < _sl[1]
    _sl[1] = _sl[2]
  end

  // Write value to State Loom globals at cursor offset
  let mut snap = [value]
  let offset = _sl[1]
  let vm = _sl[0]
  let _w = loom_write(vm, offset, snap)

  _sl[1] = _sl[1] + 1.0
  _sl[2] = _sl[1]
  return 0.0
end

// Read a snapshot from Support Loom (GPU → CPU)
fn support_read(index)
  let vm = _sl[0]
  let result = loom_read_globals(vm, index, 1.0)
  return result[0]
end

// Undo: move cursor back, read previous state from GPU
fn support_undo()
  if _sl[2] <= 1.0
    return -9999.0
  end
  _sl[2] = _sl[2] - 1.0
  let val = support_read(_sl[2] - 1.0)
  return val
end

// Redo: move cursor forward, read next state from GPU
fn support_redo()
  if _sl[2] >= _sl[1]
    return -9999.0
  end
  let val = support_read(_sl[2])
  _sl[2] = _sl[2] + 1.0
  return val
end

// ── Reactive State ────────────────────────────────────────────────
let counter = ui_state(0.0)

// ── Widget Tree ───────────────────────────────────────────────────
let root = ui_column(-1.0, 10.0)
let _sp = ui_tree_set_padding(root, 40.0)
let _sr = ui_tree_set_pos(root, 0.0, 0.0)
let _ss = ui_tree_set_size(root, 400.0, 300.0)

// Title
let title = ui_text(root, "TWO-LOOM COUNTER", UI_COLOR_TEXT)

// Counter display — bound to reactive state
let display = ui_text(root, "0", UI_COLOR_PRIMARY)
let _bind = ui_bind_text(display, counter)

// Status line — shows Support Loom state
let status = ui_text(root, "Support: 0/0 | Z=undo Y=redo", UI_COLOR_TEXT_DIM)

// Button row
let btn_row = ui_row(root, 20.0)
let btn_dec = ui_button(btn_row, 80.0, 40.0, " - ")
let btn_inc = ui_button(btn_row, 80.0, 40.0, " + ")

// Undo/redo row
let undo_row = ui_row(root, 20.0)
let btn_undo = ui_button(undo_row, 80.0, 36.0, "Undo")
let btn_redo = ui_button(undo_row, 80.0, 36.0, "Redo")

// Initial layout
let _l = ui_layout_update()

// Boot Support Loom + push initial state (counter = 0)
let _slvm = support_init()
let _init = support_push(0.0)

// ── Event Loop ────────────────────────────────────────────────────
let mut running = 1.0
while running == 1.0
  let alive = ui_poll_events()
  if alive == 0.0
    running = 0.0
  end

  if ui_key_pressed("escape") == 1.0
    running = 0.0
  end

  let _pi = ui_process_input()

  // ── Increment ───────────────────────────────────────────────
  if ui_button_clicked(btn_inc) == 1.0
    let val = ui_state_get(counter)
    let new_val = val + 1.0
    let _s = ui_state_set(counter, new_val)
    let _log = support_push(new_val)
  end

  // ── Decrement ───────────────────────────────────────────────
  if ui_button_clicked(btn_dec) == 1.0
    let val = ui_state_get(counter)
    let new_val = val - 1.0
    let _s = ui_state_set(counter, new_val)
    let _log = support_push(new_val)
  end

  // ── Undo (button or Z key) ─────────────────────────────────
  let mut did_undo = 0.0
  if ui_button_clicked(btn_undo) == 1.0
    did_undo = 1.0
  end
  if ui_key_pressed("z") == 1.0
    did_undo = 1.0
  end
  if did_undo == 1.0
    let restored = support_undo()
    if restored != -9999.0
      let _s = ui_state_set(counter, restored)
    end
  end

  // ── Redo (button or Y key) ─────────────────────────────────
  let mut did_redo = 0.0
  if ui_button_clicked(btn_redo) == 1.0
    did_redo = 1.0
  end
  if ui_key_pressed("y") == 1.0
    did_redo = 1.0
  end
  if did_redo == 1.0
    let restored = support_redo()
    if restored != -9999.0
      let _s = ui_state_set(counter, restored)
    end
  end

  // ── Update status line ──────────────────────────────────────
  let cursor_str = str(_sl[2])
  let count_str = str(_sl[1])
  _ui_texts[status] = "Support: " + cursor_str + "/" + count_str + " | Z=undo Y=redo"
  let _md = ui_mark_dirty()

  // ── Render (Main Loom — double-buffered, Support orchestrates) ──
  if ui_is_dirty() == 1.0
    let _r = ui_pipeline_render()
    let _cd = ui_clear_dirty()
  else
    let _p = ui_pipeline_present()
    let _idle = sleep(16.0)
  end
end

// ── Cleanup ───────────────────────────────────────────────────────
// Support Loom shutdown
let _shutdown = loom_shutdown(_sl[0])
let _c = ui_window_close()
let final_val = ui_state_get(counter)
let final_snaps = _sl[1]
print("Two-Loom counter finished.")
print("Final counter: {final_val}")
print("Support Loom: {final_snaps} snapshots")
